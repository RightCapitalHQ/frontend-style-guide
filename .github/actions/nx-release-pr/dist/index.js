/*! For license information please see index.js.LICENSE.txt */
var __webpack_modules__ = {
    "../../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const cp = __webpack_require__("child_process");
        const parse = __webpack_require__("../../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/parse.js");
        const enoent = __webpack_require__("../../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/enoent.js");
        function spawn(command, args, options) {
            const parsed = parse(command, args, options);
            const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
            enoent.hookChildProcess(spawned, parsed);
            return spawned;
        }
        function spawnSync(command, args, options) {
            const parsed = parse(command, args, options);
            const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
            result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
            return result;
        }
        module.exports = spawn;
        module.exports.spawn = spawn;
        module.exports.sync = spawnSync;
        module.exports._parse = parse;
        module.exports._enoent = enoent;
    },
    "../../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/enoent.js" (module) {
        "use strict";
        const isWin = 'win32' === process.platform;
        function notFoundError(original, syscall) {
            return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
                code: 'ENOENT',
                errno: 'ENOENT',
                syscall: `${syscall} ${original.command}`,
                path: original.command,
                spawnargs: original.args
            });
        }
        function hookChildProcess(cp, parsed) {
            if (!isWin) return;
            const originalEmit = cp.emit;
            cp.emit = function(name, arg1) {
                if ('exit' === name) {
                    const err = verifyENOENT(arg1, parsed);
                    if (err) return originalEmit.call(cp, 'error', err);
                }
                return originalEmit.apply(cp, arguments);
            };
        }
        function verifyENOENT(status, parsed) {
            if (isWin && 1 === status && !parsed.file) return notFoundError(parsed.original, 'spawn');
            return null;
        }
        function verifyENOENTSync(status, parsed) {
            if (isWin && 1 === status && !parsed.file) return notFoundError(parsed.original, 'spawnSync');
            return null;
        }
        module.exports = {
            hookChildProcess,
            verifyENOENT,
            verifyENOENTSync,
            notFoundError
        };
    },
    "../../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/parse.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const path = __webpack_require__("path");
        const resolveCommand = __webpack_require__("../../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/resolveCommand.js");
        const escape = __webpack_require__("../../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/escape.js");
        const readShebang = __webpack_require__("../../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/readShebang.js");
        const isWin = 'win32' === process.platform;
        const isExecutableRegExp = /\.(?:com|exe)$/i;
        const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
        function detectShebang(parsed) {
            parsed.file = resolveCommand(parsed);
            const shebang = parsed.file && readShebang(parsed.file);
            if (shebang) {
                parsed.args.unshift(parsed.file);
                parsed.command = shebang;
                return resolveCommand(parsed);
            }
            return parsed.file;
        }
        function parseNonShell(parsed) {
            if (!isWin) return parsed;
            const commandFile = detectShebang(parsed);
            const needsShell = !isExecutableRegExp.test(commandFile);
            if (parsed.options.forceShell || needsShell) {
                const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
                parsed.command = path.normalize(parsed.command);
                parsed.command = escape.command(parsed.command);
                parsed.args = parsed.args.map((arg)=>escape.argument(arg, needsDoubleEscapeMetaChars));
                const shellCommand = [
                    parsed.command
                ].concat(parsed.args).join(' ');
                parsed.args = [
                    '/d',
                    '/s',
                    '/c',
                    `"${shellCommand}"`
                ];
                parsed.command = process.env.comspec || 'cmd.exe';
                parsed.options.windowsVerbatimArguments = true;
            }
            return parsed;
        }
        function parse(command, args, options) {
            if (args && !Array.isArray(args)) {
                options = args;
                args = null;
            }
            args = args ? args.slice(0) : [];
            options = Object.assign({}, options);
            const parsed = {
                command,
                args,
                options,
                file: void 0,
                original: {
                    command,
                    args
                }
            };
            return options.shell ? parsed : parseNonShell(parsed);
        }
        module.exports = parse;
    },
    "../../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/escape.js" (module) {
        "use strict";
        const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
        function escapeCommand(arg) {
            arg = arg.replace(metaCharsRegExp, '^$1');
            return arg;
        }
        function escapeArgument(arg, doubleEscapeMetaChars) {
            arg = `${arg}`;
            arg = arg.replace(/(?=(\\+?)?)\1"/g, '$1$1\\"');
            arg = arg.replace(/(?=(\\+?)?)\1$/, '$1$1');
            arg = `"${arg}"`;
            arg = arg.replace(metaCharsRegExp, '^$1');
            if (doubleEscapeMetaChars) arg = arg.replace(metaCharsRegExp, '^$1');
            return arg;
        }
        module.exports.command = escapeCommand;
        module.exports.argument = escapeArgument;
    },
    "../../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/readShebang.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const fs = __webpack_require__("fs");
        const shebangCommand = __webpack_require__("../../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js");
        function readShebang(command) {
            const size = 150;
            const buffer = Buffer.alloc(size);
            let fd;
            try {
                fd = fs.openSync(command, 'r');
                fs.readSync(fd, buffer, 0, size, 0);
                fs.closeSync(fd);
            } catch (e) {}
            return shebangCommand(buffer.toString());
        }
        module.exports = readShebang;
    },
    "../../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/resolveCommand.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const path = __webpack_require__("path");
        const which = __webpack_require__("../../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js");
        const getPathKey = __webpack_require__("../../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js");
        function resolveCommandAttempt(parsed, withoutPathExt) {
            const env = parsed.options.env || process.env;
            const cwd = process.cwd();
            const hasCustomCwd = null != parsed.options.cwd;
            const shouldSwitchCwd = hasCustomCwd && void 0 !== process.chdir && !process.chdir.disabled;
            if (shouldSwitchCwd) try {
                process.chdir(parsed.options.cwd);
            } catch (err) {}
            let resolved;
            try {
                resolved = which.sync(parsed.command, {
                    path: env[getPathKey({
                        env
                    })],
                    pathExt: withoutPathExt ? path.delimiter : void 0
                });
            } catch (e) {} finally{
                if (shouldSwitchCwd) process.chdir(cwd);
            }
            if (resolved) resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);
            return resolved;
        }
        function resolveCommand(parsed) {
            return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
        }
        module.exports = resolveCommand;
    },
    "../../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        __webpack_require__("fs");
        var core;
        core = 'win32' === process.platform || global.TESTING_WINDOWS ? __webpack_require__("../../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js") : __webpack_require__("../../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js");
        module.exports = isexe;
        isexe.sync = sync;
        function isexe(path, options, cb) {
            if ('function' == typeof options) {
                cb = options;
                options = {};
            }
            if (!cb) {
                if ('function' != typeof Promise) throw new TypeError('callback not provided');
                return new Promise(function(resolve, reject) {
                    isexe(path, options || {}, function(er, is) {
                        if (er) reject(er);
                        else resolve(is);
                    });
                });
            }
            core(path, options || {}, function(er, is) {
                if (er) {
                    if ('EACCES' === er.code || options && options.ignoreErrors) {
                        er = null;
                        is = false;
                    }
                }
                cb(er, is);
            });
        }
        function sync(path, options) {
            try {
                return core.sync(path, options || {});
            } catch (er) {
                if (options && options.ignoreErrors || 'EACCES' === er.code) return false;
                throw er;
            }
        }
    },
    "../../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js" (module, __unused_rspack_exports, __webpack_require__) {
        module.exports = isexe;
        isexe.sync = sync;
        var fs = __webpack_require__("fs");
        function isexe(path, options, cb) {
            fs.stat(path, function(er, stat) {
                cb(er, er ? false : checkStat(stat, options));
            });
        }
        function sync(path, options) {
            return checkStat(fs.statSync(path), options);
        }
        function checkStat(stat, options) {
            return stat.isFile() && checkMode(stat, options);
        }
        function checkMode(stat, options) {
            var mod = stat.mode;
            var uid = stat.uid;
            var gid = stat.gid;
            var myUid = void 0 !== options.uid ? options.uid : process.getuid && process.getuid();
            var myGid = void 0 !== options.gid ? options.gid : process.getgid && process.getgid();
            var u = parseInt('100', 8);
            var g = parseInt('010', 8);
            var o = parseInt('001', 8);
            var ug = u | g;
            var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && 0 === myUid;
            return ret;
        }
    },
    "../../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js" (module, __unused_rspack_exports, __webpack_require__) {
        module.exports = isexe;
        isexe.sync = sync;
        var fs = __webpack_require__("fs");
        function checkPathExt(path, options) {
            var pathext = void 0 !== options.pathExt ? options.pathExt : process.env.PATHEXT;
            if (!pathext) return true;
            pathext = pathext.split(';');
            if (-1 !== pathext.indexOf('')) return true;
            for(var i = 0; i < pathext.length; i++){
                var p = pathext[i].toLowerCase();
                if (p && path.substr(-p.length).toLowerCase() === p) return true;
            }
            return false;
        }
        function checkStat(stat, path, options) {
            if (!stat.isSymbolicLink() && !stat.isFile()) return false;
            return checkPathExt(path, options);
        }
        function isexe(path, options, cb) {
            fs.stat(path, function(er, stat) {
                cb(er, er ? false : checkStat(stat, path, options));
            });
        }
        function sync(path, options) {
            return checkStat(fs.statSync(path), path, options);
        }
    },
    "../../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js" (module) {
        "use strict";
        const pathKey = (options = {})=>{
            const environment = options.env || process.env;
            const platform = options.platform || process.platform;
            if ('win32' !== platform) return 'PATH';
            return Object.keys(environment).reverse().find((key)=>'PATH' === key.toUpperCase()) || 'Path';
        };
        module.exports = pathKey;
        module.exports["default"] = pathKey;
    },
    "../../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const shebangRegex = __webpack_require__("../../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js");
        module.exports = (string = '')=>{
            const match = string.match(shebangRegex);
            if (!match) return null;
            const [path, argument] = match[0].replace(/#! ?/, '').split(' ');
            const binary = path.split('/').pop();
            if ('env' === binary) return argument;
            return argument ? `${binary} ${argument}` : binary;
        };
    },
    "../../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js" (module) {
        "use strict";
        module.exports = /^#!(.*)/;
    },
    "../../../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        __webpack_require__("../../../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js");
    },
    "../../../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        __webpack_require__("net");
        __webpack_require__("tls");
        var http = __webpack_require__("http");
        __webpack_require__("https");
        var events = __webpack_require__("events");
        __webpack_require__("assert");
        var util = __webpack_require__("util");
        function TunnelingAgent(options) {
            var self = this;
            self.options = options || {};
            self.proxyOptions = self.options.proxy || {};
            self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
            self.requests = [];
            self.sockets = [];
            self.on('free', function(socket, host, port, localAddress) {
                var options = toOptions(host, port, localAddress);
                for(var i = 0, len = self.requests.length; i < len; ++i){
                    var pending = self.requests[i];
                    if (pending.host === options.host && pending.port === options.port) {
                        self.requests.splice(i, 1);
                        pending.request.onSocket(socket);
                        return;
                    }
                }
                socket.destroy();
                self.removeSocket(socket);
            });
        }
        util.inherits(TunnelingAgent, events.EventEmitter);
        TunnelingAgent.prototype.addRequest = function(req, host, port, localAddress) {
            var self = this;
            var options = mergeOptions({
                request: req
            }, self.options, toOptions(host, port, localAddress));
            if (self.sockets.length >= this.maxSockets) return void self.requests.push(options);
            self.createSocket(options, function(socket) {
                socket.on('free', onFree);
                socket.on('close', onCloseOrRemove);
                socket.on('agentRemove', onCloseOrRemove);
                req.onSocket(socket);
                function onFree() {
                    self.emit('free', socket, options);
                }
                function onCloseOrRemove(err) {
                    self.removeSocket(socket);
                    socket.removeListener('free', onFree);
                    socket.removeListener('close', onCloseOrRemove);
                    socket.removeListener('agentRemove', onCloseOrRemove);
                }
            });
        };
        TunnelingAgent.prototype.createSocket = function(options, cb) {
            var self = this;
            var placeholder = {};
            self.sockets.push(placeholder);
            var connectOptions = mergeOptions({}, self.proxyOptions, {
                method: 'CONNECT',
                path: options.host + ':' + options.port,
                agent: false,
                headers: {
                    host: options.host + ':' + options.port
                }
            });
            if (options.localAddress) connectOptions.localAddress = options.localAddress;
            if (connectOptions.proxyAuth) {
                connectOptions.headers = connectOptions.headers || {};
                connectOptions.headers['Proxy-Authorization'] = 'Basic ' + new Buffer(connectOptions.proxyAuth).toString('base64');
            }
            debug('making CONNECT request');
            var connectReq = self.request(connectOptions);
            connectReq.useChunkedEncodingByDefault = false;
            connectReq.once('response', onResponse);
            connectReq.once('upgrade', onUpgrade);
            connectReq.once('connect', onConnect);
            connectReq.once('error', onError);
            connectReq.end();
            function onResponse(res) {
                res.upgrade = true;
            }
            function onUpgrade(res, socket, head) {
                process.nextTick(function() {
                    onConnect(res, socket, head);
                });
            }
            function onConnect(res, socket, head) {
                connectReq.removeAllListeners();
                socket.removeAllListeners();
                if (200 !== res.statusCode) {
                    debug('tunneling socket could not be established, statusCode=%d', res.statusCode);
                    socket.destroy();
                    var error = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
                    error.code = 'ECONNRESET';
                    options.request.emit('error', error);
                    self.removeSocket(placeholder);
                    return;
                }
                if (head.length > 0) {
                    debug('got illegal response body from proxy');
                    socket.destroy();
                    var error = new Error('got illegal response body from proxy');
                    error.code = 'ECONNRESET';
                    options.request.emit('error', error);
                    self.removeSocket(placeholder);
                    return;
                }
                debug('tunneling connection has established');
                self.sockets[self.sockets.indexOf(placeholder)] = socket;
                return cb(socket);
            }
            function onError(cause) {
                connectReq.removeAllListeners();
                debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack);
                var error = new Error("tunneling socket could not be established, cause=" + cause.message);
                error.code = 'ECONNRESET';
                options.request.emit('error', error);
                self.removeSocket(placeholder);
            }
        };
        TunnelingAgent.prototype.removeSocket = function(socket) {
            var pos = this.sockets.indexOf(socket);
            if (-1 === pos) return;
            this.sockets.splice(pos, 1);
            var pending = this.requests.shift();
            if (pending) this.createSocket(pending, function(socket) {
                pending.request.onSocket(socket);
            });
        };
        function toOptions(host, port, localAddress) {
            if ('string' == typeof host) return {
                host: host,
                port: port,
                localAddress: localAddress
            };
            return host;
        }
        function mergeOptions(target) {
            for(var i = 1, len = arguments.length; i < len; ++i){
                var overrides = arguments[i];
                if ('object' == typeof overrides) {
                    var keys = Object.keys(overrides);
                    for(var j = 0, keyLen = keys.length; j < keyLen; ++j){
                        var k = keys[j];
                        if (void 0 !== overrides[k]) target[k] = overrides[k];
                    }
                }
            }
            return target;
        }
        var debug;
        debug = process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG) ? function() {
            var args = Array.prototype.slice.call(arguments);
            if ('string' == typeof args[0]) args[0] = 'TUNNEL: ' + args[0];
            else args.unshift('TUNNEL:');
            console.error.apply(console, args);
        } : function() {};
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/client.js");
        const Dispatcher = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/dispatcher.js");
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/pool.js");
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/balanced-pool.js");
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/agent.js");
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/proxy-agent.js");
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/env-http-proxy-agent.js");
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/retry-agent.js");
        const errors = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { InvalidArgumentError } = errors;
        const api = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/index.js");
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/connect.js");
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-client.js");
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-agent.js");
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-pool.js");
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-errors.js");
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/handler/retry-handler.js");
        const { getGlobalDispatcher, setGlobalDispatcher } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/global.js");
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/handler/decorator-handler.js");
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/handler/redirect-handler.js");
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/interceptor/redirect-interceptor.js");
        Object.assign(Dispatcher.prototype, api);
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/interceptor/redirect.js"), __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/interceptor/retry.js"), __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/interceptor/dump.js"), __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/interceptor/dns.js");
        util.parseHeaders, util.headerNameToString;
        function makeDispatcher(fn) {
            return (url, opts, handler)=>{
                if ('function' == typeof opts) {
                    handler = opts;
                    opts = null;
                }
                if (!url || 'string' != typeof url && 'object' != typeof url && !(url instanceof URL)) throw new InvalidArgumentError('invalid url');
                if (null != opts && 'object' != typeof opts) throw new InvalidArgumentError('invalid opts');
                if (opts && null != opts.path) {
                    if ('string' != typeof opts.path) throw new InvalidArgumentError('invalid opts.path');
                    let path = opts.path;
                    if (!opts.path.startsWith('/')) path = `/${path}`;
                    url = new URL(util.parseOrigin(url).origin + path);
                } else {
                    if (!opts) opts = 'object' == typeof url ? url : {};
                    url = util.parseURL(url);
                }
                const { agent, dispatcher = getGlobalDispatcher() } = opts;
                if (agent) throw new InvalidArgumentError('unsupported opts.agent. Did you mean opts.client?');
                return fn.call(dispatcher, {
                    ...opts,
                    origin: url.origin,
                    path: url.search ? `${url.pathname}${url.search}` : url.pathname,
                    method: opts.method || (opts.body ? 'PUT' : 'GET')
                }, handler);
            };
        }
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/index.js").fetch;
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/headers.js").Headers;
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/response.js").Response;
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/request.js").Request;
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/formdata.js").FormData;
        globalThis.File ?? __webpack_require__("node:buffer").File;
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fileapi/filereader.js").FileReader;
        const { setGlobalOrigin, getGlobalOrigin } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/global.js");
        const { CacheStorage } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cache/cachestorage.js");
        const { kConstruct } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cache/symbols.js");
        new CacheStorage(kConstruct);
        const { deleteCookie, getCookies, getSetCookies, setCookie } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cookies/index.js");
        const { parseMIMEType, serializeAMimeType } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/data-url.js");
        const { CloseEvent, ErrorEvent, MessageEvent } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/events.js");
        __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/websocket.js").WebSocket;
        makeDispatcher(api.request);
        makeDispatcher(api.stream);
        makeDispatcher(api.pipeline);
        makeDispatcher(api.connect);
        makeDispatcher(api.upgrade);
        const { EventSource } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/eventsource/eventsource.js");
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/abort-signal.js" (module, __unused_rspack_exports, __webpack_require__) {
        const { addAbortListener } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { RequestAbortedError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const kListener = Symbol('kListener');
        const kSignal = Symbol('kSignal');
        function abort(self) {
            if (self.abort) self.abort(self[kSignal]?.reason);
            else self.reason = self[kSignal]?.reason ?? new RequestAbortedError();
            removeSignal(self);
        }
        function addSignal(self, signal) {
            self.reason = null;
            self[kSignal] = null;
            self[kListener] = null;
            if (!signal) return;
            if (signal.aborted) return void abort(self);
            self[kSignal] = signal;
            self[kListener] = ()=>{
                abort(self);
            };
            addAbortListener(self[kSignal], self[kListener]);
        }
        function removeSignal(self) {
            if (!self[kSignal]) return;
            if ('removeEventListener' in self[kSignal]) self[kSignal].removeEventListener('abort', self[kListener]);
            else self[kSignal].removeListener('abort', self[kListener]);
            self[kSignal] = null;
            self[kListener] = null;
        }
        module.exports = {
            addSignal,
            removeSignal
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/api-connect.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const assert = __webpack_require__("node:assert");
        const { AsyncResource } = __webpack_require__("node:async_hooks");
        const { InvalidArgumentError, SocketError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { addSignal, removeSignal } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/abort-signal.js");
        class ConnectHandler extends AsyncResource {
            constructor(opts, callback){
                if (!opts || 'object' != typeof opts) throw new InvalidArgumentError('invalid opts');
                if ('function' != typeof callback) throw new InvalidArgumentError('invalid callback');
                const { signal, opaque, responseHeaders } = opts;
                if (signal && 'function' != typeof signal.on && 'function' != typeof signal.addEventListener) throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');
                super('UNDICI_CONNECT');
                this.opaque = opaque || null;
                this.responseHeaders = responseHeaders || null;
                this.callback = callback;
                this.abort = null;
                addSignal(this, signal);
            }
            onConnect(abort, context) {
                if (this.reason) return void abort(this.reason);
                assert(this.callback);
                this.abort = abort;
                this.context = context;
            }
            onHeaders() {
                throw new SocketError('bad connect', null);
            }
            onUpgrade(statusCode, rawHeaders, socket) {
                const { callback, opaque, context } = this;
                removeSignal(this);
                this.callback = null;
                let headers = rawHeaders;
                if (null != headers) headers = 'raw' === this.responseHeaders ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
                this.runInAsyncScope(callback, null, null, {
                    statusCode,
                    headers,
                    socket,
                    opaque,
                    context
                });
            }
            onError(err) {
                const { callback, opaque } = this;
                removeSignal(this);
                if (callback) {
                    this.callback = null;
                    queueMicrotask(()=>{
                        this.runInAsyncScope(callback, null, err, {
                            opaque
                        });
                    });
                }
            }
        }
        function connect(opts, callback) {
            if (void 0 === callback) return new Promise((resolve, reject)=>{
                connect.call(this, opts, (err, data)=>err ? reject(err) : resolve(data));
            });
            try {
                const connectHandler = new ConnectHandler(opts, callback);
                this.dispatch({
                    ...opts,
                    method: 'CONNECT'
                }, connectHandler);
            } catch (err) {
                if ('function' != typeof callback) throw err;
                const opaque = opts?.opaque;
                queueMicrotask(()=>callback(err, {
                        opaque
                    }));
            }
        }
        module.exports = connect;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/api-pipeline.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { Readable, Duplex, PassThrough } = __webpack_require__("node:stream");
        const { InvalidArgumentError, InvalidReturnValueError, RequestAbortedError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { AsyncResource } = __webpack_require__("node:async_hooks");
        const { addSignal, removeSignal } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/abort-signal.js");
        const assert = __webpack_require__("node:assert");
        const kResume = Symbol('resume');
        class PipelineRequest extends Readable {
            constructor(){
                super({
                    autoDestroy: true
                });
                this[kResume] = null;
            }
            _read() {
                const { [kResume]: resume } = this;
                if (resume) {
                    this[kResume] = null;
                    resume();
                }
            }
            _destroy(err, callback) {
                this._read();
                callback(err);
            }
        }
        class PipelineResponse extends Readable {
            constructor(resume){
                super({
                    autoDestroy: true
                });
                this[kResume] = resume;
            }
            _read() {
                this[kResume]();
            }
            _destroy(err, callback) {
                if (!err && !this._readableState.endEmitted) err = new RequestAbortedError();
                callback(err);
            }
        }
        class PipelineHandler extends AsyncResource {
            constructor(opts, handler){
                if (!opts || 'object' != typeof opts) throw new InvalidArgumentError('invalid opts');
                if ('function' != typeof handler) throw new InvalidArgumentError('invalid handler');
                const { signal, method, opaque, onInfo, responseHeaders } = opts;
                if (signal && 'function' != typeof signal.on && 'function' != typeof signal.addEventListener) throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');
                if ('CONNECT' === method) throw new InvalidArgumentError('invalid method');
                if (onInfo && 'function' != typeof onInfo) throw new InvalidArgumentError('invalid onInfo callback');
                super('UNDICI_PIPELINE');
                this.opaque = opaque || null;
                this.responseHeaders = responseHeaders || null;
                this.handler = handler;
                this.abort = null;
                this.context = null;
                this.onInfo = onInfo || null;
                this.req = new PipelineRequest().on('error', util.nop);
                this.ret = new Duplex({
                    readableObjectMode: opts.objectMode,
                    autoDestroy: true,
                    read: ()=>{
                        const { body } = this;
                        if (body?.resume) body.resume();
                    },
                    write: (chunk, encoding, callback)=>{
                        const { req } = this;
                        if (req.push(chunk, encoding) || req._readableState.destroyed) callback();
                        else req[kResume] = callback;
                    },
                    destroy: (err, callback)=>{
                        const { body, req, res, ret, abort } = this;
                        if (!err && !ret._readableState.endEmitted) err = new RequestAbortedError();
                        if (abort && err) abort();
                        util.destroy(body, err);
                        util.destroy(req, err);
                        util.destroy(res, err);
                        removeSignal(this);
                        callback(err);
                    }
                }).on('prefinish', ()=>{
                    const { req } = this;
                    req.push(null);
                });
                this.res = null;
                addSignal(this, signal);
            }
            onConnect(abort, context) {
                const { ret, res } = this;
                if (this.reason) return void abort(this.reason);
                assert(!res, 'pipeline cannot be retried');
                assert(!ret.destroyed);
                this.abort = abort;
                this.context = context;
            }
            onHeaders(statusCode, rawHeaders, resume) {
                const { opaque, handler, context } = this;
                if (statusCode < 200) {
                    if (this.onInfo) {
                        const headers = 'raw' === this.responseHeaders ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
                        this.onInfo({
                            statusCode,
                            headers
                        });
                    }
                    return;
                }
                this.res = new PipelineResponse(resume);
                let body;
                try {
                    this.handler = null;
                    const headers = 'raw' === this.responseHeaders ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
                    body = this.runInAsyncScope(handler, null, {
                        statusCode,
                        headers,
                        opaque,
                        body: this.res,
                        context
                    });
                } catch (err) {
                    this.res.on('error', util.nop);
                    throw err;
                }
                if (!body || 'function' != typeof body.on) throw new InvalidReturnValueError('expected Readable');
                body.on('data', (chunk)=>{
                    const { ret, body } = this;
                    if (!ret.push(chunk) && body.pause) body.pause();
                }).on('error', (err)=>{
                    const { ret } = this;
                    util.destroy(ret, err);
                }).on('end', ()=>{
                    const { ret } = this;
                    ret.push(null);
                }).on('close', ()=>{
                    const { ret } = this;
                    if (!ret._readableState.ended) util.destroy(ret, new RequestAbortedError());
                });
                this.body = body;
            }
            onData(chunk) {
                const { res } = this;
                return res.push(chunk);
            }
            onComplete(trailers) {
                const { res } = this;
                res.push(null);
            }
            onError(err) {
                const { ret } = this;
                this.handler = null;
                util.destroy(ret, err);
            }
        }
        function pipeline(opts, handler) {
            try {
                const pipelineHandler = new PipelineHandler(opts, handler);
                this.dispatch({
                    ...opts,
                    body: pipelineHandler.req
                }, pipelineHandler);
                return pipelineHandler.ret;
            } catch (err) {
                return new PassThrough().destroy(err);
            }
        }
        module.exports = pipeline;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/api-request.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const assert = __webpack_require__("node:assert");
        const { Readable } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/readable.js");
        const { InvalidArgumentError, RequestAbortedError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { getResolveErrorBodyCallback } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/util.js");
        const { AsyncResource } = __webpack_require__("node:async_hooks");
        class RequestHandler extends AsyncResource {
            constructor(opts, callback){
                if (!opts || 'object' != typeof opts) throw new InvalidArgumentError('invalid opts');
                const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
                try {
                    if ('function' != typeof callback) throw new InvalidArgumentError('invalid callback');
                    if (highWaterMark && ('number' != typeof highWaterMark || highWaterMark < 0)) throw new InvalidArgumentError('invalid highWaterMark');
                    if (signal && 'function' != typeof signal.on && 'function' != typeof signal.addEventListener) throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');
                    if ('CONNECT' === method) throw new InvalidArgumentError('invalid method');
                    if (onInfo && 'function' != typeof onInfo) throw new InvalidArgumentError('invalid onInfo callback');
                    super('UNDICI_REQUEST');
                } catch (err) {
                    if (util.isStream(body)) util.destroy(body.on('error', util.nop), err);
                    throw err;
                }
                this.method = method;
                this.responseHeaders = responseHeaders || null;
                this.opaque = opaque || null;
                this.callback = callback;
                this.res = null;
                this.abort = null;
                this.body = body;
                this.trailers = {};
                this.context = null;
                this.onInfo = onInfo || null;
                this.throwOnError = throwOnError;
                this.highWaterMark = highWaterMark;
                this.signal = signal;
                this.reason = null;
                this.removeAbortListener = null;
                if (util.isStream(body)) body.on('error', (err)=>{
                    this.onError(err);
                });
                if (this.signal) if (this.signal.aborted) this.reason = this.signal.reason ?? new RequestAbortedError();
                else this.removeAbortListener = util.addAbortListener(this.signal, ()=>{
                    this.reason = this.signal.reason ?? new RequestAbortedError();
                    if (this.res) util.destroy(this.res.on('error', util.nop), this.reason);
                    else if (this.abort) this.abort(this.reason);
                    if (this.removeAbortListener) {
                        this.res?.off('close', this.removeAbortListener);
                        this.removeAbortListener();
                        this.removeAbortListener = null;
                    }
                });
            }
            onConnect(abort, context) {
                if (this.reason) return void abort(this.reason);
                assert(this.callback);
                this.abort = abort;
                this.context = context;
            }
            onHeaders(statusCode, rawHeaders, resume, statusMessage) {
                const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
                const headers = 'raw' === responseHeaders ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
                if (statusCode < 200) {
                    if (this.onInfo) this.onInfo({
                        statusCode,
                        headers
                    });
                    return;
                }
                const parsedHeaders = 'raw' === responseHeaders ? util.parseHeaders(rawHeaders) : headers;
                const contentType = parsedHeaders['content-type'];
                const contentLength = parsedHeaders['content-length'];
                const res = new Readable({
                    resume,
                    abort,
                    contentType,
                    contentLength: 'HEAD' !== this.method && contentLength ? Number(contentLength) : null,
                    highWaterMark
                });
                if (this.removeAbortListener) res.on('close', this.removeAbortListener);
                this.callback = null;
                this.res = res;
                if (null !== callback) if (this.throwOnError && statusCode >= 400) this.runInAsyncScope(getResolveErrorBodyCallback, null, {
                    callback,
                    body: res,
                    contentType,
                    statusCode,
                    statusMessage,
                    headers
                });
                else this.runInAsyncScope(callback, null, null, {
                    statusCode,
                    headers,
                    trailers: this.trailers,
                    opaque,
                    body: res,
                    context
                });
            }
            onData(chunk) {
                return this.res.push(chunk);
            }
            onComplete(trailers) {
                util.parseHeaders(trailers, this.trailers);
                this.res.push(null);
            }
            onError(err) {
                const { res, callback, body, opaque } = this;
                if (callback) {
                    this.callback = null;
                    queueMicrotask(()=>{
                        this.runInAsyncScope(callback, null, err, {
                            opaque
                        });
                    });
                }
                if (res) {
                    this.res = null;
                    queueMicrotask(()=>{
                        util.destroy(res, err);
                    });
                }
                if (body) {
                    this.body = null;
                    util.destroy(body, err);
                }
                if (this.removeAbortListener) {
                    res?.off('close', this.removeAbortListener);
                    this.removeAbortListener();
                    this.removeAbortListener = null;
                }
            }
        }
        function request(opts, callback) {
            if (void 0 === callback) return new Promise((resolve, reject)=>{
                request.call(this, opts, (err, data)=>err ? reject(err) : resolve(data));
            });
            try {
                this.dispatch(opts, new RequestHandler(opts, callback));
            } catch (err) {
                if ('function' != typeof callback) throw err;
                const opaque = opts?.opaque;
                queueMicrotask(()=>callback(err, {
                        opaque
                    }));
            }
        }
        module.exports = request;
        module.exports.RequestHandler = RequestHandler;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/api-stream.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const assert = __webpack_require__("node:assert");
        const { finished, PassThrough } = __webpack_require__("node:stream");
        const { InvalidArgumentError, InvalidReturnValueError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { getResolveErrorBodyCallback } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/util.js");
        const { AsyncResource } = __webpack_require__("node:async_hooks");
        const { addSignal, removeSignal } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/abort-signal.js");
        class StreamHandler extends AsyncResource {
            constructor(opts, factory, callback){
                if (!opts || 'object' != typeof opts) throw new InvalidArgumentError('invalid opts');
                const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
                try {
                    if ('function' != typeof callback) throw new InvalidArgumentError('invalid callback');
                    if ('function' != typeof factory) throw new InvalidArgumentError('invalid factory');
                    if (signal && 'function' != typeof signal.on && 'function' != typeof signal.addEventListener) throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');
                    if ('CONNECT' === method) throw new InvalidArgumentError('invalid method');
                    if (onInfo && 'function' != typeof onInfo) throw new InvalidArgumentError('invalid onInfo callback');
                    super('UNDICI_STREAM');
                } catch (err) {
                    if (util.isStream(body)) util.destroy(body.on('error', util.nop), err);
                    throw err;
                }
                this.responseHeaders = responseHeaders || null;
                this.opaque = opaque || null;
                this.factory = factory;
                this.callback = callback;
                this.res = null;
                this.abort = null;
                this.context = null;
                this.trailers = null;
                this.body = body;
                this.onInfo = onInfo || null;
                this.throwOnError = throwOnError || false;
                if (util.isStream(body)) body.on('error', (err)=>{
                    this.onError(err);
                });
                addSignal(this, signal);
            }
            onConnect(abort, context) {
                if (this.reason) return void abort(this.reason);
                assert(this.callback);
                this.abort = abort;
                this.context = context;
            }
            onHeaders(statusCode, rawHeaders, resume, statusMessage) {
                const { factory, opaque, context, callback, responseHeaders } = this;
                const headers = 'raw' === responseHeaders ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
                if (statusCode < 200) {
                    if (this.onInfo) this.onInfo({
                        statusCode,
                        headers
                    });
                    return;
                }
                this.factory = null;
                let res;
                if (this.throwOnError && statusCode >= 400) {
                    const parsedHeaders = 'raw' === responseHeaders ? util.parseHeaders(rawHeaders) : headers;
                    const contentType = parsedHeaders['content-type'];
                    res = new PassThrough();
                    this.callback = null;
                    this.runInAsyncScope(getResolveErrorBodyCallback, null, {
                        callback,
                        body: res,
                        contentType,
                        statusCode,
                        statusMessage,
                        headers
                    });
                } else {
                    if (null === factory) return;
                    res = this.runInAsyncScope(factory, null, {
                        statusCode,
                        headers,
                        opaque,
                        context
                    });
                    if (!res || 'function' != typeof res.write || 'function' != typeof res.end || 'function' != typeof res.on) throw new InvalidReturnValueError('expected Writable');
                    finished(res, {
                        readable: false
                    }, (err)=>{
                        const { callback, res, opaque, trailers, abort } = this;
                        this.res = null;
                        if (err || !res.readable) util.destroy(res, err);
                        this.callback = null;
                        this.runInAsyncScope(callback, null, err || null, {
                            opaque,
                            trailers
                        });
                        if (err) abort();
                    });
                }
                res.on('drain', resume);
                this.res = res;
                const needDrain = void 0 !== res.writableNeedDrain ? res.writableNeedDrain : res._writableState?.needDrain;
                return true !== needDrain;
            }
            onData(chunk) {
                const { res } = this;
                return res ? res.write(chunk) : true;
            }
            onComplete(trailers) {
                const { res } = this;
                removeSignal(this);
                if (!res) return;
                this.trailers = util.parseHeaders(trailers);
                res.end();
            }
            onError(err) {
                const { res, callback, opaque, body } = this;
                removeSignal(this);
                this.factory = null;
                if (res) {
                    this.res = null;
                    util.destroy(res, err);
                } else if (callback) {
                    this.callback = null;
                    queueMicrotask(()=>{
                        this.runInAsyncScope(callback, null, err, {
                            opaque
                        });
                    });
                }
                if (body) {
                    this.body = null;
                    util.destroy(body, err);
                }
            }
        }
        function stream(opts, factory, callback) {
            if (void 0 === callback) return new Promise((resolve, reject)=>{
                stream.call(this, opts, factory, (err, data)=>err ? reject(err) : resolve(data));
            });
            try {
                this.dispatch(opts, new StreamHandler(opts, factory, callback));
            } catch (err) {
                if ('function' != typeof callback) throw err;
                const opaque = opts?.opaque;
                queueMicrotask(()=>callback(err, {
                        opaque
                    }));
            }
        }
        module.exports = stream;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/api-upgrade.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { InvalidArgumentError, SocketError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const { AsyncResource } = __webpack_require__("node:async_hooks");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { addSignal, removeSignal } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/abort-signal.js");
        const assert = __webpack_require__("node:assert");
        class UpgradeHandler extends AsyncResource {
            constructor(opts, callback){
                if (!opts || 'object' != typeof opts) throw new InvalidArgumentError('invalid opts');
                if ('function' != typeof callback) throw new InvalidArgumentError('invalid callback');
                const { signal, opaque, responseHeaders } = opts;
                if (signal && 'function' != typeof signal.on && 'function' != typeof signal.addEventListener) throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');
                super('UNDICI_UPGRADE');
                this.responseHeaders = responseHeaders || null;
                this.opaque = opaque || null;
                this.callback = callback;
                this.abort = null;
                this.context = null;
                addSignal(this, signal);
            }
            onConnect(abort, context) {
                if (this.reason) return void abort(this.reason);
                assert(this.callback);
                this.abort = abort;
                this.context = null;
            }
            onHeaders() {
                throw new SocketError('bad upgrade', null);
            }
            onUpgrade(statusCode, rawHeaders, socket) {
                assert(101 === statusCode);
                const { callback, opaque, context } = this;
                removeSignal(this);
                this.callback = null;
                const headers = 'raw' === this.responseHeaders ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
                this.runInAsyncScope(callback, null, null, {
                    headers,
                    socket,
                    opaque,
                    context
                });
            }
            onError(err) {
                const { callback, opaque } = this;
                removeSignal(this);
                if (callback) {
                    this.callback = null;
                    queueMicrotask(()=>{
                        this.runInAsyncScope(callback, null, err, {
                            opaque
                        });
                    });
                }
            }
        }
        function upgrade(opts, callback) {
            if (void 0 === callback) return new Promise((resolve, reject)=>{
                upgrade.call(this, opts, (err, data)=>err ? reject(err) : resolve(data));
            });
            try {
                const upgradeHandler = new UpgradeHandler(opts, callback);
                this.dispatch({
                    ...opts,
                    method: opts.method || 'GET',
                    upgrade: opts.protocol || 'Websocket'
                }, upgradeHandler);
            } catch (err) {
                if ('function' != typeof callback) throw err;
                const opaque = opts?.opaque;
                queueMicrotask(()=>callback(err, {
                        opaque
                    }));
            }
        }
        module.exports = upgrade;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        module.exports.request = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/api-request.js");
        module.exports.stream = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/api-stream.js");
        module.exports.pipeline = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/api-pipeline.js");
        module.exports.upgrade = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/api-upgrade.js");
        module.exports.connect = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/api-connect.js");
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/readable.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const assert = __webpack_require__("node:assert");
        const { Readable } = __webpack_require__("node:stream");
        const { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { ReadableStreamFrom } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const kConsume = Symbol('kConsume');
        const kReading = Symbol('kReading');
        const kBody = Symbol('kBody');
        const kAbort = Symbol('kAbort');
        const kContentType = Symbol('kContentType');
        const kContentLength = Symbol('kContentLength');
        const noop = ()=>{};
        class BodyReadable extends Readable {
            constructor({ resume, abort, contentType = '', contentLength, highWaterMark = 65536 }){
                super({
                    autoDestroy: true,
                    read: resume,
                    highWaterMark
                });
                this._readableState.dataEmitted = false;
                this[kAbort] = abort;
                this[kConsume] = null;
                this[kBody] = null;
                this[kContentType] = contentType;
                this[kContentLength] = contentLength;
                this[kReading] = false;
            }
            destroy(err) {
                if (!err && !this._readableState.endEmitted) err = new RequestAbortedError();
                if (err) this[kAbort]();
                return super.destroy(err);
            }
            _destroy(err, callback) {
                if (this[kReading]) callback(err);
                else setImmediate(()=>{
                    callback(err);
                });
            }
            on(ev, ...args) {
                if ('data' === ev || 'readable' === ev) this[kReading] = true;
                return super.on(ev, ...args);
            }
            addListener(ev, ...args) {
                return this.on(ev, ...args);
            }
            off(ev, ...args) {
                const ret = super.off(ev, ...args);
                if ('data' === ev || 'readable' === ev) this[kReading] = this.listenerCount('data') > 0 || this.listenerCount('readable') > 0;
                return ret;
            }
            removeListener(ev, ...args) {
                return this.off(ev, ...args);
            }
            push(chunk) {
                if (this[kConsume] && null !== chunk) {
                    consumePush(this[kConsume], chunk);
                    return this[kReading] ? super.push(chunk) : true;
                }
                return super.push(chunk);
            }
            async text() {
                return consume(this, 'text');
            }
            async json() {
                return consume(this, 'json');
            }
            async blob() {
                return consume(this, 'blob');
            }
            async bytes() {
                return consume(this, 'bytes');
            }
            async arrayBuffer() {
                return consume(this, 'arrayBuffer');
            }
            async formData() {
                throw new NotSupportedError();
            }
            get bodyUsed() {
                return util.isDisturbed(this);
            }
            get body() {
                if (!this[kBody]) {
                    this[kBody] = ReadableStreamFrom(this);
                    if (this[kConsume]) {
                        this[kBody].getReader();
                        assert(this[kBody].locked);
                    }
                }
                return this[kBody];
            }
            async dump(opts) {
                let limit = Number.isFinite(opts?.limit) ? opts.limit : 131072;
                const signal = opts?.signal;
                if (null != signal && ('object' != typeof signal || !('aborted' in signal))) throw new InvalidArgumentError('signal must be an AbortSignal');
                signal?.throwIfAborted();
                if (this._readableState.closeEmitted) return null;
                return await new Promise((resolve, reject)=>{
                    if (this[kContentLength] > limit) this.destroy(new AbortError());
                    const onAbort = ()=>{
                        this.destroy(signal.reason ?? new AbortError());
                    };
                    signal?.addEventListener('abort', onAbort);
                    this.on('close', function() {
                        signal?.removeEventListener('abort', onAbort);
                        if (signal?.aborted) reject(signal.reason ?? new AbortError());
                        else resolve(null);
                    }).on('error', noop).on('data', function(chunk) {
                        limit -= chunk.length;
                        if (limit <= 0) this.destroy();
                    }).resume();
                });
            }
        }
        function isLocked(self) {
            return self[kBody] && true === self[kBody].locked || self[kConsume];
        }
        function isUnusable(self) {
            return util.isDisturbed(self) || isLocked(self);
        }
        async function consume(stream, type) {
            assert(!stream[kConsume]);
            return new Promise((resolve, reject)=>{
                if (isUnusable(stream)) {
                    const rState = stream._readableState;
                    if (rState.destroyed && false === rState.closeEmitted) stream.on('error', (err)=>{
                        reject(err);
                    }).on('close', ()=>{
                        reject(new TypeError('unusable'));
                    });
                    else reject(rState.errored ?? new TypeError('unusable'));
                } else queueMicrotask(()=>{
                    stream[kConsume] = {
                        type,
                        stream,
                        resolve,
                        reject,
                        length: 0,
                        body: []
                    };
                    stream.on('error', function(err) {
                        consumeFinish(this[kConsume], err);
                    }).on('close', function() {
                        if (null !== this[kConsume].body) consumeFinish(this[kConsume], new RequestAbortedError());
                    });
                    consumeStart(stream[kConsume]);
                });
            });
        }
        function consumeStart(consume) {
            if (null === consume.body) return;
            const { _readableState: state } = consume.stream;
            if (state.bufferIndex) {
                const start = state.bufferIndex;
                const end = state.buffer.length;
                for(let n = start; n < end; n++)consumePush(consume, state.buffer[n]);
            } else for (const chunk of state.buffer)consumePush(consume, chunk);
            if (state.endEmitted) consumeEnd(this[kConsume]);
            else consume.stream.on('end', function() {
                consumeEnd(this[kConsume]);
            });
            consume.stream.resume();
            while(null != consume.stream.read());
        }
        function chunksDecode(chunks, length) {
            if (0 === chunks.length || 0 === length) return '';
            const buffer = 1 === chunks.length ? chunks[0] : Buffer.concat(chunks, length);
            const bufferLength = buffer.length;
            const start = bufferLength > 2 && 0xef === buffer[0] && 0xbb === buffer[1] && 0xbf === buffer[2] ? 3 : 0;
            return buffer.utf8Slice(start, bufferLength);
        }
        function chunksConcat(chunks, length) {
            if (0 === chunks.length || 0 === length) return new Uint8Array(0);
            if (1 === chunks.length) return new Uint8Array(chunks[0]);
            const buffer = new Uint8Array(Buffer.allocUnsafeSlow(length).buffer);
            let offset = 0;
            for(let i = 0; i < chunks.length; ++i){
                const chunk = chunks[i];
                buffer.set(chunk, offset);
                offset += chunk.length;
            }
            return buffer;
        }
        function consumeEnd(consume) {
            const { type, body, resolve, stream, length } = consume;
            try {
                if ('text' === type) resolve(chunksDecode(body, length));
                else if ('json' === type) resolve(JSON.parse(chunksDecode(body, length)));
                else if ('arrayBuffer' === type) resolve(chunksConcat(body, length).buffer);
                else if ('blob' === type) resolve(new Blob(body, {
                    type: stream[kContentType]
                }));
                else if ('bytes' === type) resolve(chunksConcat(body, length));
                consumeFinish(consume);
            } catch (err) {
                stream.destroy(err);
            }
        }
        function consumePush(consume, chunk) {
            consume.length += chunk.length;
            consume.body.push(chunk);
        }
        function consumeFinish(consume, err) {
            if (null === consume.body) return;
            if (err) consume.reject(err);
            else consume.resolve();
            consume.type = null;
            consume.stream = null;
            consume.resolve = null;
            consume.reject = null;
            consume.length = 0;
            consume.body = null;
        }
        module.exports = {
            Readable: BodyReadable,
            chunksDecode
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/util.js" (module, __unused_rspack_exports, __webpack_require__) {
        const assert = __webpack_require__("node:assert");
        const { ResponseStatusCodeError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const { chunksDecode } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/api/readable.js");
        const CHUNK_LIMIT = 131072;
        async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
            assert(body);
            let chunks = [];
            let length = 0;
            try {
                for await (const chunk of body){
                    chunks.push(chunk);
                    length += chunk.length;
                    if (length > CHUNK_LIMIT) {
                        chunks = [];
                        length = 0;
                        break;
                    }
                }
            } catch  {
                chunks = [];
                length = 0;
            }
            const message = `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`;
            if (204 === statusCode || !contentType || !length) return void queueMicrotask(()=>callback(new ResponseStatusCodeError(message, statusCode, headers)));
            const stackTraceLimit = Error.stackTraceLimit;
            Error.stackTraceLimit = 0;
            let payload;
            try {
                if (isContentTypeApplicationJson(contentType)) payload = JSON.parse(chunksDecode(chunks, length));
                else if (isContentTypeText(contentType)) payload = chunksDecode(chunks, length);
            } catch  {} finally{
                Error.stackTraceLimit = stackTraceLimit;
            }
            queueMicrotask(()=>callback(new ResponseStatusCodeError(message, statusCode, headers, payload)));
        }
        const isContentTypeApplicationJson = (contentType)=>contentType.length > 15 && '/' === contentType[11] && 'a' === contentType[0] && 'p' === contentType[1] && 'p' === contentType[2] && 'l' === contentType[3] && 'i' === contentType[4] && 'c' === contentType[5] && 'a' === contentType[6] && 't' === contentType[7] && 'i' === contentType[8] && 'o' === contentType[9] && 'n' === contentType[10] && 'j' === contentType[12] && 's' === contentType[13] && 'o' === contentType[14] && 'n' === contentType[15];
        const isContentTypeText = (contentType)=>contentType.length > 4 && '/' === contentType[4] && 't' === contentType[0] && 'e' === contentType[1] && 'x' === contentType[2] && 't' === contentType[3];
        module.exports = {
            getResolveErrorBodyCallback,
            isContentTypeApplicationJson,
            isContentTypeText
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/connect.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const net = __webpack_require__("node:net");
        const assert = __webpack_require__("node:assert");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { InvalidArgumentError, ConnectTimeoutError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const timers = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/util/timers.js");
        function noop() {}
        let tls;
        let SessionCache;
        SessionCache = global.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG) ? class {
            constructor(maxCachedSessions){
                this._maxCachedSessions = maxCachedSessions;
                this._sessionCache = new Map();
                this._sessionRegistry = new global.FinalizationRegistry((key)=>{
                    if (this._sessionCache.size < this._maxCachedSessions) return;
                    const ref = this._sessionCache.get(key);
                    if (void 0 !== ref && void 0 === ref.deref()) this._sessionCache.delete(key);
                });
            }
            get(sessionKey) {
                const ref = this._sessionCache.get(sessionKey);
                return ref ? ref.deref() : null;
            }
            set(sessionKey, session) {
                if (0 === this._maxCachedSessions) return;
                this._sessionCache.set(sessionKey, new WeakRef(session));
                this._sessionRegistry.register(session, sessionKey);
            }
        } : class {
            constructor(maxCachedSessions){
                this._maxCachedSessions = maxCachedSessions;
                this._sessionCache = new Map();
            }
            get(sessionKey) {
                return this._sessionCache.get(sessionKey);
            }
            set(sessionKey, session) {
                if (0 === this._maxCachedSessions) return;
                if (this._sessionCache.size >= this._maxCachedSessions) {
                    const { value: oldestKey } = this._sessionCache.keys().next();
                    this._sessionCache.delete(oldestKey);
                }
                this._sessionCache.set(sessionKey, session);
            }
        };
        function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {
            if (null != maxCachedSessions && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero');
            const options = {
                path: socketPath,
                ...opts
            };
            const sessionCache = new SessionCache(null == maxCachedSessions ? 100 : maxCachedSessions);
            timeout = null == timeout ? 10e3 : timeout;
            allowH2 = null != allowH2 ? allowH2 : false;
            return function({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
                let socket;
                if ('https:' === protocol) {
                    if (!tls) tls = __webpack_require__("node:tls");
                    servername = servername || options.servername || util.getServerName(host) || null;
                    const sessionKey = servername || hostname;
                    assert(sessionKey);
                    const session = customSession || sessionCache.get(sessionKey) || null;
                    port = port || 443;
                    socket = tls.connect({
                        highWaterMark: 16384,
                        ...options,
                        servername,
                        session,
                        localAddress,
                        ALPNProtocols: allowH2 ? [
                            'http/1.1',
                            'h2'
                        ] : [
                            'http/1.1'
                        ],
                        socket: httpSocket,
                        port,
                        host: hostname
                    });
                    socket.on('session', function(session) {
                        sessionCache.set(sessionKey, session);
                    });
                } else {
                    assert(!httpSocket, 'httpSocket can only be sent on TLS update');
                    port = port || 80;
                    socket = net.connect({
                        highWaterMark: 65536,
                        ...options,
                        localAddress,
                        port,
                        host: hostname
                    });
                }
                if (null == options.keepAlive || options.keepAlive) {
                    const keepAliveInitialDelay = void 0 === options.keepAliveInitialDelay ? 60e3 : options.keepAliveInitialDelay;
                    socket.setKeepAlive(true, keepAliveInitialDelay);
                }
                const clearConnectTimeout = setupConnectTimeout(new WeakRef(socket), {
                    timeout,
                    hostname,
                    port
                });
                socket.setNoDelay(true).once('https:' === protocol ? 'secureConnect' : 'connect', function() {
                    queueMicrotask(clearConnectTimeout);
                    if (callback) {
                        const cb = callback;
                        callback = null;
                        cb(null, this);
                    }
                }).on('error', function(err) {
                    queueMicrotask(clearConnectTimeout);
                    if (callback) {
                        const cb = callback;
                        callback = null;
                        cb(err);
                    }
                });
                return socket;
            };
        }
        const setupConnectTimeout = 'win32' === process.platform ? (socketWeakRef, opts)=>{
            if (!opts.timeout) return noop;
            let s1 = null;
            let s2 = null;
            const fastTimer = timers.setFastTimeout(()=>{
                s1 = setImmediate(()=>{
                    s2 = setImmediate(()=>onConnectTimeout(socketWeakRef.deref(), opts));
                });
            }, opts.timeout);
            return ()=>{
                timers.clearFastTimeout(fastTimer);
                clearImmediate(s1);
                clearImmediate(s2);
            };
        } : (socketWeakRef, opts)=>{
            if (!opts.timeout) return noop;
            let s1 = null;
            const fastTimer = timers.setFastTimeout(()=>{
                s1 = setImmediate(()=>{
                    onConnectTimeout(socketWeakRef.deref(), opts);
                });
            }, opts.timeout);
            return ()=>{
                timers.clearFastTimeout(fastTimer);
                clearImmediate(s1);
            };
        };
        function onConnectTimeout(socket, opts) {
            if (null == socket) return;
            let message = 'Connect Timeout Error';
            if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(', ')},`;
            else message += ` (attempted address: ${opts.hostname}:${opts.port},`;
            message += ` timeout: ${opts.timeout}ms)`;
            util.destroy(socket, new ConnectTimeoutError(message));
        }
        module.exports = buildConnector;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/constants.js" (module) {
        "use strict";
        const headerNameLowerCasedRecord = {};
        const wellknownHeaderNames = [
            'Accept',
            'Accept-Encoding',
            'Accept-Language',
            'Accept-Ranges',
            'Access-Control-Allow-Credentials',
            'Access-Control-Allow-Headers',
            'Access-Control-Allow-Methods',
            'Access-Control-Allow-Origin',
            'Access-Control-Expose-Headers',
            'Access-Control-Max-Age',
            'Access-Control-Request-Headers',
            'Access-Control-Request-Method',
            'Age',
            'Allow',
            'Alt-Svc',
            'Alt-Used',
            'Authorization',
            'Cache-Control',
            'Clear-Site-Data',
            'Connection',
            'Content-Disposition',
            'Content-Encoding',
            'Content-Language',
            'Content-Length',
            'Content-Location',
            'Content-Range',
            'Content-Security-Policy',
            'Content-Security-Policy-Report-Only',
            'Content-Type',
            'Cookie',
            'Cross-Origin-Embedder-Policy',
            'Cross-Origin-Opener-Policy',
            'Cross-Origin-Resource-Policy',
            'Date',
            'Device-Memory',
            'Downlink',
            'ECT',
            'ETag',
            'Expect',
            'Expect-CT',
            'Expires',
            'Forwarded',
            'From',
            'Host',
            'If-Match',
            'If-Modified-Since',
            'If-None-Match',
            'If-Range',
            'If-Unmodified-Since',
            'Keep-Alive',
            'Last-Modified',
            'Link',
            'Location',
            'Max-Forwards',
            'Origin',
            'Permissions-Policy',
            'Pragma',
            'Proxy-Authenticate',
            'Proxy-Authorization',
            'RTT',
            'Range',
            'Referer',
            'Referrer-Policy',
            'Refresh',
            'Retry-After',
            'Sec-WebSocket-Accept',
            'Sec-WebSocket-Extensions',
            'Sec-WebSocket-Key',
            'Sec-WebSocket-Protocol',
            'Sec-WebSocket-Version',
            'Server',
            'Server-Timing',
            'Service-Worker-Allowed',
            'Service-Worker-Navigation-Preload',
            'Set-Cookie',
            'SourceMap',
            'Strict-Transport-Security',
            'Supports-Loading-Mode',
            'TE',
            'Timing-Allow-Origin',
            'Trailer',
            'Transfer-Encoding',
            'Upgrade',
            'Upgrade-Insecure-Requests',
            'User-Agent',
            'Vary',
            'Via',
            'WWW-Authenticate',
            'X-Content-Type-Options',
            'X-DNS-Prefetch-Control',
            'X-Frame-Options',
            'X-Permitted-Cross-Domain-Policies',
            'X-Powered-By',
            'X-Requested-With',
            'X-XSS-Protection'
        ];
        for(let i = 0; i < wellknownHeaderNames.length; ++i){
            const key = wellknownHeaderNames[i];
            const lowerCasedKey = key.toLowerCase();
            headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
        }
        Object.setPrototypeOf(headerNameLowerCasedRecord, null);
        module.exports = {
            wellknownHeaderNames,
            headerNameLowerCasedRecord
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/diagnostics.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const diagnosticsChannel = __webpack_require__("node:diagnostics_channel");
        const util = __webpack_require__("node:util");
        const undiciDebugLog = util.debuglog('undici');
        const fetchDebuglog = util.debuglog('fetch');
        const websocketDebuglog = util.debuglog('websocket');
        let isClientSet = false;
        const channels = {
            beforeConnect: diagnosticsChannel.channel('undici:client:beforeConnect'),
            connected: diagnosticsChannel.channel('undici:client:connected'),
            connectError: diagnosticsChannel.channel('undici:client:connectError'),
            sendHeaders: diagnosticsChannel.channel('undici:client:sendHeaders'),
            create: diagnosticsChannel.channel('undici:request:create'),
            bodySent: diagnosticsChannel.channel('undici:request:bodySent'),
            headers: diagnosticsChannel.channel('undici:request:headers'),
            trailers: diagnosticsChannel.channel('undici:request:trailers'),
            error: diagnosticsChannel.channel('undici:request:error'),
            open: diagnosticsChannel.channel('undici:websocket:open'),
            close: diagnosticsChannel.channel('undici:websocket:close'),
            socketError: diagnosticsChannel.channel('undici:websocket:socket_error'),
            ping: diagnosticsChannel.channel('undici:websocket:ping'),
            pong: diagnosticsChannel.channel('undici:websocket:pong')
        };
        if (undiciDebugLog.enabled || fetchDebuglog.enabled) {
            const debuglog = fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog;
            diagnosticsChannel.channel('undici:client:beforeConnect').subscribe((evt)=>{
                const { connectParams: { version, protocol, port, host } } = evt;
                debuglog('connecting to %s using %s%s', `${host}${port ? `:${port}` : ''}`, protocol, version);
            });
            diagnosticsChannel.channel('undici:client:connected').subscribe((evt)=>{
                const { connectParams: { version, protocol, port, host } } = evt;
                debuglog('connected to %s using %s%s', `${host}${port ? `:${port}` : ''}`, protocol, version);
            });
            diagnosticsChannel.channel('undici:client:connectError').subscribe((evt)=>{
                const { connectParams: { version, protocol, port, host }, error } = evt;
                debuglog('connection to %s using %s%s errored - %s', `${host}${port ? `:${port}` : ''}`, protocol, version, error.message);
            });
            diagnosticsChannel.channel('undici:client:sendHeaders').subscribe((evt)=>{
                const { request: { method, path, origin } } = evt;
                debuglog('sending request to %s %s/%s', method, origin, path);
            });
            diagnosticsChannel.channel('undici:request:headers').subscribe((evt)=>{
                const { request: { method, path, origin }, response: { statusCode } } = evt;
                debuglog('received response to %s %s/%s - HTTP %d', method, origin, path, statusCode);
            });
            diagnosticsChannel.channel('undici:request:trailers').subscribe((evt)=>{
                const { request: { method, path, origin } } = evt;
                debuglog('trailers received from %s %s/%s', method, origin, path);
            });
            diagnosticsChannel.channel('undici:request:error').subscribe((evt)=>{
                const { request: { method, path, origin }, error } = evt;
                debuglog('request to %s %s/%s errored - %s', method, origin, path, error.message);
            });
            isClientSet = true;
        }
        if (websocketDebuglog.enabled) {
            if (!isClientSet) {
                const debuglog = undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog;
                diagnosticsChannel.channel('undici:client:beforeConnect').subscribe((evt)=>{
                    const { connectParams: { version, protocol, port, host } } = evt;
                    debuglog('connecting to %s%s using %s%s', host, port ? `:${port}` : '', protocol, version);
                });
                diagnosticsChannel.channel('undici:client:connected').subscribe((evt)=>{
                    const { connectParams: { version, protocol, port, host } } = evt;
                    debuglog('connected to %s%s using %s%s', host, port ? `:${port}` : '', protocol, version);
                });
                diagnosticsChannel.channel('undici:client:connectError').subscribe((evt)=>{
                    const { connectParams: { version, protocol, port, host }, error } = evt;
                    debuglog('connection to %s%s using %s%s errored - %s', host, port ? `:${port}` : '', protocol, version, error.message);
                });
                diagnosticsChannel.channel('undici:client:sendHeaders').subscribe((evt)=>{
                    const { request: { method, path, origin } } = evt;
                    debuglog('sending request to %s %s/%s', method, origin, path);
                });
            }
            diagnosticsChannel.channel('undici:websocket:open').subscribe((evt)=>{
                const { address: { address, port } } = evt;
                websocketDebuglog('connection opened %s%s', address, port ? `:${port}` : '');
            });
            diagnosticsChannel.channel('undici:websocket:close').subscribe((evt)=>{
                const { websocket, code, reason } = evt;
                websocketDebuglog('closed connection to %s - %s %s', websocket.url, code, reason);
            });
            diagnosticsChannel.channel('undici:websocket:socket_error').subscribe((err)=>{
                websocketDebuglog('connection errored - %s', err.message);
            });
            diagnosticsChannel.channel('undici:websocket:ping').subscribe((evt)=>{
                websocketDebuglog('ping received');
            });
            diagnosticsChannel.channel('undici:websocket:pong').subscribe((evt)=>{
                websocketDebuglog('pong received');
            });
        }
        module.exports = {
            channels
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js" (module) {
        "use strict";
        const kUndiciError = Symbol.for('undici.error.UND_ERR');
        class UndiciError extends Error {
            constructor(message){
                super(message);
                this.name = 'UndiciError';
                this.code = 'UND_ERR';
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kUndiciError];
            }
            [kUndiciError] = true;
        }
        const kConnectTimeoutError = Symbol.for('undici.error.UND_ERR_CONNECT_TIMEOUT');
        class ConnectTimeoutError extends UndiciError {
            constructor(message){
                super(message);
                this.name = 'ConnectTimeoutError';
                this.message = message || 'Connect Timeout Error';
                this.code = 'UND_ERR_CONNECT_TIMEOUT';
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kConnectTimeoutError];
            }
            [kConnectTimeoutError] = true;
        }
        const kHeadersTimeoutError = Symbol.for('undici.error.UND_ERR_HEADERS_TIMEOUT');
        class HeadersTimeoutError extends UndiciError {
            constructor(message){
                super(message);
                this.name = 'HeadersTimeoutError';
                this.message = message || 'Headers Timeout Error';
                this.code = 'UND_ERR_HEADERS_TIMEOUT';
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kHeadersTimeoutError];
            }
            [kHeadersTimeoutError] = true;
        }
        const kHeadersOverflowError = Symbol.for('undici.error.UND_ERR_HEADERS_OVERFLOW');
        class HeadersOverflowError extends UndiciError {
            constructor(message){
                super(message);
                this.name = 'HeadersOverflowError';
                this.message = message || 'Headers Overflow Error';
                this.code = 'UND_ERR_HEADERS_OVERFLOW';
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kHeadersOverflowError];
            }
            [kHeadersOverflowError] = true;
        }
        const kBodyTimeoutError = Symbol.for('undici.error.UND_ERR_BODY_TIMEOUT');
        class BodyTimeoutError extends UndiciError {
            constructor(message){
                super(message);
                this.name = 'BodyTimeoutError';
                this.message = message || 'Body Timeout Error';
                this.code = 'UND_ERR_BODY_TIMEOUT';
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kBodyTimeoutError];
            }
            [kBodyTimeoutError] = true;
        }
        const kResponseStatusCodeError = Symbol.for('undici.error.UND_ERR_RESPONSE_STATUS_CODE');
        class ResponseStatusCodeError extends UndiciError {
            constructor(message, statusCode, headers, body){
                super(message);
                this.name = 'ResponseStatusCodeError';
                this.message = message || 'Response Status Code Error';
                this.code = 'UND_ERR_RESPONSE_STATUS_CODE';
                this.body = body;
                this.status = statusCode;
                this.statusCode = statusCode;
                this.headers = headers;
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kResponseStatusCodeError];
            }
            [kResponseStatusCodeError] = true;
        }
        const kInvalidArgumentError = Symbol.for('undici.error.UND_ERR_INVALID_ARG');
        class InvalidArgumentError extends UndiciError {
            constructor(message){
                super(message);
                this.name = 'InvalidArgumentError';
                this.message = message || 'Invalid Argument Error';
                this.code = 'UND_ERR_INVALID_ARG';
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kInvalidArgumentError];
            }
            [kInvalidArgumentError] = true;
        }
        const kInvalidReturnValueError = Symbol.for('undici.error.UND_ERR_INVALID_RETURN_VALUE');
        class InvalidReturnValueError extends UndiciError {
            constructor(message){
                super(message);
                this.name = 'InvalidReturnValueError';
                this.message = message || 'Invalid Return Value Error';
                this.code = 'UND_ERR_INVALID_RETURN_VALUE';
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kInvalidReturnValueError];
            }
            [kInvalidReturnValueError] = true;
        }
        const kAbortError = Symbol.for('undici.error.UND_ERR_ABORT');
        class AbortError extends UndiciError {
            constructor(message){
                super(message);
                this.name = 'AbortError';
                this.message = message || 'The operation was aborted';
                this.code = 'UND_ERR_ABORT';
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kAbortError];
            }
            [kAbortError] = true;
        }
        const kRequestAbortedError = Symbol.for('undici.error.UND_ERR_ABORTED');
        class RequestAbortedError extends AbortError {
            constructor(message){
                super(message);
                this.name = 'AbortError';
                this.message = message || 'Request aborted';
                this.code = 'UND_ERR_ABORTED';
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kRequestAbortedError];
            }
            [kRequestAbortedError] = true;
        }
        const kInformationalError = Symbol.for('undici.error.UND_ERR_INFO');
        class InformationalError extends UndiciError {
            constructor(message){
                super(message);
                this.name = 'InformationalError';
                this.message = message || 'Request information';
                this.code = 'UND_ERR_INFO';
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kInformationalError];
            }
            [kInformationalError] = true;
        }
        const kRequestContentLengthMismatchError = Symbol.for('undici.error.UND_ERR_REQ_CONTENT_LENGTH_MISMATCH');
        class RequestContentLengthMismatchError extends UndiciError {
            constructor(message){
                super(message);
                this.name = 'RequestContentLengthMismatchError';
                this.message = message || 'Request body length does not match content-length header';
                this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH';
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kRequestContentLengthMismatchError];
            }
            [kRequestContentLengthMismatchError] = true;
        }
        const kResponseContentLengthMismatchError = Symbol.for('undici.error.UND_ERR_RES_CONTENT_LENGTH_MISMATCH');
        class ResponseContentLengthMismatchError extends UndiciError {
            constructor(message){
                super(message);
                this.name = 'ResponseContentLengthMismatchError';
                this.message = message || 'Response body length does not match content-length header';
                this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH';
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kResponseContentLengthMismatchError];
            }
            [kResponseContentLengthMismatchError] = true;
        }
        const kClientDestroyedError = Symbol.for('undici.error.UND_ERR_DESTROYED');
        class ClientDestroyedError extends UndiciError {
            constructor(message){
                super(message);
                this.name = 'ClientDestroyedError';
                this.message = message || 'The client is destroyed';
                this.code = 'UND_ERR_DESTROYED';
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kClientDestroyedError];
            }
            [kClientDestroyedError] = true;
        }
        const kClientClosedError = Symbol.for('undici.error.UND_ERR_CLOSED');
        class ClientClosedError extends UndiciError {
            constructor(message){
                super(message);
                this.name = 'ClientClosedError';
                this.message = message || 'The client is closed';
                this.code = 'UND_ERR_CLOSED';
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kClientClosedError];
            }
            [kClientClosedError] = true;
        }
        const kSocketError = Symbol.for('undici.error.UND_ERR_SOCKET');
        class SocketError extends UndiciError {
            constructor(message, socket){
                super(message);
                this.name = 'SocketError';
                this.message = message || 'Socket error';
                this.code = 'UND_ERR_SOCKET';
                this.socket = socket;
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kSocketError];
            }
            [kSocketError] = true;
        }
        const kNotSupportedError = Symbol.for('undici.error.UND_ERR_NOT_SUPPORTED');
        class NotSupportedError extends UndiciError {
            constructor(message){
                super(message);
                this.name = 'NotSupportedError';
                this.message = message || 'Not supported error';
                this.code = 'UND_ERR_NOT_SUPPORTED';
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kNotSupportedError];
            }
            [kNotSupportedError] = true;
        }
        const kBalancedPoolMissingUpstreamError = Symbol.for('undici.error.UND_ERR_BPL_MISSING_UPSTREAM');
        class BalancedPoolMissingUpstreamError extends UndiciError {
            constructor(message){
                super(message);
                this.name = 'MissingUpstreamError';
                this.message = message || 'No upstream has been added to the BalancedPool';
                this.code = 'UND_ERR_BPL_MISSING_UPSTREAM';
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kBalancedPoolMissingUpstreamError];
            }
            [kBalancedPoolMissingUpstreamError] = true;
        }
        const kHTTPParserError = Symbol.for('undici.error.UND_ERR_HTTP_PARSER');
        class HTTPParserError extends Error {
            constructor(message, code, data){
                super(message);
                this.name = 'HTTPParserError';
                this.code = code ? `HPE_${code}` : void 0;
                this.data = data ? data.toString() : void 0;
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kHTTPParserError];
            }
            [kHTTPParserError] = true;
        }
        const kResponseExceededMaxSizeError = Symbol.for('undici.error.UND_ERR_RES_EXCEEDED_MAX_SIZE');
        class ResponseExceededMaxSizeError extends UndiciError {
            constructor(message){
                super(message);
                this.name = 'ResponseExceededMaxSizeError';
                this.message = message || 'Response content exceeded max size';
                this.code = 'UND_ERR_RES_EXCEEDED_MAX_SIZE';
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kResponseExceededMaxSizeError];
            }
            [kResponseExceededMaxSizeError] = true;
        }
        const kRequestRetryError = Symbol.for('undici.error.UND_ERR_REQ_RETRY');
        class RequestRetryError extends UndiciError {
            constructor(message, code, { headers, data }){
                super(message);
                this.name = 'RequestRetryError';
                this.message = message || 'Request retry error';
                this.code = 'UND_ERR_REQ_RETRY';
                this.statusCode = code;
                this.data = data;
                this.headers = headers;
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kRequestRetryError];
            }
            [kRequestRetryError] = true;
        }
        const kResponseError = Symbol.for('undici.error.UND_ERR_RESPONSE');
        class ResponseError extends UndiciError {
            constructor(message, code, { headers, data }){
                super(message);
                this.name = 'ResponseError';
                this.message = message || 'Response error';
                this.code = 'UND_ERR_RESPONSE';
                this.statusCode = code;
                this.data = data;
                this.headers = headers;
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kResponseError];
            }
            [kResponseError] = true;
        }
        const kSecureProxyConnectionError = Symbol.for('undici.error.UND_ERR_PRX_TLS');
        class SecureProxyConnectionError extends UndiciError {
            constructor(cause, message, options){
                super(message, {
                    cause,
                    ...options ?? {}
                });
                this.name = 'SecureProxyConnectionError';
                this.message = message || 'Secure Proxy Connection failed';
                this.code = 'UND_ERR_PRX_TLS';
                this.cause = cause;
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kSecureProxyConnectionError];
            }
            [kSecureProxyConnectionError] = true;
        }
        module.exports = {
            AbortError,
            HTTPParserError,
            UndiciError,
            HeadersTimeoutError,
            HeadersOverflowError,
            BodyTimeoutError,
            RequestContentLengthMismatchError,
            ConnectTimeoutError,
            ResponseStatusCodeError,
            InvalidArgumentError,
            InvalidReturnValueError,
            RequestAbortedError,
            ClientDestroyedError,
            ClientClosedError,
            InformationalError,
            SocketError,
            NotSupportedError,
            ResponseContentLengthMismatchError,
            BalancedPoolMissingUpstreamError,
            ResponseExceededMaxSizeError,
            RequestRetryError,
            ResponseError,
            SecureProxyConnectionError
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/request.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { InvalidArgumentError, NotSupportedError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const assert = __webpack_require__("node:assert");
        const { isValidHTTPToken, isValidHeaderValue, isStream, destroy, isBuffer, isFormDataLike, isIterable, isBlobLike, buildURL, validateHandler, getServerName, normalizedMethodRecords } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { channels } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/diagnostics.js");
        const { headerNameLowerCasedRecord } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/constants.js");
        const invalidPathRegex = /[^\u0021-\u00ff]/;
        const kHandler = Symbol('handler');
        class Request {
            constructor(origin, { path, method, body, headers, query, idempotent, blocking, upgrade, headersTimeout, bodyTimeout, reset, throwOnError, expectContinue, servername }, handler){
                if ('string' != typeof path) throw new InvalidArgumentError('path must be a string');
                if ('/' === path[0] || path.startsWith('http://') || path.startsWith('https://') || 'CONNECT' === method) {
                    if (invalidPathRegex.test(path)) throw new InvalidArgumentError('invalid request path');
                } else throw new InvalidArgumentError('path must be an absolute URL or start with a slash');
                if ('string' != typeof method) throw new InvalidArgumentError('method must be a string');
                if (void 0 === normalizedMethodRecords[method] && !isValidHTTPToken(method)) throw new InvalidArgumentError('invalid request method');
                if (upgrade && 'string' != typeof upgrade) throw new InvalidArgumentError('upgrade must be a string');
                if (null != headersTimeout && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) throw new InvalidArgumentError('invalid headersTimeout');
                if (null != bodyTimeout && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) throw new InvalidArgumentError('invalid bodyTimeout');
                if (null != reset && 'boolean' != typeof reset) throw new InvalidArgumentError('invalid reset');
                if (null != expectContinue && 'boolean' != typeof expectContinue) throw new InvalidArgumentError('invalid expectContinue');
                this.headersTimeout = headersTimeout;
                this.bodyTimeout = bodyTimeout;
                this.throwOnError = true === throwOnError;
                this.method = method;
                this.abort = null;
                if (null == body) this.body = null;
                else if (isStream(body)) {
                    this.body = body;
                    const rState = this.body._readableState;
                    if (!rState || !rState.autoDestroy) {
                        this.endHandler = function() {
                            destroy(this);
                        };
                        this.body.on('end', this.endHandler);
                    }
                    this.errorHandler = (err)=>{
                        if (this.abort) this.abort(err);
                        else this.error = err;
                    };
                    this.body.on('error', this.errorHandler);
                } else if (isBuffer(body)) this.body = body.byteLength ? body : null;
                else if (ArrayBuffer.isView(body)) this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
                else if (body instanceof ArrayBuffer) this.body = body.byteLength ? Buffer.from(body) : null;
                else if ('string' == typeof body) this.body = body.length ? Buffer.from(body) : null;
                else if (isFormDataLike(body) || isIterable(body) || isBlobLike(body)) this.body = body;
                else throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable');
                this.completed = false;
                this.aborted = false;
                this.upgrade = upgrade || null;
                this.path = query ? buildURL(path, query) : path;
                this.origin = origin;
                this.idempotent = null == idempotent ? 'HEAD' === method || 'GET' === method : idempotent;
                this.blocking = null == blocking ? false : blocking;
                this.reset = null == reset ? null : reset;
                this.host = null;
                this.contentLength = null;
                this.contentType = null;
                this.headers = [];
                this.expectContinue = null != expectContinue ? expectContinue : false;
                if (Array.isArray(headers)) {
                    if (headers.length % 2 !== 0) throw new InvalidArgumentError('headers array must be even');
                    for(let i = 0; i < headers.length; i += 2)processHeader(this, headers[i], headers[i + 1]);
                } else if (headers && 'object' == typeof headers) if (headers[Symbol.iterator]) for (const header of headers){
                    if (!Array.isArray(header) || 2 !== header.length) throw new InvalidArgumentError('headers must be in key-value pair format');
                    processHeader(this, header[0], header[1]);
                }
                else {
                    const keys = Object.keys(headers);
                    for(let i = 0; i < keys.length; ++i)processHeader(this, keys[i], headers[keys[i]]);
                }
                else if (null != headers) throw new InvalidArgumentError('headers must be an object or an array');
                validateHandler(handler, method, upgrade);
                this.servername = servername || getServerName(this.host);
                this[kHandler] = handler;
                if (channels.create.hasSubscribers) channels.create.publish({
                    request: this
                });
            }
            onBodySent(chunk) {
                if (this[kHandler].onBodySent) try {
                    return this[kHandler].onBodySent(chunk);
                } catch (err) {
                    this.abort(err);
                }
            }
            onRequestSent() {
                if (channels.bodySent.hasSubscribers) channels.bodySent.publish({
                    request: this
                });
                if (this[kHandler].onRequestSent) try {
                    return this[kHandler].onRequestSent();
                } catch (err) {
                    this.abort(err);
                }
            }
            onConnect(abort) {
                assert(!this.aborted);
                assert(!this.completed);
                if (this.error) abort(this.error);
                else {
                    this.abort = abort;
                    return this[kHandler].onConnect(abort);
                }
            }
            onResponseStarted() {
                return this[kHandler].onResponseStarted?.();
            }
            onHeaders(statusCode, headers, resume, statusText) {
                assert(!this.aborted);
                assert(!this.completed);
                if (channels.headers.hasSubscribers) channels.headers.publish({
                    request: this,
                    response: {
                        statusCode,
                        headers,
                        statusText
                    }
                });
                try {
                    return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
                } catch (err) {
                    this.abort(err);
                }
            }
            onData(chunk) {
                assert(!this.aborted);
                assert(!this.completed);
                try {
                    return this[kHandler].onData(chunk);
                } catch (err) {
                    this.abort(err);
                    return false;
                }
            }
            onUpgrade(statusCode, headers, socket) {
                assert(!this.aborted);
                assert(!this.completed);
                return this[kHandler].onUpgrade(statusCode, headers, socket);
            }
            onComplete(trailers) {
                this.onFinally();
                assert(!this.aborted);
                this.completed = true;
                if (channels.trailers.hasSubscribers) channels.trailers.publish({
                    request: this,
                    trailers
                });
                try {
                    return this[kHandler].onComplete(trailers);
                } catch (err) {
                    this.onError(err);
                }
            }
            onError(error) {
                this.onFinally();
                if (channels.error.hasSubscribers) channels.error.publish({
                    request: this,
                    error
                });
                if (this.aborted) return;
                this.aborted = true;
                return this[kHandler].onError(error);
            }
            onFinally() {
                if (this.errorHandler) {
                    this.body.off('error', this.errorHandler);
                    this.errorHandler = null;
                }
                if (this.endHandler) {
                    this.body.off('end', this.endHandler);
                    this.endHandler = null;
                }
            }
            addHeader(key, value) {
                processHeader(this, key, value);
                return this;
            }
        }
        function processHeader(request, key, val) {
            if (val && 'object' == typeof val && !Array.isArray(val)) throw new InvalidArgumentError(`invalid ${key} header`);
            if (void 0 === val) return;
            let headerName = headerNameLowerCasedRecord[key];
            if (void 0 === headerName) {
                headerName = key.toLowerCase();
                if (void 0 === headerNameLowerCasedRecord[headerName] && !isValidHTTPToken(headerName)) throw new InvalidArgumentError('invalid header key');
            }
            if (Array.isArray(val)) {
                const arr = [];
                for(let i = 0; i < val.length; i++)if ('string' == typeof val[i]) {
                    if (!isValidHeaderValue(val[i])) throw new InvalidArgumentError(`invalid ${key} header`);
                    arr.push(val[i]);
                } else if (null === val[i]) arr.push('');
                else if ('object' == typeof val[i]) throw new InvalidArgumentError(`invalid ${key} header`);
                else arr.push(`${val[i]}`);
                val = arr;
            } else if ('string' == typeof val) {
                if (!isValidHeaderValue(val)) throw new InvalidArgumentError(`invalid ${key} header`);
            } else val = null === val ? '' : `${val}`;
            if (null === request.host && 'host' === headerName) {
                if ('string' != typeof val) throw new InvalidArgumentError('invalid host header');
                request.host = val;
            } else if (null === request.contentLength && 'content-length' === headerName) {
                request.contentLength = parseInt(val, 10);
                if (!Number.isFinite(request.contentLength)) throw new InvalidArgumentError('invalid content-length header');
            } else if (null === request.contentType && 'content-type' === headerName) {
                request.contentType = val;
                request.headers.push(key, val);
            } else if ('transfer-encoding' === headerName || 'keep-alive' === headerName || 'upgrade' === headerName) throw new InvalidArgumentError(`invalid ${headerName} header`);
            else if ('connection' === headerName) {
                const value = 'string' == typeof val ? val.toLowerCase() : null;
                if ('close' !== value && 'keep-alive' !== value) throw new InvalidArgumentError('invalid connection header');
                if ('close' === value) request.reset = true;
            } else if ('expect' === headerName) throw new NotSupportedError('expect header not supported');
            else request.headers.push(key, val);
        }
        module.exports = Request;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js" (module) {
        module.exports = {
            kClose: Symbol('close'),
            kDestroy: Symbol('destroy'),
            kDispatch: Symbol('dispatch'),
            kUrl: Symbol('url'),
            kWriting: Symbol('writing'),
            kResuming: Symbol('resuming'),
            kQueue: Symbol('queue'),
            kConnect: Symbol('connect'),
            kConnecting: Symbol('connecting'),
            kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),
            kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),
            kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),
            kKeepAliveTimeoutValue: Symbol('keep alive timeout'),
            kKeepAlive: Symbol('keep alive'),
            kHeadersTimeout: Symbol('headers timeout'),
            kBodyTimeout: Symbol('body timeout'),
            kServerName: Symbol('server name'),
            kLocalAddress: Symbol('local address'),
            kHost: Symbol('host'),
            kNoRef: Symbol('no ref'),
            kBodyUsed: Symbol('used'),
            kBody: Symbol('abstracted request body'),
            kRunning: Symbol('running'),
            kBlocking: Symbol('blocking'),
            kPending: Symbol('pending'),
            kSize: Symbol('size'),
            kBusy: Symbol('busy'),
            kQueued: Symbol('queued'),
            kFree: Symbol('free'),
            kConnected: Symbol('connected'),
            kClosed: Symbol('closed'),
            kNeedDrain: Symbol('need drain'),
            kReset: Symbol('reset'),
            kDestroyed: Symbol.for('nodejs.stream.destroyed'),
            kResume: Symbol('resume'),
            kOnError: Symbol('on error'),
            kMaxHeadersSize: Symbol('max headers size'),
            kRunningIdx: Symbol('running index'),
            kPendingIdx: Symbol('pending index'),
            kError: Symbol('error'),
            kClients: Symbol('clients'),
            kClient: Symbol('client'),
            kParser: Symbol('parser'),
            kOnDestroyed: Symbol('destroy callbacks'),
            kPipelining: Symbol('pipelining'),
            kSocket: Symbol('socket'),
            kHostHeader: Symbol('host header'),
            kConnector: Symbol('connector'),
            kStrictContentLength: Symbol('strict content length'),
            kMaxRedirections: Symbol('maxRedirections'),
            kMaxRequests: Symbol('maxRequestsPerClient'),
            kProxy: Symbol('proxy agent options'),
            kCounter: Symbol('socket request counter'),
            kInterceptors: Symbol('dispatch interceptors'),
            kMaxResponseSize: Symbol('max response size'),
            kHTTP2Session: Symbol('http2Session'),
            kHTTP2SessionState: Symbol('http2Session state'),
            kRetryHandlerDefaultRetry: Symbol('retry agent default retry'),
            kConstruct: Symbol('constructable'),
            kListeners: Symbol('listeners'),
            kHTTPContext: Symbol('http context'),
            kMaxConcurrentStreams: Symbol('max concurrent streams'),
            kNoProxyAgent: Symbol('no proxy agent'),
            kHttpProxyAgent: Symbol('http proxy agent'),
            kHttpsProxyAgent: Symbol('https proxy agent')
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/tree.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { wellknownHeaderNames, headerNameLowerCasedRecord } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/constants.js");
        class TstNode {
            value = null;
            left = null;
            middle = null;
            right = null;
            code;
            constructor(key, value, index){
                if (void 0 === index || index >= key.length) throw new TypeError('Unreachable');
                const code = this.code = key.charCodeAt(index);
                if (code > 0x7F) throw new TypeError('key must be ascii string');
                if (key.length !== ++index) this.middle = new TstNode(key, value, index);
                else this.value = value;
            }
            add(key, value) {
                const length = key.length;
                if (0 === length) throw new TypeError('Unreachable');
                let index = 0;
                let node = this;
                while(true){
                    const code = key.charCodeAt(index);
                    if (code > 0x7F) throw new TypeError('key must be ascii string');
                    if (node.code === code) if (length === ++index) {
                        node.value = value;
                        break;
                    } else if (null !== node.middle) node = node.middle;
                    else {
                        node.middle = new TstNode(key, value, index);
                        break;
                    }
                    else if (node.code < code) if (null !== node.left) node = node.left;
                    else {
                        node.left = new TstNode(key, value, index);
                        break;
                    }
                    else if (null !== node.right) node = node.right;
                    else {
                        node.right = new TstNode(key, value, index);
                        break;
                    }
                }
            }
            search(key) {
                const keylength = key.length;
                let index = 0;
                let node = this;
                while(null !== node && index < keylength){
                    let code = key[index];
                    if (code <= 0x5a && code >= 0x41) code |= 32;
                    while(null !== node){
                        if (code === node.code) {
                            if (keylength === ++index) return node;
                            node = node.middle;
                            break;
                        }
                        node = node.code < code ? node.left : node.right;
                    }
                }
                return null;
            }
        }
        class TernarySearchTree {
            node = null;
            insert(key, value) {
                if (null === this.node) this.node = new TstNode(key, value, 0);
                else this.node.add(key, value);
            }
            lookup(key) {
                return this.node?.search(key)?.value ?? null;
            }
        }
        const tree = new TernarySearchTree();
        for(let i = 0; i < wellknownHeaderNames.length; ++i){
            const key = headerNameLowerCasedRecord[wellknownHeaderNames[i]];
            tree.insert(key, key);
        }
        module.exports = {
            TernarySearchTree,
            tree
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const assert = __webpack_require__("node:assert");
        const { kDestroyed, kBodyUsed, kListeners, kBody } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const { IncomingMessage } = __webpack_require__("node:http");
        const stream = __webpack_require__("node:stream");
        const net = __webpack_require__("node:net");
        const { Blob: Blob1 } = __webpack_require__("node:buffer");
        const nodeUtil = __webpack_require__("node:util");
        const { stringify } = __webpack_require__("node:querystring");
        const { EventEmitter: EE } = __webpack_require__("node:events");
        const { InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const { headerNameLowerCasedRecord } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/constants.js");
        const { tree } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/tree.js");
        const [nodeMajor, nodeMinor] = process.versions.node.split('.').map((v)=>Number(v));
        class BodyAsyncIterable {
            constructor(body){
                this[kBody] = body;
                this[kBodyUsed] = false;
            }
            async *[Symbol.asyncIterator]() {
                assert(!this[kBodyUsed], 'disturbed');
                this[kBodyUsed] = true;
                yield* this[kBody];
            }
        }
        function wrapRequestBody(body) {
            if (isStream(body)) {
                if (0 === bodyLength(body)) body.on('data', function() {
                    assert(false);
                });
                if ('boolean' != typeof body.readableDidRead) {
                    body[kBodyUsed] = false;
                    EE.prototype.on.call(body, 'data', function() {
                        this[kBodyUsed] = true;
                    });
                }
                return body;
            }
            if (body && 'function' == typeof body.pipeTo) return new BodyAsyncIterable(body);
            if (body && 'string' != typeof body && !ArrayBuffer.isView(body) && isIterable(body)) return new BodyAsyncIterable(body);
            return body;
        }
        function nop() {}
        function isStream(obj) {
            return obj && 'object' == typeof obj && 'function' == typeof obj.pipe && 'function' == typeof obj.on;
        }
        function isBlobLike(object) {
            if (null === object) return false;
            {
                if (object instanceof Blob1) return true;
                if ('object' != typeof object) return false;
                const sTag = object[Symbol.toStringTag];
                return ('Blob' === sTag || 'File' === sTag) && ('stream' in object && 'function' == typeof object.stream || 'arrayBuffer' in object && 'function' == typeof object.arrayBuffer);
            }
        }
        function buildURL(url, queryParams) {
            if (url.includes('?') || url.includes('#')) throw new Error('Query params cannot be passed when url already contains "?" or "#".');
            const stringified = stringify(queryParams);
            if (stringified) url += '?' + stringified;
            return url;
        }
        function isValidPort(port) {
            const value = parseInt(port, 10);
            return value === Number(port) && value >= 0 && value <= 65535;
        }
        function isHttpOrHttpsPrefixed(value) {
            return null != value && 'h' === value[0] && 't' === value[1] && 't' === value[2] && 'p' === value[3] && (':' === value[4] || 's' === value[4] && ':' === value[5]);
        }
        function parseURL(url) {
            if ('string' == typeof url) {
                url = new URL(url);
                if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.');
                return url;
            }
            if (!url || 'object' != typeof url) throw new InvalidArgumentError('Invalid URL: The URL argument must be a non-null object.');
            if (!(url instanceof URL)) {
                if (null != url.port && '' !== url.port && false === isValidPort(url.port)) throw new InvalidArgumentError('Invalid URL: port must be a valid integer or a string representation of an integer.');
                if (null != url.path && 'string' != typeof url.path) throw new InvalidArgumentError('Invalid URL path: the path must be a string or null/undefined.');
                if (null != url.pathname && 'string' != typeof url.pathname) throw new InvalidArgumentError('Invalid URL pathname: the pathname must be a string or null/undefined.');
                if (null != url.hostname && 'string' != typeof url.hostname) throw new InvalidArgumentError('Invalid URL hostname: the hostname must be a string or null/undefined.');
                if (null != url.origin && 'string' != typeof url.origin) throw new InvalidArgumentError('Invalid URL origin: the origin must be a string or null/undefined.');
                if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.');
                const port = null != url.port ? url.port : 'https:' === url.protocol ? 443 : 80;
                let origin = null != url.origin ? url.origin : `${url.protocol || ''}//${url.hostname || ''}:${port}`;
                let path = null != url.path ? url.path : `${url.pathname || ''}${url.search || ''}`;
                if ('/' === origin[origin.length - 1]) origin = origin.slice(0, origin.length - 1);
                if (path && '/' !== path[0]) path = `/${path}`;
                return new URL(`${origin}${path}`);
            }
            if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.');
            return url;
        }
        function parseOrigin(url) {
            url = parseURL(url);
            if ('/' !== url.pathname || url.search || url.hash) throw new InvalidArgumentError('invalid url');
            return url;
        }
        function getHostname(host) {
            if ('[' === host[0]) {
                const idx = host.indexOf(']');
                assert(-1 !== idx);
                return host.substring(1, idx);
            }
            const idx = host.indexOf(':');
            if (-1 === idx) return host;
            return host.substring(0, idx);
        }
        function getServerName(host) {
            if (!host) return null;
            assert('string' == typeof host);
            const servername = getHostname(host);
            if (net.isIP(servername)) return '';
            return servername;
        }
        function deepClone(obj) {
            return JSON.parse(JSON.stringify(obj));
        }
        function isAsyncIterable(obj) {
            return !!(null != obj && 'function' == typeof obj[Symbol.asyncIterator]);
        }
        function isIterable(obj) {
            return !!(null != obj && ('function' == typeof obj[Symbol.iterator] || 'function' == typeof obj[Symbol.asyncIterator]));
        }
        function bodyLength(body) {
            if (null == body) return 0;
            if (isStream(body)) {
                const state = body._readableState;
                return state && false === state.objectMode && true === state.ended && Number.isFinite(state.length) ? state.length : null;
            }
            if (isBlobLike(body)) return null != body.size ? body.size : null;
            if (isBuffer(body)) return body.byteLength;
            return null;
        }
        function isDestroyed(body) {
            return body && !!(body.destroyed || body[kDestroyed] || stream.isDestroyed?.(body));
        }
        function destroy(stream, err) {
            if (null == stream || !isStream(stream) || isDestroyed(stream)) return;
            if ('function' == typeof stream.destroy) {
                if (Object.getPrototypeOf(stream).constructor === IncomingMessage) stream.socket = null;
                stream.destroy(err);
            } else if (err) queueMicrotask(()=>{
                stream.emit('error', err);
            });
            if (true !== stream.destroyed) stream[kDestroyed] = true;
        }
        const KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
        function parseKeepAliveTimeout(val) {
            const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
            return m ? 1000 * parseInt(m[1], 10) : null;
        }
        function headerNameToString(value) {
            return 'string' == typeof value ? headerNameLowerCasedRecord[value] ?? value.toLowerCase() : tree.lookup(value) ?? value.toString('latin1').toLowerCase();
        }
        function bufferToLowerCasedHeaderName(value) {
            return tree.lookup(value) ?? value.toString('latin1').toLowerCase();
        }
        function parseHeaders(headers, obj) {
            if (void 0 === obj) obj = {};
            for(let i = 0; i < headers.length; i += 2){
                const key = headerNameToString(headers[i]);
                let val = obj[key];
                if (val) {
                    if ('string' == typeof val) {
                        val = [
                            val
                        ];
                        obj[key] = val;
                    }
                    val.push(headers[i + 1].toString('utf8'));
                } else {
                    const headersValue = headers[i + 1];
                    if ('string' == typeof headersValue) obj[key] = headersValue;
                    else obj[key] = Array.isArray(headersValue) ? headersValue.map((x)=>x.toString('utf8')) : headersValue.toString('utf8');
                }
            }
            if ('content-length' in obj && 'content-disposition' in obj) obj['content-disposition'] = Buffer.from(obj['content-disposition']).toString('latin1');
            return obj;
        }
        function parseRawHeaders(headers) {
            const len = headers.length;
            const ret = new Array(len);
            let hasContentLength = false;
            let contentDispositionIdx = -1;
            let key;
            let val;
            let kLen = 0;
            for(let n = 0; n < headers.length; n += 2){
                key = headers[n];
                val = headers[n + 1];
                'string' != typeof key && (key = key.toString());
                'string' != typeof val && (val = val.toString('utf8'));
                kLen = key.length;
                if (14 === kLen && '-' === key[7] && ('content-length' === key || 'content-length' === key.toLowerCase())) hasContentLength = true;
                else if (19 === kLen && '-' === key[7] && ('content-disposition' === key || 'content-disposition' === key.toLowerCase())) contentDispositionIdx = n + 1;
                ret[n] = key;
                ret[n + 1] = val;
            }
            if (hasContentLength && -1 !== contentDispositionIdx) ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString('latin1');
            return ret;
        }
        function isBuffer(buffer) {
            return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
        }
        function validateHandler(handler, method, upgrade) {
            if (!handler || 'object' != typeof handler) throw new InvalidArgumentError('handler must be an object');
            if ('function' != typeof handler.onConnect) throw new InvalidArgumentError('invalid onConnect method');
            if ('function' != typeof handler.onError) throw new InvalidArgumentError('invalid onError method');
            if ('function' != typeof handler.onBodySent && void 0 !== handler.onBodySent) throw new InvalidArgumentError('invalid onBodySent method');
            if (upgrade || 'CONNECT' === method) {
                if ('function' != typeof handler.onUpgrade) throw new InvalidArgumentError('invalid onUpgrade method');
            } else {
                if ('function' != typeof handler.onHeaders) throw new InvalidArgumentError('invalid onHeaders method');
                if ('function' != typeof handler.onData) throw new InvalidArgumentError('invalid onData method');
                if ('function' != typeof handler.onComplete) throw new InvalidArgumentError('invalid onComplete method');
            }
        }
        function isDisturbed(body) {
            return !!(body && (stream.isDisturbed(body) || body[kBodyUsed]));
        }
        function isErrored(body) {
            return !!(body && stream.isErrored(body));
        }
        function isReadable(body) {
            return !!(body && stream.isReadable(body));
        }
        function getSocketInfo(socket) {
            return {
                localAddress: socket.localAddress,
                localPort: socket.localPort,
                remoteAddress: socket.remoteAddress,
                remotePort: socket.remotePort,
                remoteFamily: socket.remoteFamily,
                timeout: socket.timeout,
                bytesWritten: socket.bytesWritten,
                bytesRead: socket.bytesRead
            };
        }
        function ReadableStreamFrom(iterable) {
            let iterator;
            return new ReadableStream({
                async start () {
                    iterator = iterable[Symbol.asyncIterator]();
                },
                async pull (controller) {
                    const { done, value } = await iterator.next();
                    if (done) queueMicrotask(()=>{
                        controller.close();
                        controller.byobRequest?.respond(0);
                    });
                    else {
                        const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
                        if (buf.byteLength) controller.enqueue(new Uint8Array(buf));
                    }
                    return controller.desiredSize > 0;
                },
                async cancel (reason) {
                    await iterator.return();
                },
                type: 'bytes'
            });
        }
        function isFormDataLike(object) {
            return object && 'object' == typeof object && 'function' == typeof object.append && 'function' == typeof object.delete && 'function' == typeof object.get && 'function' == typeof object.getAll && 'function' == typeof object.has && 'function' == typeof object.set && 'FormData' === object[Symbol.toStringTag];
        }
        function addAbortListener(signal, listener) {
            if ('addEventListener' in signal) {
                signal.addEventListener('abort', listener, {
                    once: true
                });
                return ()=>signal.removeEventListener('abort', listener);
            }
            signal.addListener('abort', listener);
            return ()=>signal.removeListener('abort', listener);
        }
        const hasToWellFormed = 'function' == typeof String.prototype.toWellFormed;
        const hasIsWellFormed = 'function' == typeof String.prototype.isWellFormed;
        function toUSVString(val) {
            return hasToWellFormed ? `${val}`.toWellFormed() : nodeUtil.toUSVString(val);
        }
        function isUSVString(val) {
            return hasIsWellFormed ? `${val}`.isWellFormed() : toUSVString(val) === `${val}`;
        }
        function isTokenCharCode(c) {
            switch(c){
                case 0x22:
                case 0x28:
                case 0x29:
                case 0x2c:
                case 0x2f:
                case 0x3a:
                case 0x3b:
                case 0x3c:
                case 0x3d:
                case 0x3e:
                case 0x3f:
                case 0x40:
                case 0x5b:
                case 0x5c:
                case 0x5d:
                case 0x7b:
                case 0x7d:
                    return false;
                default:
                    return c >= 0x21 && c <= 0x7e;
            }
        }
        function isValidHTTPToken(characters) {
            if (0 === characters.length) return false;
            for(let i = 0; i < characters.length; ++i)if (!isTokenCharCode(characters.charCodeAt(i))) return false;
            return true;
        }
        const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
        function isValidHeaderValue(characters) {
            return !headerCharRegex.test(characters);
        }
        function parseRangeHeader(range) {
            if (null == range || '' === range) return {
                start: 0,
                end: null,
                size: null
            };
            const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
            return m ? {
                start: parseInt(m[1]),
                end: m[2] ? parseInt(m[2]) : null,
                size: m[3] ? parseInt(m[3]) : null
            } : null;
        }
        function addListener(obj, name, listener) {
            const listeners = obj[kListeners] ??= [];
            listeners.push([
                name,
                listener
            ]);
            obj.on(name, listener);
            return obj;
        }
        function removeAllListeners(obj) {
            for (const [name, listener] of obj[kListeners] ?? [])obj.removeListener(name, listener);
            obj[kListeners] = null;
        }
        function errorRequest(client, request, err) {
            try {
                request.onError(err);
                assert(request.aborted);
            } catch (err) {
                client.emit('error', err);
            }
        }
        const kEnumerableProperty = Object.create(null);
        kEnumerableProperty.enumerable = true;
        const normalizedMethodRecordsBase = {
            delete: 'DELETE',
            DELETE: 'DELETE',
            get: 'GET',
            GET: 'GET',
            head: 'HEAD',
            HEAD: 'HEAD',
            options: 'OPTIONS',
            OPTIONS: 'OPTIONS',
            post: 'POST',
            POST: 'POST',
            put: 'PUT',
            PUT: 'PUT'
        };
        const normalizedMethodRecords = {
            ...normalizedMethodRecordsBase,
            patch: 'patch',
            PATCH: 'PATCH'
        };
        Object.setPrototypeOf(normalizedMethodRecordsBase, null);
        Object.setPrototypeOf(normalizedMethodRecords, null);
        module.exports = {
            kEnumerableProperty,
            nop,
            isDisturbed,
            isErrored,
            isReadable,
            toUSVString,
            isUSVString,
            isBlobLike,
            parseOrigin,
            parseURL,
            getServerName,
            isStream,
            isIterable,
            isAsyncIterable,
            isDestroyed,
            headerNameToString,
            bufferToLowerCasedHeaderName,
            addListener,
            removeAllListeners,
            errorRequest,
            parseRawHeaders,
            parseHeaders,
            parseKeepAliveTimeout,
            destroy,
            bodyLength,
            deepClone,
            ReadableStreamFrom,
            isBuffer,
            validateHandler,
            getSocketInfo,
            isFormDataLike,
            buildURL,
            addAbortListener,
            isValidHTTPToken,
            isValidHeaderValue,
            isTokenCharCode,
            parseRangeHeader,
            normalizedMethodRecordsBase,
            normalizedMethodRecords,
            isValidPort,
            isHttpOrHttpsPrefixed,
            nodeMajor,
            nodeMinor,
            safeHTTPMethods: [
                'GET',
                'HEAD',
                'OPTIONS',
                'TRACE'
            ],
            wrapRequestBody
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/agent.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const DispatcherBase = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/dispatcher-base.js");
        const Pool = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/pool.js");
        const Client = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/client.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const createRedirectInterceptor = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/interceptor/redirect-interceptor.js");
        const kOnConnect = Symbol('onConnect');
        const kOnDisconnect = Symbol('onDisconnect');
        const kOnConnectionError = Symbol('onConnectionError');
        const kMaxRedirections = Symbol('maxRedirections');
        const kOnDrain = Symbol('onDrain');
        const kFactory = Symbol('factory');
        const kOptions = Symbol('options');
        function defaultFactory(origin, opts) {
            return opts && 1 === opts.connections ? new Client(origin, opts) : new Pool(origin, opts);
        }
        class Agent extends DispatcherBase {
            constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}){
                super();
                if ('function' != typeof factory) throw new InvalidArgumentError('factory must be a function.');
                if (null != connect && 'function' != typeof connect && 'object' != typeof connect) throw new InvalidArgumentError('connect must be a function or an object');
                if (!Number.isInteger(maxRedirections) || maxRedirections < 0) throw new InvalidArgumentError('maxRedirections must be a positive number');
                if (connect && 'function' != typeof connect) connect = {
                    ...connect
                };
                this[kInterceptors] = options.interceptors?.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [
                    createRedirectInterceptor({
                        maxRedirections
                    })
                ];
                this[kOptions] = {
                    ...util.deepClone(options),
                    connect
                };
                this[kOptions].interceptors = options.interceptors ? {
                    ...options.interceptors
                } : void 0;
                this[kMaxRedirections] = maxRedirections;
                this[kFactory] = factory;
                this[kClients] = new Map();
                this[kOnDrain] = (origin, targets)=>{
                    this.emit('drain', origin, [
                        this,
                        ...targets
                    ]);
                };
                this[kOnConnect] = (origin, targets)=>{
                    this.emit('connect', origin, [
                        this,
                        ...targets
                    ]);
                };
                this[kOnDisconnect] = (origin, targets, err)=>{
                    this.emit('disconnect', origin, [
                        this,
                        ...targets
                    ], err);
                };
                this[kOnConnectionError] = (origin, targets, err)=>{
                    this.emit('connectionError', origin, [
                        this,
                        ...targets
                    ], err);
                };
            }
            get [kRunning]() {
                let ret = 0;
                for (const client of this[kClients].values())ret += client[kRunning];
                return ret;
            }
            [kDispatch](opts, handler) {
                let key;
                if (opts.origin && ('string' == typeof opts.origin || opts.origin instanceof URL)) key = String(opts.origin);
                else throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.');
                let dispatcher = this[kClients].get(key);
                if (!dispatcher) {
                    dispatcher = this[kFactory](opts.origin, this[kOptions]).on('drain', this[kOnDrain]).on('connect', this[kOnConnect]).on('disconnect', this[kOnDisconnect]).on('connectionError', this[kOnConnectionError]);
                    this[kClients].set(key, dispatcher);
                }
                return dispatcher.dispatch(opts, handler);
            }
            async [kClose]() {
                const closePromises = [];
                for (const client of this[kClients].values())closePromises.push(client.close());
                this[kClients].clear();
                await Promise.all(closePromises);
            }
            async [kDestroy](err) {
                const destroyPromises = [];
                for (const client of this[kClients].values())destroyPromises.push(client.destroy(err));
                this[kClients].clear();
                await Promise.all(destroyPromises);
            }
        }
        module.exports = Agent;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/balanced-pool.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { BalancedPoolMissingUpstreamError, InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const { PoolBase, kClients, kNeedDrain, kAddClient, kRemoveClient, kGetDispatcher } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/pool-base.js");
        const Pool = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/pool.js");
        const { kUrl, kInterceptors } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const { parseOrigin } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const kFactory = Symbol('factory');
        const kOptions = Symbol('options');
        const kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor');
        const kCurrentWeight = Symbol('kCurrentWeight');
        const kIndex = Symbol('kIndex');
        const kWeight = Symbol('kWeight');
        const kMaxWeightPerServer = Symbol('kMaxWeightPerServer');
        const kErrorPenalty = Symbol('kErrorPenalty');
        function getGreatestCommonDivisor(a, b) {
            if (0 === a) return b;
            while(0 !== b){
                const t = b;
                b = a % b;
                a = t;
            }
            return a;
        }
        function defaultFactory(origin, opts) {
            return new Pool(origin, opts);
        }
        class BalancedPool extends PoolBase {
            constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}){
                super();
                this[kOptions] = opts;
                this[kIndex] = -1;
                this[kCurrentWeight] = 0;
                this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
                this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
                if (!Array.isArray(upstreams)) upstreams = [
                    upstreams
                ];
                if ('function' != typeof factory) throw new InvalidArgumentError('factory must be a function.');
                this[kInterceptors] = opts.interceptors?.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
                this[kFactory] = factory;
                for (const upstream of upstreams)this.addUpstream(upstream);
                this._updateBalancedPoolStats();
            }
            addUpstream(upstream) {
                const upstreamOrigin = parseOrigin(upstream).origin;
                if (this[kClients].find((pool)=>pool[kUrl].origin === upstreamOrigin && true !== pool.closed && true !== pool.destroyed)) return this;
                const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
                this[kAddClient](pool);
                pool.on('connect', ()=>{
                    pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
                });
                pool.on('connectionError', ()=>{
                    pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
                    this._updateBalancedPoolStats();
                });
                pool.on('disconnect', (...args)=>{
                    const err = args[2];
                    if (err && 'UND_ERR_SOCKET' === err.code) {
                        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
                        this._updateBalancedPoolStats();
                    }
                });
                for (const client of this[kClients])client[kWeight] = this[kMaxWeightPerServer];
                this._updateBalancedPoolStats();
                return this;
            }
            _updateBalancedPoolStats() {
                let result = 0;
                for(let i = 0; i < this[kClients].length; i++)result = getGreatestCommonDivisor(this[kClients][i][kWeight], result);
                this[kGreatestCommonDivisor] = result;
            }
            removeUpstream(upstream) {
                const upstreamOrigin = parseOrigin(upstream).origin;
                const pool = this[kClients].find((pool)=>pool[kUrl].origin === upstreamOrigin && true !== pool.closed && true !== pool.destroyed);
                if (pool) this[kRemoveClient](pool);
                return this;
            }
            get upstreams() {
                return this[kClients].filter((dispatcher)=>true !== dispatcher.closed && true !== dispatcher.destroyed).map((p)=>p[kUrl].origin);
            }
            [kGetDispatcher]() {
                if (0 === this[kClients].length) throw new BalancedPoolMissingUpstreamError();
                const dispatcher = this[kClients].find((dispatcher)=>!dispatcher[kNeedDrain] && true !== dispatcher.closed && true !== dispatcher.destroyed);
                if (!dispatcher) return;
                const allClientsBusy = this[kClients].map((pool)=>pool[kNeedDrain]).reduce((a, b)=>a && b, true);
                if (allClientsBusy) return;
                let counter = 0;
                let maxWeightIndex = this[kClients].findIndex((pool)=>!pool[kNeedDrain]);
                while(counter++ < this[kClients].length){
                    this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
                    const pool = this[kClients][this[kIndex]];
                    if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) maxWeightIndex = this[kIndex];
                    if (0 === this[kIndex]) {
                        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
                        if (this[kCurrentWeight] <= 0) this[kCurrentWeight] = this[kMaxWeightPerServer];
                    }
                    if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) return pool;
                }
                this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
                this[kIndex] = maxWeightIndex;
                return this[kClients][maxWeightIndex];
            }
        }
        module.exports = BalancedPool;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/client-h1.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const assert = __webpack_require__("node:assert");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { channels } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/diagnostics.js");
        const timers = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/util/timers.js");
        const { RequestContentLengthMismatchError, ResponseContentLengthMismatchError, RequestAbortedError, HeadersTimeoutError, HeadersOverflowError, SocketError, InformationalError, BodyTimeoutError, HTTPParserError, ResponseExceededMaxSizeError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const { kUrl, kReset, kClient, kParser, kBlocking, kRunning, kPending, kSize, kWriting, kQueue, kNoRef, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError, kPipelining, kSocket, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kMaxRequests, kCounter, kMaxResponseSize, kOnError, kResume, kHTTPContext } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const constants = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/llhttp/constants.js");
        const EMPTY_BUF = Buffer.alloc(0);
        const FastBuffer = Buffer[Symbol.species];
        const addListener = util.addListener;
        const removeAllListeners = util.removeAllListeners;
        let extractBody;
        async function lazyllhttp() {
            const llhttpWasmData = process.env.JEST_WORKER_ID ? __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/llhttp/llhttp-wasm.js") : void 0;
            let mod;
            try {
                mod = await WebAssembly.compile(__webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"));
            } catch (e) {
                mod = await WebAssembly.compile(llhttpWasmData || __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/llhttp/llhttp-wasm.js"));
            }
            return await WebAssembly.instantiate(mod, {
                env: {
                    wasm_on_url: (p, at, len)=>0,
                    wasm_on_status: (p, at, len)=>{
                        assert(currentParser.ptr === p);
                        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
                        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
                    },
                    wasm_on_message_begin: (p)=>{
                        assert(currentParser.ptr === p);
                        return currentParser.onMessageBegin() || 0;
                    },
                    wasm_on_header_field: (p, at, len)=>{
                        assert(currentParser.ptr === p);
                        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
                        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
                    },
                    wasm_on_header_value: (p, at, len)=>{
                        assert(currentParser.ptr === p);
                        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
                        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
                    },
                    wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive)=>{
                        assert(currentParser.ptr === p);
                        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
                    },
                    wasm_on_body: (p, at, len)=>{
                        assert(currentParser.ptr === p);
                        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
                        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
                    },
                    wasm_on_message_complete: (p)=>{
                        assert(currentParser.ptr === p);
                        return currentParser.onMessageComplete() || 0;
                    }
                }
            });
        }
        let llhttpInstance = null;
        let llhttpPromise = lazyllhttp();
        llhttpPromise.catch();
        let currentParser = null;
        let currentBufferRef = null;
        let currentBufferSize = 0;
        let currentBufferPtr = null;
        const USE_NATIVE_TIMER = 0;
        const USE_FAST_TIMER = 1;
        const TIMEOUT_HEADERS = 2 | USE_FAST_TIMER;
        const TIMEOUT_BODY = 4 | USE_FAST_TIMER;
        const TIMEOUT_KEEP_ALIVE = 8 | USE_NATIVE_TIMER;
        class Parser {
            constructor(client, socket, { exports: exports1 }){
                assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
                this.llhttp = exports1;
                this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
                this.client = client;
                this.socket = socket;
                this.timeout = null;
                this.timeoutValue = null;
                this.timeoutType = null;
                this.statusCode = null;
                this.statusText = '';
                this.upgrade = false;
                this.headers = [];
                this.headersSize = 0;
                this.headersMaxSize = client[kMaxHeadersSize];
                this.shouldKeepAlive = false;
                this.paused = false;
                this.resume = this.resume.bind(this);
                this.bytesRead = 0;
                this.keepAlive = '';
                this.contentLength = '';
                this.connection = '';
                this.maxResponseSize = client[kMaxResponseSize];
            }
            setTimeout(delay, type) {
                if (delay !== this.timeoutValue || type & USE_FAST_TIMER ^ this.timeoutType & USE_FAST_TIMER) {
                    if (this.timeout) {
                        timers.clearTimeout(this.timeout);
                        this.timeout = null;
                    }
                    if (delay) if (type & USE_FAST_TIMER) this.timeout = timers.setFastTimeout(onParserTimeout, delay, new WeakRef(this));
                    else {
                        this.timeout = setTimeout(onParserTimeout, delay, new WeakRef(this));
                        this.timeout.unref();
                    }
                    this.timeoutValue = delay;
                } else if (this.timeout) {
                    if (this.timeout.refresh) this.timeout.refresh();
                }
                this.timeoutType = type;
            }
            resume() {
                if (this.socket.destroyed || !this.paused) return;
                assert(null != this.ptr);
                assert(null == currentParser);
                this.llhttp.llhttp_resume(this.ptr);
                assert(this.timeoutType === TIMEOUT_BODY);
                if (this.timeout) {
                    if (this.timeout.refresh) this.timeout.refresh();
                }
                this.paused = false;
                this.execute(this.socket.read() || EMPTY_BUF);
                this.readMore();
            }
            readMore() {
                while(!this.paused && this.ptr){
                    const chunk = this.socket.read();
                    if (null === chunk) break;
                    this.execute(chunk);
                }
            }
            execute(data) {
                assert(null != this.ptr);
                assert(null == currentParser);
                assert(!this.paused);
                const { socket, llhttp } = this;
                if (data.length > currentBufferSize) {
                    if (currentBufferPtr) llhttp.free(currentBufferPtr);
                    currentBufferSize = 4096 * Math.ceil(data.length / 4096);
                    currentBufferPtr = llhttp.malloc(currentBufferSize);
                }
                new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
                try {
                    let ret;
                    try {
                        currentBufferRef = data;
                        currentParser = this;
                        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
                    } catch (err) {
                        throw err;
                    } finally{
                        currentParser = null;
                        currentBufferRef = null;
                    }
                    const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
                    if (ret === constants.ERROR.PAUSED_UPGRADE) this.onUpgrade(data.slice(offset));
                    else if (ret === constants.ERROR.PAUSED) {
                        this.paused = true;
                        socket.unshift(data.slice(offset));
                    } else if (ret !== constants.ERROR.OK) {
                        const ptr = llhttp.llhttp_get_error_reason(this.ptr);
                        let message = '';
                        if (ptr) {
                            const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
                            message = 'Response does not match the HTTP/1.1 protocol (' + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ')';
                        }
                        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
                    }
                } catch (err) {
                    util.destroy(socket, err);
                }
            }
            destroy() {
                assert(null != this.ptr);
                assert(null == currentParser);
                this.llhttp.llhttp_free(this.ptr);
                this.ptr = null;
                this.timeout && timers.clearTimeout(this.timeout);
                this.timeout = null;
                this.timeoutValue = null;
                this.timeoutType = null;
                this.paused = false;
            }
            onStatus(buf) {
                this.statusText = buf.toString();
            }
            onMessageBegin() {
                const { socket, client } = this;
                if (socket.destroyed) return -1;
                const request = client[kQueue][client[kRunningIdx]];
                if (!request) return -1;
                request.onResponseStarted();
            }
            onHeaderField(buf) {
                const len = this.headers.length;
                if ((1 & len) === 0) this.headers.push(buf);
                else this.headers[len - 1] = Buffer.concat([
                    this.headers[len - 1],
                    buf
                ]);
                this.trackHeader(buf.length);
            }
            onHeaderValue(buf) {
                let len = this.headers.length;
                if ((1 & len) === 1) {
                    this.headers.push(buf);
                    len += 1;
                } else this.headers[len - 1] = Buffer.concat([
                    this.headers[len - 1],
                    buf
                ]);
                const key = this.headers[len - 2];
                if (10 === key.length) {
                    const headerName = util.bufferToLowerCasedHeaderName(key);
                    if ('keep-alive' === headerName) this.keepAlive += buf.toString();
                    else if ('connection' === headerName) this.connection += buf.toString();
                } else if (14 === key.length && 'content-length' === util.bufferToLowerCasedHeaderName(key)) this.contentLength += buf.toString();
                this.trackHeader(buf.length);
            }
            trackHeader(len) {
                this.headersSize += len;
                if (this.headersSize >= this.headersMaxSize) util.destroy(this.socket, new HeadersOverflowError());
            }
            onUpgrade(head) {
                const { upgrade, client, socket, headers, statusCode } = this;
                assert(upgrade);
                assert(client[kSocket] === socket);
                assert(!socket.destroyed);
                assert(!this.paused);
                assert((1 & headers.length) === 0);
                const request = client[kQueue][client[kRunningIdx]];
                assert(request);
                assert(request.upgrade || 'CONNECT' === request.method);
                this.statusCode = null;
                this.statusText = '';
                this.shouldKeepAlive = null;
                this.headers = [];
                this.headersSize = 0;
                socket.unshift(head);
                socket[kParser].destroy();
                socket[kParser] = null;
                socket[kClient] = null;
                socket[kError] = null;
                removeAllListeners(socket);
                client[kSocket] = null;
                client[kHTTPContext] = null;
                client[kQueue][client[kRunningIdx]++] = null;
                client.emit('disconnect', client[kUrl], [
                    client
                ], new InformationalError('upgrade'));
                try {
                    request.onUpgrade(statusCode, headers, socket);
                } catch (err) {
                    util.destroy(socket, err);
                }
                client[kResume]();
            }
            onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
                const { client, socket, headers, statusText } = this;
                if (socket.destroyed) return -1;
                const request = client[kQueue][client[kRunningIdx]];
                if (!request) return -1;
                assert(!this.upgrade);
                assert(this.statusCode < 200);
                if (100 === statusCode) {
                    util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)));
                    return -1;
                }
                if (upgrade && !request.upgrade) {
                    util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)));
                    return -1;
                }
                assert(this.timeoutType === TIMEOUT_HEADERS);
                this.statusCode = statusCode;
                this.shouldKeepAlive = shouldKeepAlive || 'HEAD' === request.method && !socket[kReset] && 'keep-alive' === this.connection.toLowerCase();
                if (this.statusCode >= 200) {
                    const bodyTimeout = null != request.bodyTimeout ? request.bodyTimeout : client[kBodyTimeout];
                    this.setTimeout(bodyTimeout, TIMEOUT_BODY);
                } else if (this.timeout) {
                    if (this.timeout.refresh) this.timeout.refresh();
                }
                if ('CONNECT' === request.method) {
                    assert(1 === client[kRunning]);
                    this.upgrade = true;
                    return 2;
                }
                if (upgrade) {
                    assert(1 === client[kRunning]);
                    this.upgrade = true;
                    return 2;
                }
                assert((1 & this.headers.length) === 0);
                this.headers = [];
                this.headersSize = 0;
                if (this.shouldKeepAlive && client[kPipelining]) {
                    const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
                    if (null != keepAliveTimeout) {
                        const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
                        if (timeout <= 0) socket[kReset] = true;
                        else client[kKeepAliveTimeoutValue] = timeout;
                    } else client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
                } else socket[kReset] = true;
                const pause = false === request.onHeaders(statusCode, headers, this.resume, statusText);
                if (request.aborted) return -1;
                if ('HEAD' === request.method) return 1;
                if (statusCode < 200) return 1;
                if (socket[kBlocking]) {
                    socket[kBlocking] = false;
                    client[kResume]();
                }
                return pause ? constants.ERROR.PAUSED : 0;
            }
            onBody(buf) {
                const { client, socket, statusCode, maxResponseSize } = this;
                if (socket.destroyed) return -1;
                const request = client[kQueue][client[kRunningIdx]];
                assert(request);
                assert(this.timeoutType === TIMEOUT_BODY);
                if (this.timeout) {
                    if (this.timeout.refresh) this.timeout.refresh();
                }
                assert(statusCode >= 200);
                if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
                    util.destroy(socket, new ResponseExceededMaxSizeError());
                    return -1;
                }
                this.bytesRead += buf.length;
                if (false === request.onData(buf)) return constants.ERROR.PAUSED;
            }
            onMessageComplete() {
                const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
                if (socket.destroyed && (!statusCode || shouldKeepAlive)) return -1;
                if (upgrade) return;
                assert(statusCode >= 100);
                assert((1 & this.headers.length) === 0);
                const request = client[kQueue][client[kRunningIdx]];
                assert(request);
                this.statusCode = null;
                this.statusText = '';
                this.bytesRead = 0;
                this.contentLength = '';
                this.keepAlive = '';
                this.connection = '';
                this.headers = [];
                this.headersSize = 0;
                if (statusCode < 200) return;
                if ('HEAD' !== request.method && contentLength && bytesRead !== parseInt(contentLength, 10)) {
                    util.destroy(socket, new ResponseContentLengthMismatchError());
                    return -1;
                }
                request.onComplete(headers);
                client[kQueue][client[kRunningIdx]++] = null;
                if (socket[kWriting]) {
                    assert(0 === client[kRunning]);
                    util.destroy(socket, new InformationalError('reset'));
                    return constants.ERROR.PAUSED;
                }
                if (shouldKeepAlive) if (socket[kReset] && 0 === client[kRunning]) {
                    util.destroy(socket, new InformationalError('reset'));
                    return constants.ERROR.PAUSED;
                } else if (null == client[kPipelining] || 1 === client[kPipelining]) setImmediate(()=>client[kResume]());
                else client[kResume]();
                else {
                    util.destroy(socket, new InformationalError('reset'));
                    return constants.ERROR.PAUSED;
                }
            }
        }
        function onParserTimeout(parser) {
            const { socket, timeoutType, client, paused } = parser.deref();
            if (timeoutType === TIMEOUT_HEADERS) {
                if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
                    assert(!paused, 'cannot be paused while waiting for headers');
                    util.destroy(socket, new HeadersTimeoutError());
                }
            } else if (timeoutType === TIMEOUT_BODY) {
                if (!paused) util.destroy(socket, new BodyTimeoutError());
            } else if (timeoutType === TIMEOUT_KEEP_ALIVE) {
                assert(0 === client[kRunning] && client[kKeepAliveTimeoutValue]);
                util.destroy(socket, new InformationalError('socket idle timeout'));
            }
        }
        async function connectH1(client, socket) {
            client[kSocket] = socket;
            if (!llhttpInstance) {
                llhttpInstance = await llhttpPromise;
                llhttpPromise = null;
            }
            socket[kNoRef] = false;
            socket[kWriting] = false;
            socket[kReset] = false;
            socket[kBlocking] = false;
            socket[kParser] = new Parser(client, socket, llhttpInstance);
            addListener(socket, 'error', function(err) {
                assert('ERR_TLS_CERT_ALTNAME_INVALID' !== err.code);
                const parser = this[kParser];
                if ('ECONNRESET' === err.code && parser.statusCode && !parser.shouldKeepAlive) return void parser.onMessageComplete();
                this[kError] = err;
                this[kClient][kOnError](err);
            });
            addListener(socket, 'readable', function() {
                const parser = this[kParser];
                if (parser) parser.readMore();
            });
            addListener(socket, 'end', function() {
                const parser = this[kParser];
                if (parser.statusCode && !parser.shouldKeepAlive) return void parser.onMessageComplete();
                util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)));
            });
            addListener(socket, 'close', function() {
                const client = this[kClient];
                const parser = this[kParser];
                if (parser) {
                    if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) parser.onMessageComplete();
                    this[kParser].destroy();
                    this[kParser] = null;
                }
                const err = this[kError] || new SocketError('closed', util.getSocketInfo(this));
                client[kSocket] = null;
                client[kHTTPContext] = null;
                if (client.destroyed) {
                    assert(0 === client[kPending]);
                    const requests = client[kQueue].splice(client[kRunningIdx]);
                    for(let i = 0; i < requests.length; i++){
                        const request = requests[i];
                        util.errorRequest(client, request, err);
                    }
                } else if (client[kRunning] > 0 && 'UND_ERR_INFO' !== err.code) {
                    const request = client[kQueue][client[kRunningIdx]];
                    client[kQueue][client[kRunningIdx]++] = null;
                    util.errorRequest(client, request, err);
                }
                client[kPendingIdx] = client[kRunningIdx];
                assert(0 === client[kRunning]);
                client.emit('disconnect', client[kUrl], [
                    client
                ], err);
                client[kResume]();
            });
            let closed = false;
            socket.on('close', ()=>{
                closed = true;
            });
            return {
                version: 'h1',
                defaultPipelining: 1,
                write (...args) {
                    return writeH1(client, ...args);
                },
                resume () {
                    resumeH1(client);
                },
                destroy (err, callback) {
                    if (closed) queueMicrotask(callback);
                    else socket.destroy(err).on('close', callback);
                },
                get destroyed () {
                    return socket.destroyed;
                },
                busy (request) {
                    if (socket[kWriting] || socket[kReset] || socket[kBlocking]) return true;
                    if (request) {
                        if (client[kRunning] > 0 && !request.idempotent) return true;
                        if (client[kRunning] > 0 && (request.upgrade || 'CONNECT' === request.method)) return true;
                        if (client[kRunning] > 0 && 0 !== util.bodyLength(request.body) && (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) return true;
                    }
                    return false;
                }
            };
        }
        function resumeH1(client) {
            const socket = client[kSocket];
            if (socket && !socket.destroyed) {
                if (0 === client[kSize]) {
                    if (!socket[kNoRef] && socket.unref) {
                        socket.unref();
                        socket[kNoRef] = true;
                    }
                } else if (socket[kNoRef] && socket.ref) {
                    socket.ref();
                    socket[kNoRef] = false;
                }
                if (0 === client[kSize]) {
                    if (socket[kParser].timeoutType !== TIMEOUT_KEEP_ALIVE) socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_KEEP_ALIVE);
                } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
                    if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
                        const request = client[kQueue][client[kRunningIdx]];
                        const headersTimeout = null != request.headersTimeout ? request.headersTimeout : client[kHeadersTimeout];
                        socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
                    }
                }
            }
        }
        function shouldSendContentLength(method) {
            return 'GET' !== method && 'HEAD' !== method && 'OPTIONS' !== method && 'TRACE' !== method && 'CONNECT' !== method;
        }
        function writeH1(client, request) {
            const { method, path, host, upgrade, blocking, reset } = request;
            let { body, headers, contentLength } = request;
            const expectsPayload = 'PUT' === method || 'POST' === method || 'PATCH' === method || 'QUERY' === method || 'PROPFIND' === method || 'PROPPATCH' === method;
            if (util.isFormDataLike(body)) {
                if (!extractBody) extractBody = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/body.js").extractBody;
                const [bodyStream, contentType] = extractBody(body);
                if (null == request.contentType) headers.push('content-type', contentType);
                body = bodyStream.stream;
                contentLength = bodyStream.length;
            } else if (util.isBlobLike(body) && null == request.contentType && body.type) headers.push('content-type', body.type);
            if (body && 'function' == typeof body.read) body.read(0);
            const bodyLength = util.bodyLength(body);
            contentLength = bodyLength ?? contentLength;
            if (null === contentLength) contentLength = request.contentLength;
            if (0 === contentLength && !expectsPayload) contentLength = null;
            if (shouldSendContentLength(method) && contentLength > 0 && null !== request.contentLength && request.contentLength !== contentLength) {
                if (client[kStrictContentLength]) {
                    util.errorRequest(client, request, new RequestContentLengthMismatchError());
                    return false;
                }
                process.emitWarning(new RequestContentLengthMismatchError());
            }
            const socket = client[kSocket];
            const abort = (err)=>{
                if (request.aborted || request.completed) return;
                util.errorRequest(client, request, err || new RequestAbortedError());
                util.destroy(body);
                util.destroy(socket, new InformationalError('aborted'));
            };
            try {
                request.onConnect(abort);
            } catch (err) {
                util.errorRequest(client, request, err);
            }
            if (request.aborted) return false;
            if ('HEAD' === method) socket[kReset] = true;
            if (upgrade || 'CONNECT' === method) socket[kReset] = true;
            if (null != reset) socket[kReset] = reset;
            if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) socket[kReset] = true;
            if (blocking) socket[kBlocking] = true;
            let header = `${method} ${path} HTTP/1.1\r\n`;
            if ('string' == typeof host) header += `host: ${host}\r\n`;
            else header += client[kHostHeader];
            if (upgrade) header += `connection: upgrade\r\nupgrade: ${upgrade}\r\n`;
            else if (client[kPipelining] && !socket[kReset]) header += 'connection: keep-alive\r\n';
            else header += 'connection: close\r\n';
            if (Array.isArray(headers)) for(let n = 0; n < headers.length; n += 2){
                const key = headers[n + 0];
                const val = headers[n + 1];
                if (Array.isArray(val)) for(let i = 0; i < val.length; i++)header += `${key}: ${val[i]}\r\n`;
                else header += `${key}: ${val}\r\n`;
            }
            if (channels.sendHeaders.hasSubscribers) channels.sendHeaders.publish({
                request,
                headers: header,
                socket
            });
            if (body && 0 !== bodyLength) if (util.isBuffer(body)) writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload);
            else if (util.isBlobLike(body)) if ('function' == typeof body.stream) writeIterable(abort, body.stream(), client, request, socket, contentLength, header, expectsPayload);
            else writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload);
            else if (util.isStream(body)) writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload);
            else if (util.isIterable(body)) writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload);
            else assert(false);
            else writeBuffer(abort, null, client, request, socket, contentLength, header, expectsPayload);
            return true;
        }
        function writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload) {
            assert(0 !== contentLength || 0 === client[kRunning], 'stream body cannot be pipelined');
            let finished = false;
            const writer = new AsyncWriter({
                abort,
                socket,
                request,
                contentLength,
                client,
                expectsPayload,
                header
            });
            const onData = function(chunk) {
                if (finished) return;
                try {
                    if (!writer.write(chunk) && this.pause) this.pause();
                } catch (err) {
                    util.destroy(this, err);
                }
            };
            const onDrain = function() {
                if (finished) return;
                if (body.resume) body.resume();
            };
            const onClose = function() {
                queueMicrotask(()=>{
                    body.removeListener('error', onFinished);
                });
                if (!finished) {
                    const err = new RequestAbortedError();
                    queueMicrotask(()=>onFinished(err));
                }
            };
            const onFinished = function(err) {
                if (finished) return;
                finished = true;
                assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
                socket.off('drain', onDrain).off('error', onFinished);
                body.removeListener('data', onData).removeListener('end', onFinished).removeListener('close', onClose);
                if (!err) try {
                    writer.end();
                } catch (er) {
                    err = er;
                }
                writer.destroy(err);
                if (err && ('UND_ERR_INFO' !== err.code || 'reset' !== err.message)) util.destroy(body, err);
                else util.destroy(body);
            };
            body.on('data', onData).on('end', onFinished).on('error', onFinished).on('close', onClose);
            if (body.resume) body.resume();
            socket.on('drain', onDrain).on('error', onFinished);
            if (body.errorEmitted ?? body.errored) setImmediate(()=>onFinished(body.errored));
            else if (body.endEmitted ?? body.readableEnded) setImmediate(()=>onFinished(null));
            if (body.closeEmitted ?? body.closed) setImmediate(onClose);
        }
        function writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload) {
            try {
                if (body) {
                    if (util.isBuffer(body)) {
                        assert(contentLength === body.byteLength, 'buffer body must have content length');
                        socket.cork();
                        socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'latin1');
                        socket.write(body);
                        socket.uncork();
                        request.onBodySent(body);
                        if (!expectsPayload && false !== request.reset) socket[kReset] = true;
                    }
                } else if (0 === contentLength) socket.write(`${header}content-length: 0\r\n\r\n`, 'latin1');
                else {
                    assert(null === contentLength, 'no body must not have content length');
                    socket.write(`${header}\r\n`, 'latin1');
                }
                request.onRequestSent();
                client[kResume]();
            } catch (err) {
                abort(err);
            }
        }
        async function writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload) {
            assert(contentLength === body.size, 'blob body must have content length');
            try {
                if (null != contentLength && contentLength !== body.size) throw new RequestContentLengthMismatchError();
                const buffer = Buffer.from(await body.arrayBuffer());
                socket.cork();
                socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'latin1');
                socket.write(buffer);
                socket.uncork();
                request.onBodySent(buffer);
                request.onRequestSent();
                if (!expectsPayload && false !== request.reset) socket[kReset] = true;
                client[kResume]();
            } catch (err) {
                abort(err);
            }
        }
        async function writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload) {
            assert(0 !== contentLength || 0 === client[kRunning], 'iterator body cannot be pipelined');
            let callback = null;
            function onDrain() {
                if (callback) {
                    const cb = callback;
                    callback = null;
                    cb();
                }
            }
            const waitForDrain = ()=>new Promise((resolve, reject)=>{
                    assert(null === callback);
                    if (socket[kError]) reject(socket[kError]);
                    else callback = resolve;
                });
            socket.on('close', onDrain).on('drain', onDrain);
            const writer = new AsyncWriter({
                abort,
                socket,
                request,
                contentLength,
                client,
                expectsPayload,
                header
            });
            try {
                for await (const chunk of body){
                    if (socket[kError]) throw socket[kError];
                    if (!writer.write(chunk)) await waitForDrain();
                }
                writer.end();
            } catch (err) {
                writer.destroy(err);
            } finally{
                socket.off('close', onDrain).off('drain', onDrain);
            }
        }
        class AsyncWriter {
            constructor({ abort, socket, request, contentLength, client, expectsPayload, header }){
                this.socket = socket;
                this.request = request;
                this.contentLength = contentLength;
                this.client = client;
                this.bytesWritten = 0;
                this.expectsPayload = expectsPayload;
                this.header = header;
                this.abort = abort;
                socket[kWriting] = true;
            }
            write(chunk) {
                const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
                if (socket[kError]) throw socket[kError];
                if (socket.destroyed) return false;
                const len = Buffer.byteLength(chunk);
                if (!len) return true;
                if (null !== contentLength && bytesWritten + len > contentLength) {
                    if (client[kStrictContentLength]) throw new RequestContentLengthMismatchError();
                    process.emitWarning(new RequestContentLengthMismatchError());
                }
                socket.cork();
                if (0 === bytesWritten) {
                    if (!expectsPayload && false !== request.reset) socket[kReset] = true;
                    if (null === contentLength) socket.write(`${header}transfer-encoding: chunked\r\n`, 'latin1');
                    else socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'latin1');
                }
                if (null === contentLength) socket.write(`\r\n${len.toString(16)}\r\n`, 'latin1');
                this.bytesWritten += len;
                const ret = socket.write(chunk);
                socket.uncork();
                request.onBodySent(chunk);
                if (!ret) {
                    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
                        if (socket[kParser].timeout.refresh) socket[kParser].timeout.refresh();
                    }
                }
                return ret;
            }
            end() {
                const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
                request.onRequestSent();
                socket[kWriting] = false;
                if (socket[kError]) throw socket[kError];
                if (socket.destroyed) return;
                if (0 === bytesWritten) if (expectsPayload) socket.write(`${header}content-length: 0\r\n\r\n`, 'latin1');
                else socket.write(`${header}\r\n`, 'latin1');
                else if (null === contentLength) socket.write('\r\n0\r\n\r\n', 'latin1');
                if (null !== contentLength && bytesWritten !== contentLength) if (client[kStrictContentLength]) throw new RequestContentLengthMismatchError();
                else process.emitWarning(new RequestContentLengthMismatchError());
                if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
                    if (socket[kParser].timeout.refresh) socket[kParser].timeout.refresh();
                }
                client[kResume]();
            }
            destroy(err) {
                const { socket, client, abort } = this;
                socket[kWriting] = false;
                if (err) {
                    assert(client[kRunning] <= 1, 'pipeline should only contain this request');
                    abort(err);
                }
            }
        }
        module.exports = connectH1;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/client-h2.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const assert = __webpack_require__("node:assert");
        const { pipeline } = __webpack_require__("node:stream");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { RequestContentLengthMismatchError, RequestAbortedError, SocketError, InformationalError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const { kUrl, kReset, kClient, kRunning, kPending, kQueue, kPendingIdx, kRunningIdx, kError, kSocket, kStrictContentLength, kOnError, kMaxConcurrentStreams, kHTTP2Session, kResume, kSize, kHTTPContext } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const kOpenStreams = Symbol('open streams');
        let extractBody;
        let h2ExperimentalWarned = false;
        let http2;
        try {
            http2 = __webpack_require__("node:http2");
        } catch  {
            http2 = {
                constants: {}
            };
        }
        const { constants: { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_SCHEME, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_EXPECT, HTTP2_HEADER_STATUS } } = http2;
        function parseH2Headers(headers) {
            const result = [];
            for (const [name, value] of Object.entries(headers))if (Array.isArray(value)) for (const subvalue of value)result.push(Buffer.from(name), Buffer.from(subvalue));
            else result.push(Buffer.from(name), Buffer.from(value));
            return result;
        }
        async function connectH2(client, socket) {
            client[kSocket] = socket;
            if (!h2ExperimentalWarned) {
                h2ExperimentalWarned = true;
                process.emitWarning('H2 support is experimental, expect them to change at any time.', {
                    code: 'UNDICI-H2'
                });
            }
            const session = http2.connect(client[kUrl], {
                createConnection: ()=>socket,
                peerMaxConcurrentStreams: client[kMaxConcurrentStreams]
            });
            session[kOpenStreams] = 0;
            session[kClient] = client;
            session[kSocket] = socket;
            util.addListener(session, 'error', onHttp2SessionError);
            util.addListener(session, 'frameError', onHttp2FrameError);
            util.addListener(session, 'end', onHttp2SessionEnd);
            util.addListener(session, 'goaway', onHTTP2GoAway);
            util.addListener(session, 'close', function() {
                const { [kClient]: client } = this;
                const { [kSocket]: socket } = client;
                const err = this[kSocket][kError] || this[kError] || new SocketError('closed', util.getSocketInfo(socket));
                client[kHTTP2Session] = null;
                if (client.destroyed) {
                    assert(0 === client[kPending]);
                    const requests = client[kQueue].splice(client[kRunningIdx]);
                    for(let i = 0; i < requests.length; i++){
                        const request = requests[i];
                        util.errorRequest(client, request, err);
                    }
                }
            });
            session.unref();
            client[kHTTP2Session] = session;
            socket[kHTTP2Session] = session;
            util.addListener(socket, 'error', function(err) {
                assert('ERR_TLS_CERT_ALTNAME_INVALID' !== err.code);
                this[kError] = err;
                this[kClient][kOnError](err);
            });
            util.addListener(socket, 'end', function() {
                util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)));
            });
            util.addListener(socket, 'close', function() {
                const err = this[kError] || new SocketError('closed', util.getSocketInfo(this));
                client[kSocket] = null;
                if (null != this[kHTTP2Session]) this[kHTTP2Session].destroy(err);
                client[kPendingIdx] = client[kRunningIdx];
                assert(0 === client[kRunning]);
                client.emit('disconnect', client[kUrl], [
                    client
                ], err);
                client[kResume]();
            });
            let closed = false;
            socket.on('close', ()=>{
                closed = true;
            });
            return {
                version: 'h2',
                defaultPipelining: 1 / 0,
                write (...args) {
                    return writeH2(client, ...args);
                },
                resume () {
                    resumeH2(client);
                },
                destroy (err, callback) {
                    if (closed) queueMicrotask(callback);
                    else socket.destroy(err).on('close', callback);
                },
                get destroyed () {
                    return socket.destroyed;
                },
                busy () {
                    return false;
                }
            };
        }
        function resumeH2(client) {
            const socket = client[kSocket];
            if (socket?.destroyed === false) if (0 === client[kSize] && 0 === client[kMaxConcurrentStreams]) {
                socket.unref();
                client[kHTTP2Session].unref();
            } else {
                socket.ref();
                client[kHTTP2Session].ref();
            }
        }
        function onHttp2SessionError(err) {
            assert('ERR_TLS_CERT_ALTNAME_INVALID' !== err.code);
            this[kSocket][kError] = err;
            this[kClient][kOnError](err);
        }
        function onHttp2FrameError(type, code, id) {
            if (0 === id) {
                const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
                this[kSocket][kError] = err;
                this[kClient][kOnError](err);
            }
        }
        function onHttp2SessionEnd() {
            const err = new SocketError('other side closed', util.getSocketInfo(this[kSocket]));
            this.destroy(err);
            util.destroy(this[kSocket], err);
        }
        function onHTTP2GoAway(code) {
            const err = this[kError] || new SocketError(`HTTP/2: "GOAWAY" frame received with code ${code}`, util.getSocketInfo(this));
            const client = this[kClient];
            client[kSocket] = null;
            client[kHTTPContext] = null;
            if (null != this[kHTTP2Session]) {
                this[kHTTP2Session].destroy(err);
                this[kHTTP2Session] = null;
            }
            util.destroy(this[kSocket], err);
            if (client[kRunningIdx] < client[kQueue].length) {
                const request = client[kQueue][client[kRunningIdx]];
                client[kQueue][client[kRunningIdx]++] = null;
                util.errorRequest(client, request, err);
                client[kPendingIdx] = client[kRunningIdx];
            }
            assert(0 === client[kRunning]);
            client.emit('disconnect', client[kUrl], [
                client
            ], err);
            client[kResume]();
        }
        function shouldSendContentLength(method) {
            return 'GET' !== method && 'HEAD' !== method && 'OPTIONS' !== method && 'TRACE' !== method && 'CONNECT' !== method;
        }
        function writeH2(client, request) {
            const session = client[kHTTP2Session];
            const { method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
            let { body } = request;
            if (upgrade) {
                util.errorRequest(client, request, new Error('Upgrade not supported for H2'));
                return false;
            }
            const headers = {};
            for(let n = 0; n < reqHeaders.length; n += 2){
                const key = reqHeaders[n + 0];
                const val = reqHeaders[n + 1];
                if (Array.isArray(val)) for(let i = 0; i < val.length; i++)if (headers[key]) headers[key] += `,${val[i]}`;
                else headers[key] = val[i];
                else headers[key] = val;
            }
            let stream;
            const { hostname, port } = client[kUrl];
            headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ''}`;
            headers[HTTP2_HEADER_METHOD] = method;
            const abort = (err)=>{
                if (request.aborted || request.completed) return;
                err = err || new RequestAbortedError();
                util.errorRequest(client, request, err);
                if (null != stream) util.destroy(stream, err);
                util.destroy(body, err);
                client[kQueue][client[kRunningIdx]++] = null;
                client[kResume]();
            };
            try {
                request.onConnect(abort);
            } catch (err) {
                util.errorRequest(client, request, err);
            }
            if (request.aborted) return false;
            if ('CONNECT' === method) {
                session.ref();
                stream = session.request(headers, {
                    endStream: false,
                    signal
                });
                if (stream.id && !stream.pending) {
                    request.onUpgrade(null, null, stream);
                    ++session[kOpenStreams];
                    client[kQueue][client[kRunningIdx]++] = null;
                } else stream.once('ready', ()=>{
                    request.onUpgrade(null, null, stream);
                    ++session[kOpenStreams];
                    client[kQueue][client[kRunningIdx]++] = null;
                });
                stream.once('close', ()=>{
                    session[kOpenStreams] -= 1;
                    if (0 === session[kOpenStreams]) session.unref();
                });
                return true;
            }
            headers[HTTP2_HEADER_PATH] = path;
            headers[HTTP2_HEADER_SCHEME] = 'https';
            const expectsPayload = 'PUT' === method || 'POST' === method || 'PATCH' === method;
            if (body && 'function' == typeof body.read) body.read(0);
            let contentLength = util.bodyLength(body);
            if (util.isFormDataLike(body)) {
                extractBody ??= __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/body.js").extractBody;
                const [bodyStream, contentType] = extractBody(body);
                headers['content-type'] = contentType;
                body = bodyStream.stream;
                contentLength = bodyStream.length;
            }
            if (null == contentLength) contentLength = request.contentLength;
            if (0 === contentLength || !expectsPayload) contentLength = null;
            if (shouldSendContentLength(method) && contentLength > 0 && null != request.contentLength && request.contentLength !== contentLength) {
                if (client[kStrictContentLength]) {
                    util.errorRequest(client, request, new RequestContentLengthMismatchError());
                    return false;
                }
                process.emitWarning(new RequestContentLengthMismatchError());
            }
            if (null != contentLength) {
                assert(body, 'no body must not have content length');
                headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
            }
            session.ref();
            const shouldEndStream = 'GET' === method || 'HEAD' === method || null === body;
            if (expectContinue) {
                headers[HTTP2_HEADER_EXPECT] = '100-continue';
                stream = session.request(headers, {
                    endStream: shouldEndStream,
                    signal
                });
                stream.once('continue', writeBodyH2);
            } else {
                stream = session.request(headers, {
                    endStream: shouldEndStream,
                    signal
                });
                writeBodyH2();
            }
            ++session[kOpenStreams];
            stream.once('response', (headers)=>{
                const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers;
                request.onResponseStarted();
                if (request.aborted) {
                    const err = new RequestAbortedError();
                    util.errorRequest(client, request, err);
                    util.destroy(stream, err);
                    return;
                }
                if (false === request.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), '')) stream.pause();
                stream.on('data', (chunk)=>{
                    if (false === request.onData(chunk)) stream.pause();
                });
            });
            stream.once('end', ()=>{
                if (stream.state?.state == null || stream.state.state < 6) request.onComplete([]);
                if (0 === session[kOpenStreams]) session.unref();
                abort(new InformationalError('HTTP/2: stream half-closed (remote)'));
                client[kQueue][client[kRunningIdx]++] = null;
                client[kPendingIdx] = client[kRunningIdx];
                client[kResume]();
            });
            stream.once('close', ()=>{
                session[kOpenStreams] -= 1;
                if (0 === session[kOpenStreams]) session.unref();
            });
            stream.once('error', function(err) {
                abort(err);
            });
            stream.once('frameError', (type, code)=>{
                abort(new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`));
            });
            return true;
            function writeBodyH2() {
                if (body && 0 !== contentLength) if (util.isBuffer(body)) writeBuffer(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);
                else if (util.isBlobLike(body)) if ('function' == typeof body.stream) writeIterable(abort, stream, body.stream(), client, request, client[kSocket], contentLength, expectsPayload);
                else writeBlob(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);
                else if (util.isStream(body)) writeStream(abort, client[kSocket], expectsPayload, stream, body, client, request, contentLength);
                else if (util.isIterable(body)) writeIterable(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);
                else assert(false);
                else writeBuffer(abort, stream, null, client, request, client[kSocket], contentLength, expectsPayload);
            }
        }
        function writeBuffer(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
            try {
                if (null != body && util.isBuffer(body)) {
                    assert(contentLength === body.byteLength, 'buffer body must have content length');
                    h2stream.cork();
                    h2stream.write(body);
                    h2stream.uncork();
                    h2stream.end();
                    request.onBodySent(body);
                }
                if (!expectsPayload) socket[kReset] = true;
                request.onRequestSent();
                client[kResume]();
            } catch (error) {
                abort(error);
            }
        }
        function writeStream(abort, socket, expectsPayload, h2stream, body, client, request, contentLength) {
            assert(0 !== contentLength || 0 === client[kRunning], 'stream body cannot be pipelined');
            const pipe = pipeline(body, h2stream, (err)=>{
                if (err) {
                    util.destroy(pipe, err);
                    abort(err);
                } else {
                    util.removeAllListeners(pipe);
                    request.onRequestSent();
                    if (!expectsPayload) socket[kReset] = true;
                    client[kResume]();
                }
            });
            util.addListener(pipe, 'data', onPipeData);
            function onPipeData(chunk) {
                request.onBodySent(chunk);
            }
        }
        async function writeBlob(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
            assert(contentLength === body.size, 'blob body must have content length');
            try {
                if (null != contentLength && contentLength !== body.size) throw new RequestContentLengthMismatchError();
                const buffer = Buffer.from(await body.arrayBuffer());
                h2stream.cork();
                h2stream.write(buffer);
                h2stream.uncork();
                h2stream.end();
                request.onBodySent(buffer);
                request.onRequestSent();
                if (!expectsPayload) socket[kReset] = true;
                client[kResume]();
            } catch (err) {
                abort(err);
            }
        }
        async function writeIterable(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
            assert(0 !== contentLength || 0 === client[kRunning], 'iterator body cannot be pipelined');
            let callback = null;
            function onDrain() {
                if (callback) {
                    const cb = callback;
                    callback = null;
                    cb();
                }
            }
            const waitForDrain = ()=>new Promise((resolve, reject)=>{
                    assert(null === callback);
                    if (socket[kError]) reject(socket[kError]);
                    else callback = resolve;
                });
            h2stream.on('close', onDrain).on('drain', onDrain);
            try {
                for await (const chunk of body){
                    if (socket[kError]) throw socket[kError];
                    const res = h2stream.write(chunk);
                    request.onBodySent(chunk);
                    if (!res) await waitForDrain();
                }
                h2stream.end();
                request.onRequestSent();
                if (!expectsPayload) socket[kReset] = true;
                client[kResume]();
            } catch (err) {
                abort(err);
            } finally{
                h2stream.off('close', onDrain).off('drain', onDrain);
            }
        }
        module.exports = connectH2;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/client.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const assert = __webpack_require__("node:assert");
        const net = __webpack_require__("node:net");
        const http = __webpack_require__("node:http");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { channels } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/diagnostics.js");
        const Request = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/request.js");
        const DispatcherBase = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/dispatcher-base.js");
        const { InvalidArgumentError, InformationalError, ClientDestroyedError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const buildConnector = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/connect.js");
        const { kUrl, kServerName, kClient, kBusy, kConnect, kResuming, kRunning, kPending, kSize, kQueue, kConnected, kConnecting, kNeedDrain, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError, kPipelining, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kConnector, kMaxRedirections, kMaxRequests, kCounter, kClose, kDestroy, kDispatch, kInterceptors, kLocalAddress, kMaxResponseSize, kOnError, kHTTPContext, kMaxConcurrentStreams, kResume } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const connectH1 = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/client-h1.js");
        const connectH2 = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/client-h2.js");
        let deprecatedInterceptorWarned = false;
        const kClosedResolve = Symbol('kClosedResolve');
        const noop = ()=>{};
        function getPipelining(client) {
            return client[kPipelining] ?? client[kHTTPContext]?.defaultPipelining ?? 1;
        }
        class Client extends DispatcherBase {
            constructor(url, { interceptors, maxHeaderSize, headersTimeout, socketTimeout, requestTimeout, connectTimeout, bodyTimeout, idleTimeout, keepAlive, keepAliveTimeout, maxKeepAliveTimeout, keepAliveMaxTimeout, keepAliveTimeoutThreshold, socketPath, pipelining, tls, strictContentLength, maxCachedSessions, maxRedirections, connect, maxRequestsPerClient, localAddress, maxResponseSize, autoSelectFamily, autoSelectFamilyAttemptTimeout, maxConcurrentStreams, allowH2 } = {}){
                super();
                if (void 0 !== keepAlive) throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead');
                if (void 0 !== socketTimeout) throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead');
                if (void 0 !== requestTimeout) throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead');
                if (void 0 !== idleTimeout) throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead');
                if (void 0 !== maxKeepAliveTimeout) throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead');
                if (null != maxHeaderSize && !Number.isFinite(maxHeaderSize)) throw new InvalidArgumentError('invalid maxHeaderSize');
                if (null != socketPath && 'string' != typeof socketPath) throw new InvalidArgumentError('invalid socketPath');
                if (null != connectTimeout && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) throw new InvalidArgumentError('invalid connectTimeout');
                if (null != keepAliveTimeout && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) throw new InvalidArgumentError('invalid keepAliveTimeout');
                if (null != keepAliveMaxTimeout && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) throw new InvalidArgumentError('invalid keepAliveMaxTimeout');
                if (null != keepAliveTimeoutThreshold && !Number.isFinite(keepAliveTimeoutThreshold)) throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold');
                if (null != headersTimeout && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) throw new InvalidArgumentError('headersTimeout must be a positive integer or zero');
                if (null != bodyTimeout && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero');
                if (null != connect && 'function' != typeof connect && 'object' != typeof connect) throw new InvalidArgumentError('connect must be a function or an object');
                if (null != maxRedirections && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new InvalidArgumentError('maxRedirections must be a positive number');
                if (null != maxRequestsPerClient && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) throw new InvalidArgumentError('maxRequestsPerClient must be a positive number');
                if (null != localAddress && ('string' != typeof localAddress || 0 === net.isIP(localAddress))) throw new InvalidArgumentError('localAddress must be valid string IP address');
                if (null != maxResponseSize && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) throw new InvalidArgumentError('maxResponseSize must be a positive number');
                if (null != autoSelectFamilyAttemptTimeout && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number');
                if (null != allowH2 && 'boolean' != typeof allowH2) throw new InvalidArgumentError('allowH2 must be a valid boolean value');
                if (null != maxConcurrentStreams && ('number' != typeof maxConcurrentStreams || maxConcurrentStreams < 1)) throw new InvalidArgumentError('maxConcurrentStreams must be a positive integer, greater than 0');
                if ('function' != typeof connect) connect = buildConnector({
                    ...tls,
                    maxCachedSessions,
                    allowH2,
                    socketPath,
                    timeout: connectTimeout,
                    ...autoSelectFamily ? {
                        autoSelectFamily,
                        autoSelectFamilyAttemptTimeout
                    } : void 0,
                    ...connect
                });
                if (interceptors?.Client && Array.isArray(interceptors.Client)) {
                    this[kInterceptors] = interceptors.Client;
                    if (!deprecatedInterceptorWarned) {
                        deprecatedInterceptorWarned = true;
                        process.emitWarning('Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.', {
                            code: 'UNDICI-CLIENT-INTERCEPTOR-DEPRECATED'
                        });
                    }
                } else this[kInterceptors] = [
                    createRedirectInterceptor({
                        maxRedirections
                    })
                ];
                this[kUrl] = util.parseOrigin(url);
                this[kConnector] = connect;
                this[kPipelining] = null != pipelining ? pipelining : 1;
                this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
                this[kKeepAliveDefaultTimeout] = null == keepAliveTimeout ? 4e3 : keepAliveTimeout;
                this[kKeepAliveMaxTimeout] = null == keepAliveMaxTimeout ? 600e3 : keepAliveMaxTimeout;
                this[kKeepAliveTimeoutThreshold] = null == keepAliveTimeoutThreshold ? 2e3 : keepAliveTimeoutThreshold;
                this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
                this[kServerName] = null;
                this[kLocalAddress] = null != localAddress ? localAddress : null;
                this[kResuming] = 0;
                this[kNeedDrain] = 0;
                this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\r\n`;
                this[kBodyTimeout] = null != bodyTimeout ? bodyTimeout : 300e3;
                this[kHeadersTimeout] = null != headersTimeout ? headersTimeout : 300e3;
                this[kStrictContentLength] = null == strictContentLength ? true : strictContentLength;
                this[kMaxRedirections] = maxRedirections;
                this[kMaxRequests] = maxRequestsPerClient;
                this[kClosedResolve] = null;
                this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
                this[kMaxConcurrentStreams] = null != maxConcurrentStreams ? maxConcurrentStreams : 100;
                this[kHTTPContext] = null;
                this[kQueue] = [];
                this[kRunningIdx] = 0;
                this[kPendingIdx] = 0;
                this[kResume] = (sync)=>resume(this, sync);
                this[kOnError] = (err)=>onError(this, err);
            }
            get pipelining() {
                return this[kPipelining];
            }
            set pipelining(value) {
                this[kPipelining] = value;
                this[kResume](true);
            }
            get [kPending]() {
                return this[kQueue].length - this[kPendingIdx];
            }
            get [kRunning]() {
                return this[kPendingIdx] - this[kRunningIdx];
            }
            get [kSize]() {
                return this[kQueue].length - this[kRunningIdx];
            }
            get [kConnected]() {
                return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;
            }
            get [kBusy]() {
                return Boolean(this[kHTTPContext]?.busy(null) || this[kSize] >= (getPipelining(this) || 1) || this[kPending] > 0);
            }
            [kConnect](cb) {
                connect(this);
                this.once('connect', cb);
            }
            [kDispatch](opts, handler) {
                const origin = opts.origin || this[kUrl].origin;
                const request = new Request(origin, opts, handler);
                this[kQueue].push(request);
                if (this[kResuming]) ;
                else if (null == util.bodyLength(request.body) && util.isIterable(request.body)) {
                    this[kResuming] = 1;
                    queueMicrotask(()=>resume(this));
                } else this[kResume](true);
                if (this[kResuming] && 2 !== this[kNeedDrain] && this[kBusy]) this[kNeedDrain] = 2;
                return this[kNeedDrain] < 2;
            }
            async [kClose]() {
                return new Promise((resolve)=>{
                    if (this[kSize]) this[kClosedResolve] = resolve;
                    else resolve(null);
                });
            }
            async [kDestroy](err) {
                return new Promise((resolve)=>{
                    const requests = this[kQueue].splice(this[kPendingIdx]);
                    for(let i = 0; i < requests.length; i++){
                        const request = requests[i];
                        util.errorRequest(this, request, err);
                    }
                    const callback = ()=>{
                        if (this[kClosedResolve]) {
                            this[kClosedResolve]();
                            this[kClosedResolve] = null;
                        }
                        resolve(null);
                    };
                    if (this[kHTTPContext]) {
                        this[kHTTPContext].destroy(err, callback);
                        this[kHTTPContext] = null;
                    } else queueMicrotask(callback);
                    this[kResume]();
                });
            }
        }
        const createRedirectInterceptor = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/interceptor/redirect-interceptor.js");
        function onError(client, err) {
            if (0 === client[kRunning] && 'UND_ERR_INFO' !== err.code && 'UND_ERR_SOCKET' !== err.code) {
                assert(client[kPendingIdx] === client[kRunningIdx]);
                const requests = client[kQueue].splice(client[kRunningIdx]);
                for(let i = 0; i < requests.length; i++){
                    const request = requests[i];
                    util.errorRequest(client, request, err);
                }
                assert(0 === client[kSize]);
            }
        }
        async function connect(client) {
            assert(!client[kConnecting]);
            assert(!client[kHTTPContext]);
            let { host, hostname, protocol, port } = client[kUrl];
            if ('[' === hostname[0]) {
                const idx = hostname.indexOf(']');
                assert(-1 !== idx);
                const ip = hostname.substring(1, idx);
                assert(net.isIP(ip));
                hostname = ip;
            }
            client[kConnecting] = true;
            if (channels.beforeConnect.hasSubscribers) channels.beforeConnect.publish({
                connectParams: {
                    host,
                    hostname,
                    protocol,
                    port,
                    version: client[kHTTPContext]?.version,
                    servername: client[kServerName],
                    localAddress: client[kLocalAddress]
                },
                connector: client[kConnector]
            });
            try {
                const socket = await new Promise((resolve, reject)=>{
                    client[kConnector]({
                        host,
                        hostname,
                        protocol,
                        port,
                        servername: client[kServerName],
                        localAddress: client[kLocalAddress]
                    }, (err, socket)=>{
                        if (err) reject(err);
                        else resolve(socket);
                    });
                });
                if (client.destroyed) return void util.destroy(socket.on('error', noop), new ClientDestroyedError());
                assert(socket);
                try {
                    client[kHTTPContext] = 'h2' === socket.alpnProtocol ? await connectH2(client, socket) : await connectH1(client, socket);
                } catch (err) {
                    socket.destroy().on('error', noop);
                    throw err;
                }
                client[kConnecting] = false;
                socket[kCounter] = 0;
                socket[kMaxRequests] = client[kMaxRequests];
                socket[kClient] = client;
                socket[kError] = null;
                if (channels.connected.hasSubscribers) channels.connected.publish({
                    connectParams: {
                        host,
                        hostname,
                        protocol,
                        port,
                        version: client[kHTTPContext]?.version,
                        servername: client[kServerName],
                        localAddress: client[kLocalAddress]
                    },
                    connector: client[kConnector],
                    socket
                });
                client.emit('connect', client[kUrl], [
                    client
                ]);
            } catch (err) {
                if (client.destroyed) return;
                client[kConnecting] = false;
                if (channels.connectError.hasSubscribers) channels.connectError.publish({
                    connectParams: {
                        host,
                        hostname,
                        protocol,
                        port,
                        version: client[kHTTPContext]?.version,
                        servername: client[kServerName],
                        localAddress: client[kLocalAddress]
                    },
                    connector: client[kConnector],
                    error: err
                });
                if ('ERR_TLS_CERT_ALTNAME_INVALID' === err.code) {
                    assert(0 === client[kRunning]);
                    while(client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]){
                        const request = client[kQueue][client[kPendingIdx]++];
                        util.errorRequest(client, request, err);
                    }
                } else onError(client, err);
                client.emit('connectionError', client[kUrl], [
                    client
                ], err);
            }
            client[kResume]();
        }
        function emitDrain(client) {
            client[kNeedDrain] = 0;
            client.emit('drain', client[kUrl], [
                client
            ]);
        }
        function resume(client, sync) {
            if (2 === client[kResuming]) return;
            client[kResuming] = 2;
            _resume(client, sync);
            client[kResuming] = 0;
            if (client[kRunningIdx] > 256) {
                client[kQueue].splice(0, client[kRunningIdx]);
                client[kPendingIdx] -= client[kRunningIdx];
                client[kRunningIdx] = 0;
            }
        }
        function _resume(client, sync) {
            while(true){
                if (client.destroyed) return void assert(0 === client[kPending]);
                if (client[kClosedResolve] && !client[kSize]) {
                    client[kClosedResolve]();
                    client[kClosedResolve] = null;
                    return;
                }
                if (client[kHTTPContext]) client[kHTTPContext].resume();
                if (client[kBusy]) client[kNeedDrain] = 2;
                else if (2 === client[kNeedDrain]) {
                    if (sync) {
                        client[kNeedDrain] = 1;
                        queueMicrotask(()=>emitDrain(client));
                    } else emitDrain(client);
                    continue;
                }
                if (0 === client[kPending]) return;
                if (client[kRunning] >= (getPipelining(client) || 1)) return;
                const request = client[kQueue][client[kPendingIdx]];
                if ('https:' === client[kUrl].protocol && client[kServerName] !== request.servername) {
                    if (client[kRunning] > 0) return;
                    client[kServerName] = request.servername;
                    client[kHTTPContext]?.destroy(new InformationalError('servername changed'), ()=>{
                        client[kHTTPContext] = null;
                        resume(client);
                    });
                }
                if (client[kConnecting]) return;
                if (!client[kHTTPContext]) return void connect(client);
                if (client[kHTTPContext].destroyed) return;
                if (client[kHTTPContext].busy(request)) return;
                if (!request.aborted && client[kHTTPContext].write(request)) client[kPendingIdx]++;
                else client[kQueue].splice(client[kPendingIdx], 1);
            }
        }
        module.exports = Client;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/dispatcher-base.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const Dispatcher = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/dispatcher.js");
        const { ClientDestroyedError, ClientClosedError, InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const { kDestroy, kClose, kClosed, kDestroyed, kDispatch, kInterceptors } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const kOnDestroyed = Symbol('onDestroyed');
        const kOnClosed = Symbol('onClosed');
        const kInterceptedDispatch = Symbol('Intercepted Dispatch');
        class DispatcherBase extends Dispatcher {
            constructor(){
                super();
                this[kDestroyed] = false;
                this[kOnDestroyed] = null;
                this[kClosed] = false;
                this[kOnClosed] = [];
            }
            get destroyed() {
                return this[kDestroyed];
            }
            get closed() {
                return this[kClosed];
            }
            get interceptors() {
                return this[kInterceptors];
            }
            set interceptors(newInterceptors) {
                if (newInterceptors) for(let i = newInterceptors.length - 1; i >= 0; i--){
                    const interceptor = this[kInterceptors][i];
                    if ('function' != typeof interceptor) throw new InvalidArgumentError('interceptor must be an function');
                }
                this[kInterceptors] = newInterceptors;
            }
            close(callback) {
                if (void 0 === callback) return new Promise((resolve, reject)=>{
                    this.close((err, data)=>err ? reject(err) : resolve(data));
                });
                if ('function' != typeof callback) throw new InvalidArgumentError('invalid callback');
                if (this[kDestroyed]) return void queueMicrotask(()=>callback(new ClientDestroyedError(), null));
                if (this[kClosed]) {
                    if (this[kOnClosed]) this[kOnClosed].push(callback);
                    else queueMicrotask(()=>callback(null, null));
                    return;
                }
                this[kClosed] = true;
                this[kOnClosed].push(callback);
                const onClosed = ()=>{
                    const callbacks = this[kOnClosed];
                    this[kOnClosed] = null;
                    for(let i = 0; i < callbacks.length; i++)callbacks[i](null, null);
                };
                this[kClose]().then(()=>this.destroy()).then(()=>{
                    queueMicrotask(onClosed);
                });
            }
            destroy(err, callback) {
                if ('function' == typeof err) {
                    callback = err;
                    err = null;
                }
                if (void 0 === callback) return new Promise((resolve, reject)=>{
                    this.destroy(err, (err, data)=>err ? reject(err) : resolve(data));
                });
                if ('function' != typeof callback) throw new InvalidArgumentError('invalid callback');
                if (this[kDestroyed]) {
                    if (this[kOnDestroyed]) this[kOnDestroyed].push(callback);
                    else queueMicrotask(()=>callback(null, null));
                    return;
                }
                if (!err) err = new ClientDestroyedError();
                this[kDestroyed] = true;
                this[kOnDestroyed] = this[kOnDestroyed] || [];
                this[kOnDestroyed].push(callback);
                const onDestroyed = ()=>{
                    const callbacks = this[kOnDestroyed];
                    this[kOnDestroyed] = null;
                    for(let i = 0; i < callbacks.length; i++)callbacks[i](null, null);
                };
                this[kDestroy](err).then(()=>{
                    queueMicrotask(onDestroyed);
                });
            }
            [kInterceptedDispatch](opts, handler) {
                if (!this[kInterceptors] || 0 === this[kInterceptors].length) {
                    this[kInterceptedDispatch] = this[kDispatch];
                    return this[kDispatch](opts, handler);
                }
                let dispatch = this[kDispatch].bind(this);
                for(let i = this[kInterceptors].length - 1; i >= 0; i--)dispatch = this[kInterceptors][i](dispatch);
                this[kInterceptedDispatch] = dispatch;
                return dispatch(opts, handler);
            }
            dispatch(opts, handler) {
                if (!handler || 'object' != typeof handler) throw new InvalidArgumentError('handler must be an object');
                try {
                    if (!opts || 'object' != typeof opts) throw new InvalidArgumentError('opts must be an object.');
                    if (this[kDestroyed] || this[kOnDestroyed]) throw new ClientDestroyedError();
                    if (this[kClosed]) throw new ClientClosedError();
                    return this[kInterceptedDispatch](opts, handler);
                } catch (err) {
                    if ('function' != typeof handler.onError) throw new InvalidArgumentError('invalid onError method');
                    handler.onError(err);
                    return false;
                }
            }
        }
        module.exports = DispatcherBase;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/dispatcher.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const EventEmitter = __webpack_require__("node:events");
        class Dispatcher extends EventEmitter {
            dispatch() {
                throw new Error('not implemented');
            }
            close() {
                throw new Error('not implemented');
            }
            destroy() {
                throw new Error('not implemented');
            }
            compose(...args) {
                const interceptors = Array.isArray(args[0]) ? args[0] : args;
                let dispatch = this.dispatch.bind(this);
                for (const interceptor of interceptors)if (null != interceptor) {
                    if ('function' != typeof interceptor) throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`);
                    dispatch = interceptor(dispatch);
                    if (null == dispatch || 'function' != typeof dispatch || 2 !== dispatch.length) throw new TypeError('invalid interceptor');
                }
                return new ComposedDispatcher(this, dispatch);
            }
        }
        class ComposedDispatcher extends Dispatcher {
            #dispatcher = null;
            #dispatch = null;
            constructor(dispatcher, dispatch){
                super();
                this.#dispatcher = dispatcher;
                this.#dispatch = dispatch;
            }
            dispatch(...args) {
                this.#dispatch(...args);
            }
            close(...args) {
                return this.#dispatcher.close(...args);
            }
            destroy(...args) {
                return this.#dispatcher.destroy(...args);
            }
        }
        module.exports = Dispatcher;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/env-http-proxy-agent.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const DispatcherBase = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/dispatcher-base.js");
        const { kClose, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const ProxyAgent = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/proxy-agent.js");
        const Agent = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/agent.js");
        const DEFAULT_PORTS = {
            'http:': 80,
            'https:': 443
        };
        let experimentalWarned = false;
        class EnvHttpProxyAgent extends DispatcherBase {
            #noProxyValue = null;
            #noProxyEntries = null;
            #opts = null;
            constructor(opts = {}){
                super();
                this.#opts = opts;
                if (!experimentalWarned) {
                    experimentalWarned = true;
                    process.emitWarning('EnvHttpProxyAgent is experimental, expect them to change at any time.', {
                        code: 'UNDICI-EHPA'
                    });
                }
                const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts;
                this[kNoProxyAgent] = new Agent(agentOpts);
                const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY;
                if (HTTP_PROXY) this[kHttpProxyAgent] = new ProxyAgent({
                    ...agentOpts,
                    uri: HTTP_PROXY
                });
                else this[kHttpProxyAgent] = this[kNoProxyAgent];
                const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;
                if (HTTPS_PROXY) this[kHttpsProxyAgent] = new ProxyAgent({
                    ...agentOpts,
                    uri: HTTPS_PROXY
                });
                else this[kHttpsProxyAgent] = this[kHttpProxyAgent];
                this.#parseNoProxy();
            }
            [kDispatch](opts, handler) {
                const url = new URL(opts.origin);
                const agent = this.#getProxyAgentForUrl(url);
                return agent.dispatch(opts, handler);
            }
            async [kClose]() {
                await this[kNoProxyAgent].close();
                if (!this[kHttpProxyAgent][kClosed]) await this[kHttpProxyAgent].close();
                if (!this[kHttpsProxyAgent][kClosed]) await this[kHttpsProxyAgent].close();
            }
            async [kDestroy](err) {
                await this[kNoProxyAgent].destroy(err);
                if (!this[kHttpProxyAgent][kDestroyed]) await this[kHttpProxyAgent].destroy(err);
                if (!this[kHttpsProxyAgent][kDestroyed]) await this[kHttpsProxyAgent].destroy(err);
            }
            #getProxyAgentForUrl(url) {
                let { protocol, host: hostname, port } = url;
                hostname = hostname.replace(/:\d*$/, '').toLowerCase();
                port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0;
                if (!this.#shouldProxy(hostname, port)) return this[kNoProxyAgent];
                if ('https:' === protocol) return this[kHttpsProxyAgent];
                return this[kHttpProxyAgent];
            }
            #shouldProxy(hostname, port) {
                if (this.#noProxyChanged) this.#parseNoProxy();
                if (0 === this.#noProxyEntries.length) return true;
                if ('*' === this.#noProxyValue) return false;
                for(let i = 0; i < this.#noProxyEntries.length; i++){
                    const entry = this.#noProxyEntries[i];
                    if (!entry.port || entry.port === port) {
                        if (/^[.*]/.test(entry.hostname)) {
                            if (hostname.endsWith(entry.hostname.replace(/^\*/, ''))) return false;
                        } else if (hostname === entry.hostname) return false;
                    }
                }
                return true;
            }
            #parseNoProxy() {
                const noProxyValue = this.#opts.noProxy ?? this.#noProxyEnv;
                const noProxySplit = noProxyValue.split(/[,\s]/);
                const noProxyEntries = [];
                for(let i = 0; i < noProxySplit.length; i++){
                    const entry = noProxySplit[i];
                    if (!entry) continue;
                    const parsed = entry.match(/^(.+):(\d+)$/);
                    noProxyEntries.push({
                        hostname: (parsed ? parsed[1] : entry).toLowerCase(),
                        port: parsed ? Number.parseInt(parsed[2], 10) : 0
                    });
                }
                this.#noProxyValue = noProxyValue;
                this.#noProxyEntries = noProxyEntries;
            }
            get #noProxyChanged() {
                if (void 0 !== this.#opts.noProxy) return false;
                return this.#noProxyValue !== this.#noProxyEnv;
            }
            get #noProxyEnv() {
                return process.env.no_proxy ?? process.env.NO_PROXY ?? '';
            }
        }
        module.exports = EnvHttpProxyAgent;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/fixed-queue.js" (module) {
        "use strict";
        const kSize = 2048;
        const kMask = kSize - 1;
        class FixedCircularBuffer {
            constructor(){
                this.bottom = 0;
                this.top = 0;
                this.list = new Array(kSize);
                this.next = null;
            }
            isEmpty() {
                return this.top === this.bottom;
            }
            isFull() {
                return (this.top + 1 & kMask) === this.bottom;
            }
            push(data) {
                this.list[this.top] = data;
                this.top = this.top + 1 & kMask;
            }
            shift() {
                const nextItem = this.list[this.bottom];
                if (void 0 === nextItem) return null;
                this.list[this.bottom] = void 0;
                this.bottom = this.bottom + 1 & kMask;
                return nextItem;
            }
        }
        module.exports = class {
            constructor(){
                this.head = this.tail = new FixedCircularBuffer();
            }
            isEmpty() {
                return this.head.isEmpty();
            }
            push(data) {
                if (this.head.isFull()) this.head = this.head.next = new FixedCircularBuffer();
                this.head.push(data);
            }
            shift() {
                const tail = this.tail;
                const next = tail.shift();
                if (tail.isEmpty() && null !== tail.next) this.tail = tail.next;
                return next;
            }
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/pool-base.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const DispatcherBase = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/dispatcher-base.js");
        const FixedQueue = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/fixed-queue.js");
        const { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const PoolStats = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/pool-stats.js");
        const kClients = Symbol('clients');
        const kNeedDrain = Symbol('needDrain');
        const kQueue = Symbol('queue');
        const kClosedResolve = Symbol('closed resolve');
        const kOnDrain = Symbol('onDrain');
        const kOnConnect = Symbol('onConnect');
        const kOnDisconnect = Symbol('onDisconnect');
        const kOnConnectionError = Symbol('onConnectionError');
        const kGetDispatcher = Symbol('get dispatcher');
        const kAddClient = Symbol('add client');
        const kRemoveClient = Symbol('remove client');
        const kStats = Symbol('stats');
        class PoolBase extends DispatcherBase {
            constructor(){
                super();
                this[kQueue] = new FixedQueue();
                this[kClients] = [];
                this[kQueued] = 0;
                const pool = this;
                this[kOnDrain] = function(origin, targets) {
                    const queue = pool[kQueue];
                    let needDrain = false;
                    while(!needDrain){
                        const item = queue.shift();
                        if (!item) break;
                        pool[kQueued]--;
                        needDrain = !this.dispatch(item.opts, item.handler);
                    }
                    this[kNeedDrain] = needDrain;
                    if (!this[kNeedDrain] && pool[kNeedDrain]) {
                        pool[kNeedDrain] = false;
                        pool.emit('drain', origin, [
                            pool,
                            ...targets
                        ]);
                    }
                    if (pool[kClosedResolve] && queue.isEmpty()) Promise.all(pool[kClients].map((c)=>c.close())).then(pool[kClosedResolve]);
                };
                this[kOnConnect] = (origin, targets)=>{
                    pool.emit('connect', origin, [
                        pool,
                        ...targets
                    ]);
                };
                this[kOnDisconnect] = (origin, targets, err)=>{
                    pool.emit('disconnect', origin, [
                        pool,
                        ...targets
                    ], err);
                };
                this[kOnConnectionError] = (origin, targets, err)=>{
                    pool.emit('connectionError', origin, [
                        pool,
                        ...targets
                    ], err);
                };
                this[kStats] = new PoolStats(this);
            }
            get [kBusy]() {
                return this[kNeedDrain];
            }
            get [kConnected]() {
                return this[kClients].filter((client)=>client[kConnected]).length;
            }
            get [kFree]() {
                return this[kClients].filter((client)=>client[kConnected] && !client[kNeedDrain]).length;
            }
            get [kPending]() {
                let ret = this[kQueued];
                for (const { [kPending]: pending } of this[kClients])ret += pending;
                return ret;
            }
            get [kRunning]() {
                let ret = 0;
                for (const { [kRunning]: running } of this[kClients])ret += running;
                return ret;
            }
            get [kSize]() {
                let ret = this[kQueued];
                for (const { [kSize]: size } of this[kClients])ret += size;
                return ret;
            }
            get stats() {
                return this[kStats];
            }
            async [kClose]() {
                if (this[kQueue].isEmpty()) await Promise.all(this[kClients].map((c)=>c.close()));
                else await new Promise((resolve)=>{
                    this[kClosedResolve] = resolve;
                });
            }
            async [kDestroy](err) {
                while(true){
                    const item = this[kQueue].shift();
                    if (!item) break;
                    item.handler.onError(err);
                }
                await Promise.all(this[kClients].map((c)=>c.destroy(err)));
            }
            [kDispatch](opts, handler) {
                const dispatcher = this[kGetDispatcher]();
                if (dispatcher) {
                    if (!dispatcher.dispatch(opts, handler)) {
                        dispatcher[kNeedDrain] = true;
                        this[kNeedDrain] = !this[kGetDispatcher]();
                    }
                } else {
                    this[kNeedDrain] = true;
                    this[kQueue].push({
                        opts,
                        handler
                    });
                    this[kQueued]++;
                }
                return !this[kNeedDrain];
            }
            [kAddClient](client) {
                client.on('drain', this[kOnDrain]).on('connect', this[kOnConnect]).on('disconnect', this[kOnDisconnect]).on('connectionError', this[kOnConnectionError]);
                this[kClients].push(client);
                if (this[kNeedDrain]) queueMicrotask(()=>{
                    if (this[kNeedDrain]) this[kOnDrain](client[kUrl], [
                        this,
                        client
                    ]);
                });
                return this;
            }
            [kRemoveClient](client) {
                client.close(()=>{
                    const idx = this[kClients].indexOf(client);
                    if (-1 !== idx) this[kClients].splice(idx, 1);
                });
                this[kNeedDrain] = this[kClients].some((dispatcher)=>!dispatcher[kNeedDrain] && true !== dispatcher.closed && true !== dispatcher.destroyed);
            }
        }
        module.exports = {
            PoolBase,
            kClients,
            kNeedDrain,
            kAddClient,
            kRemoveClient,
            kGetDispatcher
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/pool-stats.js" (module, __unused_rspack_exports, __webpack_require__) {
        const { kFree, kConnected, kPending, kQueued, kRunning, kSize } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const kPool = Symbol('pool');
        class PoolStats {
            constructor(pool){
                this[kPool] = pool;
            }
            get connected() {
                return this[kPool][kConnected];
            }
            get free() {
                return this[kPool][kFree];
            }
            get pending() {
                return this[kPool][kPending];
            }
            get queued() {
                return this[kPool][kQueued];
            }
            get running() {
                return this[kPool][kRunning];
            }
            get size() {
                return this[kPool][kSize];
            }
        }
        module.exports = PoolStats;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/pool.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { PoolBase, kClients, kNeedDrain, kAddClient, kGetDispatcher } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/pool-base.js");
        const Client = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/client.js");
        const { InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { kUrl, kInterceptors } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const buildConnector = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/connect.js");
        const kOptions = Symbol('options');
        const kConnections = Symbol('connections');
        const kFactory = Symbol('factory');
        function defaultFactory(origin, opts) {
            return new Client(origin, opts);
        }
        class Pool extends PoolBase {
            constructor(origin, { connections, factory = defaultFactory, connect, connectTimeout, tls, maxCachedSessions, socketPath, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2, ...options } = {}){
                super();
                if (null != connections && (!Number.isFinite(connections) || connections < 0)) throw new InvalidArgumentError('invalid connections');
                if ('function' != typeof factory) throw new InvalidArgumentError('factory must be a function.');
                if (null != connect && 'function' != typeof connect && 'object' != typeof connect) throw new InvalidArgumentError('connect must be a function or an object');
                if ('function' != typeof connect) connect = buildConnector({
                    ...tls,
                    maxCachedSessions,
                    allowH2,
                    socketPath,
                    timeout: connectTimeout,
                    ...autoSelectFamily ? {
                        autoSelectFamily,
                        autoSelectFamilyAttemptTimeout
                    } : void 0,
                    ...connect
                });
                this[kInterceptors] = options.interceptors?.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
                this[kConnections] = connections || null;
                this[kUrl] = util.parseOrigin(origin);
                this[kOptions] = {
                    ...util.deepClone(options),
                    connect,
                    allowH2
                };
                this[kOptions].interceptors = options.interceptors ? {
                    ...options.interceptors
                } : void 0;
                this[kFactory] = factory;
                this.on('connectionError', (origin, targets, error)=>{
                    for (const target of targets){
                        const idx = this[kClients].indexOf(target);
                        if (-1 !== idx) this[kClients].splice(idx, 1);
                    }
                });
            }
            [kGetDispatcher]() {
                for (const client of this[kClients])if (!client[kNeedDrain]) return client;
                if (!this[kConnections] || this[kClients].length < this[kConnections]) {
                    const dispatcher = this[kFactory](this[kUrl], this[kOptions]);
                    this[kAddClient](dispatcher);
                    return dispatcher;
                }
            }
        }
        module.exports = Pool;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/proxy-agent.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { kProxy, kClose, kDestroy, kDispatch, kInterceptors } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const { URL: URL1 } = __webpack_require__("node:url");
        const Agent = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/agent.js");
        const Pool = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/pool.js");
        const DispatcherBase = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/dispatcher-base.js");
        const { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const buildConnector = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/connect.js");
        const Client = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/client.js");
        const kAgent = Symbol('proxy agent');
        const kClient = Symbol('proxy client');
        const kProxyHeaders = Symbol('proxy headers');
        const kRequestTls = Symbol('request tls settings');
        const kProxyTls = Symbol('proxy tls settings');
        const kConnectEndpoint = Symbol('connect endpoint function');
        const kTunnelProxy = Symbol('tunnel proxy');
        function defaultProtocolPort(protocol) {
            return 'https:' === protocol ? 443 : 80;
        }
        function defaultFactory(origin, opts) {
            return new Pool(origin, opts);
        }
        const noop = ()=>{};
        function defaultAgentFactory(origin, opts) {
            if (1 === opts.connections) return new Client(origin, opts);
            return new Pool(origin, opts);
        }
        class Http1ProxyWrapper extends DispatcherBase {
            #client;
            constructor(proxyUrl, { headers = {}, connect, factory }){
                super();
                if (!proxyUrl) throw new InvalidArgumentError('Proxy URL is mandatory');
                this[kProxyHeaders] = headers;
                if (factory) this.#client = factory(proxyUrl, {
                    connect
                });
                else this.#client = new Client(proxyUrl, {
                    connect
                });
            }
            [kDispatch](opts, handler) {
                const onHeaders = handler.onHeaders;
                handler.onHeaders = function(statusCode, data, resume) {
                    if (407 === statusCode) {
                        if ('function' == typeof handler.onError) handler.onError(new InvalidArgumentError('Proxy Authentication Required (407)'));
                        return;
                    }
                    if (onHeaders) onHeaders.call(this, statusCode, data, resume);
                };
                const { origin, path = '/', headers = {} } = opts;
                opts.path = origin + path;
                if (!('host' in headers) && !('Host' in headers)) {
                    const { host } = new URL1(origin);
                    headers.host = host;
                }
                opts.headers = {
                    ...this[kProxyHeaders],
                    ...headers
                };
                return this.#client[kDispatch](opts, handler);
            }
            async [kClose]() {
                return this.#client.close();
            }
            async [kDestroy](err) {
                return this.#client.destroy(err);
            }
        }
        class ProxyAgent extends DispatcherBase {
            constructor(opts){
                super();
                if (!opts || 'object' == typeof opts && !(opts instanceof URL1) && !opts.uri) throw new InvalidArgumentError('Proxy uri is mandatory');
                const { clientFactory = defaultFactory } = opts;
                if ('function' != typeof clientFactory) throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.');
                const { proxyTunnel = true } = opts;
                const url = this.#getUrl(opts);
                const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url;
                this[kProxy] = {
                    uri: href,
                    protocol
                };
                this[kInterceptors] = opts.interceptors?.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
                this[kRequestTls] = opts.requestTls;
                this[kProxyTls] = opts.proxyTls;
                this[kProxyHeaders] = opts.headers || {};
                this[kTunnelProxy] = proxyTunnel;
                if (opts.auth && opts.token) throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token');
                if (opts.auth) this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`;
                else if (opts.token) this[kProxyHeaders]['proxy-authorization'] = opts.token;
                else if (username && password) this[kProxyHeaders]['proxy-authorization'] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString('base64')}`;
                const connect = buildConnector({
                    ...opts.proxyTls
                });
                this[kConnectEndpoint] = buildConnector({
                    ...opts.requestTls
                });
                const agentFactory = opts.factory || defaultAgentFactory;
                const factory = (origin, options)=>{
                    const { protocol } = new URL1(origin);
                    if (!this[kTunnelProxy] && 'http:' === protocol && 'http:' === this[kProxy].protocol) return new Http1ProxyWrapper(this[kProxy].uri, {
                        headers: this[kProxyHeaders],
                        connect,
                        factory: agentFactory
                    });
                    return agentFactory(origin, options);
                };
                this[kClient] = clientFactory(url, {
                    connect
                });
                this[kAgent] = new Agent({
                    ...opts,
                    factory,
                    connect: async (opts, callback)=>{
                        let requestedPath = opts.host;
                        if (!opts.port) requestedPath += `:${defaultProtocolPort(opts.protocol)}`;
                        try {
                            const { socket, statusCode } = await this[kClient].connect({
                                origin,
                                port,
                                path: requestedPath,
                                signal: opts.signal,
                                headers: {
                                    ...this[kProxyHeaders],
                                    host: opts.host
                                },
                                servername: this[kProxyTls]?.servername || proxyHostname
                            });
                            if (200 !== statusCode) {
                                socket.on('error', noop).destroy();
                                callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
                            }
                            if ('https:' !== opts.protocol) return void callback(null, socket);
                            let servername;
                            servername = this[kRequestTls] ? this[kRequestTls].servername : opts.servername;
                            this[kConnectEndpoint]({
                                ...opts,
                                servername,
                                httpSocket: socket
                            }, callback);
                        } catch (err) {
                            callback('ERR_TLS_CERT_ALTNAME_INVALID' === err.code ? new SecureProxyConnectionError(err) : err);
                        }
                    }
                });
            }
            dispatch(opts, handler) {
                const headers = buildHeaders(opts.headers);
                throwIfProxyAuthIsSent(headers);
                if (headers && !('host' in headers) && !('Host' in headers)) {
                    const { host } = new URL1(opts.origin);
                    headers.host = host;
                }
                return this[kAgent].dispatch({
                    ...opts,
                    headers
                }, handler);
            }
            #getUrl(opts) {
                if ('string' == typeof opts) return new URL1(opts);
                if (opts instanceof URL1) return opts;
                return new URL1(opts.uri);
            }
            async [kClose]() {
                await this[kAgent].close();
                await this[kClient].close();
            }
            async [kDestroy]() {
                await this[kAgent].destroy();
                await this[kClient].destroy();
            }
        }
        function buildHeaders(headers) {
            if (Array.isArray(headers)) {
                const headersPair = {};
                for(let i = 0; i < headers.length; i += 2)headersPair[headers[i]] = headers[i + 1];
                return headersPair;
            }
            return headers;
        }
        function throwIfProxyAuthIsSent(headers) {
            const existProxyAuth = headers && Object.keys(headers).find((key)=>'proxy-authorization' === key.toLowerCase());
            if (existProxyAuth) throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor');
        }
        module.exports = ProxyAgent;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/retry-agent.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const Dispatcher = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/dispatcher.js");
        const RetryHandler = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/handler/retry-handler.js");
        class RetryAgent extends Dispatcher {
            #agent = null;
            #options = null;
            constructor(agent, options = {}){
                super(options);
                this.#agent = agent;
                this.#options = options;
            }
            dispatch(opts, handler) {
                const retry = new RetryHandler({
                    ...opts,
                    retryOptions: this.#options
                }, {
                    dispatch: this.#agent.dispatch.bind(this.#agent),
                    handler
                });
                return this.#agent.dispatch(opts, retry);
            }
            close() {
                return this.#agent.close();
            }
            destroy() {
                return this.#agent.destroy();
            }
        }
        module.exports = RetryAgent;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/global.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const globalDispatcher = Symbol.for('undici.globalDispatcher.1');
        const { InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const Agent = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/agent.js");
        if (void 0 === getGlobalDispatcher()) setGlobalDispatcher(new Agent());
        function setGlobalDispatcher(agent) {
            if (!agent || 'function' != typeof agent.dispatch) throw new InvalidArgumentError('Argument agent must implement Agent');
            Object.defineProperty(globalThis, globalDispatcher, {
                value: agent,
                writable: true,
                enumerable: false,
                configurable: false
            });
        }
        function getGlobalDispatcher() {
            return globalThis[globalDispatcher];
        }
        module.exports = {
            setGlobalDispatcher,
            getGlobalDispatcher
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/handler/decorator-handler.js" (module) {
        "use strict";
        module.exports = class {
            #handler;
            constructor(handler){
                if ('object' != typeof handler || null === handler) throw new TypeError('handler must be an object');
                this.#handler = handler;
            }
            onConnect(...args) {
                return this.#handler.onConnect?.(...args);
            }
            onError(...args) {
                return this.#handler.onError?.(...args);
            }
            onUpgrade(...args) {
                return this.#handler.onUpgrade?.(...args);
            }
            onResponseStarted(...args) {
                return this.#handler.onResponseStarted?.(...args);
            }
            onHeaders(...args) {
                return this.#handler.onHeaders?.(...args);
            }
            onData(...args) {
                return this.#handler.onData?.(...args);
            }
            onComplete(...args) {
                return this.#handler.onComplete?.(...args);
            }
            onBodySent(...args) {
                return this.#handler.onBodySent?.(...args);
            }
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/handler/redirect-handler.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { kBodyUsed } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const assert = __webpack_require__("node:assert");
        const { InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const EE = __webpack_require__("node:events");
        const redirectableStatusCodes = [
            300,
            301,
            302,
            303,
            307,
            308
        ];
        const kBody = Symbol('body');
        class BodyAsyncIterable {
            constructor(body){
                this[kBody] = body;
                this[kBodyUsed] = false;
            }
            async *[Symbol.asyncIterator]() {
                assert(!this[kBodyUsed], 'disturbed');
                this[kBodyUsed] = true;
                yield* this[kBody];
            }
        }
        class RedirectHandler {
            constructor(dispatch, maxRedirections, opts, handler){
                if (null != maxRedirections && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new InvalidArgumentError('maxRedirections must be a positive number');
                util.validateHandler(handler, opts.method, opts.upgrade);
                this.dispatch = dispatch;
                this.location = null;
                this.abort = null;
                this.opts = {
                    ...opts,
                    maxRedirections: 0
                };
                this.maxRedirections = maxRedirections;
                this.handler = handler;
                this.history = [];
                this.redirectionLimitReached = false;
                if (util.isStream(this.opts.body)) {
                    if (0 === util.bodyLength(this.opts.body)) this.opts.body.on('data', function() {
                        assert(false);
                    });
                    if ('boolean' != typeof this.opts.body.readableDidRead) {
                        this.opts.body[kBodyUsed] = false;
                        EE.prototype.on.call(this.opts.body, 'data', function() {
                            this[kBodyUsed] = true;
                        });
                    }
                } else if (this.opts.body && 'function' == typeof this.opts.body.pipeTo) this.opts.body = new BodyAsyncIterable(this.opts.body);
                else if (this.opts.body && 'string' != typeof this.opts.body && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) this.opts.body = new BodyAsyncIterable(this.opts.body);
            }
            onConnect(abort) {
                this.abort = abort;
                this.handler.onConnect(abort, {
                    history: this.history
                });
            }
            onUpgrade(statusCode, headers, socket) {
                this.handler.onUpgrade(statusCode, headers, socket);
            }
            onError(error) {
                this.handler.onError(error);
            }
            onHeaders(statusCode, headers, resume, statusText) {
                this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
                if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
                    if (this.request) this.request.abort(new Error('max redirects'));
                    this.redirectionLimitReached = true;
                    this.abort(new Error('max redirects'));
                    return;
                }
                if (this.opts.origin) this.history.push(new URL(this.opts.path, this.opts.origin));
                if (!this.location) return this.handler.onHeaders(statusCode, headers, resume, statusText);
                const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
                const path = search ? `${pathname}${search}` : pathname;
                this.opts.headers = cleanRequestHeaders(this.opts.headers, 303 === statusCode, this.opts.origin !== origin);
                this.opts.path = path;
                this.opts.origin = origin;
                this.opts.maxRedirections = 0;
                this.opts.query = null;
                if (303 === statusCode && 'HEAD' !== this.opts.method) {
                    this.opts.method = 'GET';
                    this.opts.body = null;
                }
            }
            onData(chunk) {
                if (!this.location) return this.handler.onData(chunk);
            }
            onComplete(trailers) {
                if (this.location) {
                    this.location = null;
                    this.abort = null;
                    this.dispatch(this.opts, this);
                } else this.handler.onComplete(trailers);
            }
            onBodySent(chunk) {
                if (this.handler.onBodySent) this.handler.onBodySent(chunk);
            }
        }
        function parseLocation(statusCode, headers) {
            if (-1 === redirectableStatusCodes.indexOf(statusCode)) return null;
            for(let i = 0; i < headers.length; i += 2)if (8 === headers[i].length && 'location' === util.headerNameToString(headers[i])) return headers[i + 1];
        }
        function shouldRemoveHeader(header, removeContent, unknownOrigin) {
            if (4 === header.length) return 'host' === util.headerNameToString(header);
            if (removeContent && util.headerNameToString(header).startsWith('content-')) return true;
            if (unknownOrigin && (13 === header.length || 6 === header.length || 19 === header.length)) {
                const name = util.headerNameToString(header);
                return 'authorization' === name || 'cookie' === name || 'proxy-authorization' === name;
            }
            return false;
        }
        function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
            const ret = [];
            if (Array.isArray(headers)) {
                for(let i = 0; i < headers.length; i += 2)if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) ret.push(headers[i], headers[i + 1]);
            } else if (headers && 'object' == typeof headers) {
                for (const key of Object.keys(headers))if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) ret.push(key, headers[key]);
            } else assert(null == headers, 'headers must be an object or an array');
            return ret;
        }
        module.exports = RedirectHandler;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/handler/retry-handler.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const assert = __webpack_require__("node:assert");
        const { kRetryHandlerDefaultRetry } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const { RequestRetryError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const { isDisturbed, parseHeaders, parseRangeHeader, wrapRequestBody } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        function calculateRetryAfterHeader(retryAfter) {
            const current = Date.now();
            return new Date(retryAfter).getTime() - current;
        }
        class RetryHandler {
            constructor(opts, handlers){
                const { retryOptions, ...dispatchOpts } = opts;
                const { retry: retryFn, maxRetries, maxTimeout, minTimeout, timeoutFactor, methods, errorCodes, retryAfter, statusCodes } = retryOptions ?? {};
                this.dispatch = handlers.dispatch;
                this.handler = handlers.handler;
                this.opts = {
                    ...dispatchOpts,
                    body: wrapRequestBody(opts.body)
                };
                this.abort = null;
                this.aborted = false;
                this.retryOpts = {
                    retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
                    retryAfter: retryAfter ?? true,
                    maxTimeout: maxTimeout ?? 30000,
                    minTimeout: minTimeout ?? 500,
                    timeoutFactor: timeoutFactor ?? 2,
                    maxRetries: maxRetries ?? 5,
                    methods: methods ?? [
                        'GET',
                        'HEAD',
                        'OPTIONS',
                        'PUT',
                        'DELETE',
                        'TRACE'
                    ],
                    statusCodes: statusCodes ?? [
                        500,
                        502,
                        503,
                        504,
                        429
                    ],
                    errorCodes: errorCodes ?? [
                        'ECONNRESET',
                        'ECONNREFUSED',
                        'ENOTFOUND',
                        'ENETDOWN',
                        'ENETUNREACH',
                        'EHOSTDOWN',
                        'EHOSTUNREACH',
                        'EPIPE',
                        'UND_ERR_SOCKET'
                    ]
                };
                this.retryCount = 0;
                this.retryCountCheckpoint = 0;
                this.start = 0;
                this.end = null;
                this.etag = null;
                this.resume = null;
                this.handler.onConnect((reason)=>{
                    this.aborted = true;
                    if (this.abort) this.abort(reason);
                    else this.reason = reason;
                });
            }
            onRequestSent() {
                if (this.handler.onRequestSent) this.handler.onRequestSent();
            }
            onUpgrade(statusCode, headers, socket) {
                if (this.handler.onUpgrade) this.handler.onUpgrade(statusCode, headers, socket);
            }
            onConnect(abort) {
                if (this.aborted) abort(this.reason);
                else this.abort = abort;
            }
            onBodySent(chunk) {
                if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
            }
            static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
                const { statusCode, code, headers } = err;
                const { method, retryOptions } = opts;
                const { maxRetries, minTimeout, maxTimeout, timeoutFactor, statusCodes, errorCodes, methods } = retryOptions;
                const { counter } = state;
                if (code && 'UND_ERR_REQ_RETRY' !== code && !errorCodes.includes(code)) return void cb(err);
                if (Array.isArray(methods) && !methods.includes(method)) return void cb(err);
                if (null != statusCode && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) return void cb(err);
                if (counter > maxRetries) return void cb(err);
                let retryAfterHeader = headers?.['retry-after'];
                if (retryAfterHeader) {
                    retryAfterHeader = Number(retryAfterHeader);
                    retryAfterHeader = Number.isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : 1e3 * retryAfterHeader;
                }
                const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout);
                setTimeout(()=>cb(null), retryTimeout);
            }
            onHeaders(statusCode, rawHeaders, resume, statusMessage) {
                const headers = parseHeaders(rawHeaders);
                this.retryCount += 1;
                if (statusCode >= 300) if (false === this.retryOpts.statusCodes.includes(statusCode)) return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
                else {
                    this.abort(new RequestRetryError('Request failed', statusCode, {
                        headers,
                        data: {
                            count: this.retryCount
                        }
                    }));
                    return false;
                }
                if (null != this.resume) {
                    this.resume = null;
                    if (206 !== statusCode && (this.start > 0 || 200 !== statusCode)) {
                        this.abort(new RequestRetryError('server does not support the range header and the payload was partially consumed', statusCode, {
                            headers,
                            data: {
                                count: this.retryCount
                            }
                        }));
                        return false;
                    }
                    const contentRange = parseRangeHeader(headers['content-range']);
                    if (!contentRange) {
                        this.abort(new RequestRetryError('Content-Range mismatch', statusCode, {
                            headers,
                            data: {
                                count: this.retryCount
                            }
                        }));
                        return false;
                    }
                    if (null != this.etag && this.etag !== headers.etag) {
                        this.abort(new RequestRetryError('ETag mismatch', statusCode, {
                            headers,
                            data: {
                                count: this.retryCount
                            }
                        }));
                        return false;
                    }
                    const { start, size, end = size - 1 } = contentRange;
                    assert(this.start === start, 'content-range mismatch');
                    assert(null == this.end || this.end === end, 'content-range mismatch');
                    this.resume = resume;
                    return true;
                }
                if (null == this.end) {
                    if (206 === statusCode) {
                        const range = parseRangeHeader(headers['content-range']);
                        if (null == range) return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
                        const { start, size, end = size - 1 } = range;
                        assert(null != start && Number.isFinite(start), 'content-range mismatch');
                        assert(null != end && Number.isFinite(end), 'invalid content-length');
                        this.start = start;
                        this.end = end;
                    }
                    if (null == this.end) {
                        const contentLength = headers['content-length'];
                        this.end = null != contentLength ? Number(contentLength) - 1 : null;
                    }
                    assert(Number.isFinite(this.start));
                    assert(null == this.end || Number.isFinite(this.end), 'invalid content-length');
                    this.resume = resume;
                    this.etag = null != headers.etag ? headers.etag : null;
                    if (null != this.etag && this.etag.startsWith('W/')) this.etag = null;
                    return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
                }
                const err = new RequestRetryError('Request failed', statusCode, {
                    headers,
                    data: {
                        count: this.retryCount
                    }
                });
                this.abort(err);
                return false;
            }
            onData(chunk) {
                this.start += chunk.length;
                return this.handler.onData(chunk);
            }
            onComplete(rawTrailers) {
                this.retryCount = 0;
                return this.handler.onComplete(rawTrailers);
            }
            onError(err) {
                if (this.aborted || isDisturbed(this.opts.body)) return this.handler.onError(err);
                if (this.retryCount - this.retryCountCheckpoint > 0) this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint);
                else this.retryCount += 1;
                this.retryOpts.retry(err, {
                    state: {
                        counter: this.retryCount
                    },
                    opts: {
                        retryOptions: this.retryOpts,
                        ...this.opts
                    }
                }, onRetry.bind(this));
                function onRetry(err) {
                    if (null != err || this.aborted || isDisturbed(this.opts.body)) return this.handler.onError(err);
                    if (0 !== this.start) {
                        const headers = {
                            range: `bytes=${this.start}-${this.end ?? ''}`
                        };
                        if (null != this.etag) headers['if-match'] = this.etag;
                        this.opts = {
                            ...this.opts,
                            headers: {
                                ...this.opts.headers,
                                ...headers
                            }
                        };
                    }
                    try {
                        this.retryCountCheckpoint = this.retryCount;
                        this.dispatch(this.opts, this);
                    } catch (err) {
                        this.handler.onError(err);
                    }
                }
            }
        }
        module.exports = RetryHandler;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/interceptor/dns.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { isIP } = __webpack_require__("node:net");
        const { lookup } = __webpack_require__("node:dns");
        const DecoratorHandler = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/handler/decorator-handler.js");
        const { InvalidArgumentError, InformationalError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const maxInt = Math.pow(2, 31) - 1;
        class DNSInstance {
            #maxTTL = 0;
            #maxItems = 0;
            #records = new Map();
            dualStack = true;
            affinity = null;
            lookup = null;
            pick = null;
            constructor(opts){
                this.#maxTTL = opts.maxTTL;
                this.#maxItems = opts.maxItems;
                this.dualStack = opts.dualStack;
                this.affinity = opts.affinity;
                this.lookup = opts.lookup ?? this.#defaultLookup;
                this.pick = opts.pick ?? this.#defaultPick;
            }
            get full() {
                return this.#records.size === this.#maxItems;
            }
            runLookup(origin, opts, cb) {
                const ips = this.#records.get(origin.hostname);
                if (null == ips && this.full) return void cb(null, origin.origin);
                const newOpts = {
                    affinity: this.affinity,
                    dualStack: this.dualStack,
                    lookup: this.lookup,
                    pick: this.pick,
                    ...opts.dns,
                    maxTTL: this.#maxTTL,
                    maxItems: this.#maxItems
                };
                if (null == ips) this.lookup(origin, newOpts, (err, addresses)=>{
                    if (err || null == addresses || 0 === addresses.length) return void cb(err ?? new InformationalError('No DNS entries found'));
                    this.setRecords(origin, addresses);
                    const records = this.#records.get(origin.hostname);
                    const ip = this.pick(origin, records, newOpts.affinity);
                    let port;
                    port = 'number' == typeof ip.port ? `:${ip.port}` : '' !== origin.port ? `:${origin.port}` : '';
                    cb(null, `${origin.protocol}//${6 === ip.family ? `[${ip.address}]` : ip.address}${port}`);
                });
                else {
                    const ip = this.pick(origin, ips, newOpts.affinity);
                    if (null == ip) {
                        this.#records.delete(origin.hostname);
                        this.runLookup(origin, opts, cb);
                        return;
                    }
                    let port;
                    port = 'number' == typeof ip.port ? `:${ip.port}` : '' !== origin.port ? `:${origin.port}` : '';
                    cb(null, `${origin.protocol}//${6 === ip.family ? `[${ip.address}]` : ip.address}${port}`);
                }
            }
            #defaultLookup(origin, opts, cb) {
                lookup(origin.hostname, {
                    all: true,
                    family: false === this.dualStack ? this.affinity : 0,
                    order: 'ipv4first'
                }, (err, addresses)=>{
                    if (err) return cb(err);
                    const results = new Map();
                    for (const addr of addresses)results.set(`${addr.address}:${addr.family}`, addr);
                    cb(null, results.values());
                });
            }
            #defaultPick(origin, hostnameRecords, affinity) {
                let ip = null;
                const { records, offset } = hostnameRecords;
                let family;
                if (this.dualStack) {
                    if (null == affinity) if (null == offset || offset === maxInt) {
                        hostnameRecords.offset = 0;
                        affinity = 4;
                    } else {
                        hostnameRecords.offset++;
                        affinity = (1 & hostnameRecords.offset) === 1 ? 6 : 4;
                    }
                    family = null != records[affinity] && records[affinity].ips.length > 0 ? records[affinity] : records[4 === affinity ? 6 : 4];
                } else family = records[affinity];
                if (null == family || 0 === family.ips.length) return ip;
                if (null == family.offset || family.offset === maxInt) family.offset = 0;
                else family.offset++;
                const position = family.offset % family.ips.length;
                ip = family.ips[position] ?? null;
                if (null == ip) return ip;
                if (Date.now() - ip.timestamp > ip.ttl) {
                    family.ips.splice(position, 1);
                    return this.pick(origin, hostnameRecords, affinity);
                }
                return ip;
            }
            setRecords(origin, addresses) {
                const timestamp = Date.now();
                const records = {
                    records: {
                        4: null,
                        6: null
                    }
                };
                for (const record of addresses){
                    record.timestamp = timestamp;
                    if ('number' == typeof record.ttl) record.ttl = Math.min(record.ttl, this.#maxTTL);
                    else record.ttl = this.#maxTTL;
                    const familyRecords = records.records[record.family] ?? {
                        ips: []
                    };
                    familyRecords.ips.push(record);
                    records.records[record.family] = familyRecords;
                }
                this.#records.set(origin.hostname, records);
            }
            getHandler(meta, opts) {
                return new DNSDispatchHandler(this, meta, opts);
            }
        }
        class DNSDispatchHandler extends DecoratorHandler {
            #state = null;
            #opts = null;
            #dispatch = null;
            #handler = null;
            #origin = null;
            constructor(state, { origin, handler, dispatch }, opts){
                super(handler);
                this.#origin = origin;
                this.#handler = handler;
                this.#opts = {
                    ...opts
                };
                this.#state = state;
                this.#dispatch = dispatch;
            }
            onError(err) {
                switch(err.code){
                    case 'ETIMEDOUT':
                    case 'ECONNREFUSED':
                        if (this.#state.dualStack) return void this.#state.runLookup(this.#origin, this.#opts, (err, newOrigin)=>{
                            if (err) return this.#handler.onError(err);
                            const dispatchOpts = {
                                ...this.#opts,
                                origin: newOrigin
                            };
                            this.#dispatch(dispatchOpts, this);
                        });
                        this.#handler.onError(err);
                        return;
                    case 'ENOTFOUND':
                        this.#state.deleteRecord(this.#origin);
                    default:
                        this.#handler.onError(err);
                        break;
                }
            }
        }
        module.exports = (interceptorOpts)=>{
            if (interceptorOpts?.maxTTL != null && ('number' != typeof interceptorOpts?.maxTTL || interceptorOpts?.maxTTL < 0)) throw new InvalidArgumentError('Invalid maxTTL. Must be a positive number');
            if (interceptorOpts?.maxItems != null && ('number' != typeof interceptorOpts?.maxItems || interceptorOpts?.maxItems < 1)) throw new InvalidArgumentError('Invalid maxItems. Must be a positive number and greater than zero');
            if (interceptorOpts?.affinity != null && interceptorOpts?.affinity !== 4 && interceptorOpts?.affinity !== 6) throw new InvalidArgumentError('Invalid affinity. Must be either 4 or 6');
            if (interceptorOpts?.dualStack != null && 'boolean' != typeof interceptorOpts?.dualStack) throw new InvalidArgumentError('Invalid dualStack. Must be a boolean');
            if (interceptorOpts?.lookup != null && 'function' != typeof interceptorOpts?.lookup) throw new InvalidArgumentError('Invalid lookup. Must be a function');
            if (interceptorOpts?.pick != null && 'function' != typeof interceptorOpts?.pick) throw new InvalidArgumentError('Invalid pick. Must be a function');
            const dualStack = interceptorOpts?.dualStack ?? true;
            let affinity;
            affinity = dualStack ? interceptorOpts?.affinity ?? null : interceptorOpts?.affinity ?? 4;
            const opts = {
                maxTTL: interceptorOpts?.maxTTL ?? 10e3,
                lookup: interceptorOpts?.lookup ?? null,
                pick: interceptorOpts?.pick ?? null,
                dualStack,
                affinity,
                maxItems: interceptorOpts?.maxItems ?? 1 / 0
            };
            const instance = new DNSInstance(opts);
            return (dispatch)=>function(origDispatchOpts, handler) {
                    const origin = origDispatchOpts.origin.constructor === URL ? origDispatchOpts.origin : new URL(origDispatchOpts.origin);
                    if (0 !== isIP(origin.hostname)) return dispatch(origDispatchOpts, handler);
                    instance.runLookup(origin, origDispatchOpts, (err, newOrigin)=>{
                        if (err) return handler.onError(err);
                        let dispatchOpts = null;
                        dispatchOpts = {
                            ...origDispatchOpts,
                            servername: origin.hostname,
                            origin: newOrigin,
                            headers: {
                                host: origin.hostname,
                                ...origDispatchOpts.headers
                            }
                        };
                        dispatch(dispatchOpts, instance.getHandler({
                            origin,
                            dispatch,
                            handler
                        }, origDispatchOpts));
                    });
                    return true;
                };
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/interceptor/dump.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { InvalidArgumentError, RequestAbortedError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const DecoratorHandler = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/handler/decorator-handler.js");
        class DumpHandler extends DecoratorHandler {
            #maxSize = 1048576;
            #abort = null;
            #dumped = false;
            #aborted = false;
            #size = 0;
            #reason = null;
            #handler = null;
            constructor({ maxSize }, handler){
                super(handler);
                if (null != maxSize && (!Number.isFinite(maxSize) || maxSize < 1)) throw new InvalidArgumentError('maxSize must be a number greater than 0');
                this.#maxSize = maxSize ?? this.#maxSize;
                this.#handler = handler;
            }
            onConnect(abort) {
                this.#abort = abort;
                this.#handler.onConnect(this.#customAbort.bind(this));
            }
            #customAbort(reason) {
                this.#aborted = true;
                this.#reason = reason;
            }
            onHeaders(statusCode, rawHeaders, resume, statusMessage) {
                const headers = util.parseHeaders(rawHeaders);
                const contentLength = headers['content-length'];
                if (null != contentLength && contentLength > this.#maxSize) throw new RequestAbortedError(`Response size (${contentLength}) larger than maxSize (${this.#maxSize})`);
                if (this.#aborted) return true;
                return this.#handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
            }
            onError(err) {
                if (this.#dumped) return;
                err = this.#reason ?? err;
                this.#handler.onError(err);
            }
            onData(chunk) {
                this.#size = this.#size + chunk.length;
                if (this.#size >= this.#maxSize) {
                    this.#dumped = true;
                    if (this.#aborted) this.#handler.onError(this.#reason);
                    else this.#handler.onComplete([]);
                }
                return true;
            }
            onComplete(trailers) {
                if (this.#dumped) return;
                if (this.#aborted) return void this.#handler.onError(this.reason);
                this.#handler.onComplete(trailers);
            }
        }
        function createDumpInterceptor({ maxSize: defaultMaxSize } = {
            maxSize: 1048576
        }) {
            return (dispatch)=>function(opts, handler) {
                    const { dumpMaxSize = defaultMaxSize } = opts;
                    const dumpHandler = new DumpHandler({
                        maxSize: dumpMaxSize
                    }, handler);
                    return dispatch(opts, dumpHandler);
                };
        }
        module.exports = createDumpInterceptor;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/interceptor/redirect-interceptor.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const RedirectHandler = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/handler/redirect-handler.js");
        function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
            return (dispatch)=>function(opts, handler) {
                    const { maxRedirections = defaultMaxRedirections } = opts;
                    if (!maxRedirections) return dispatch(opts, handler);
                    const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
                    opts = {
                        ...opts,
                        maxRedirections: 0
                    };
                    return dispatch(opts, redirectHandler);
                };
        }
        module.exports = createRedirectInterceptor;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/interceptor/redirect.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const RedirectHandler = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/handler/redirect-handler.js");
        module.exports = (opts)=>{
            const globalMaxRedirections = opts?.maxRedirections;
            return (dispatch)=>function(opts, handler) {
                    const { maxRedirections = globalMaxRedirections, ...baseOpts } = opts;
                    if (!maxRedirections) return dispatch(opts, handler);
                    const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
                    return dispatch(baseOpts, redirectHandler);
                };
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/interceptor/retry.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const RetryHandler = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/handler/retry-handler.js");
        module.exports = (globalOpts)=>(dispatch)=>function(opts, handler) {
                    return dispatch(opts, new RetryHandler({
                        ...opts,
                        retryOptions: {
                            ...globalOpts,
                            ...opts.retryOptions
                        }
                    }, {
                        handler,
                        dispatch
                    }));
                };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/llhttp/constants.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.SPECIAL_HEADERS = exports1.HEADER_STATE = exports1.MINOR = exports1.MAJOR = exports1.CONNECTION_TOKEN_CHARS = exports1.HEADER_CHARS = exports1.TOKEN = exports1.STRICT_TOKEN = exports1.HEX = exports1.URL_CHAR = exports1.STRICT_URL_CHAR = exports1.USERINFO_CHARS = exports1.MARK = exports1.ALPHANUM = exports1.NUM = exports1.HEX_MAP = exports1.NUM_MAP = exports1.ALPHA = exports1.FINISH = exports1.H_METHOD_MAP = exports1.METHOD_MAP = exports1.METHODS_RTSP = exports1.METHODS_ICE = exports1.METHODS_HTTP = exports1.METHODS = exports1.LENIENT_FLAGS = exports1.FLAGS = exports1.TYPE = exports1.ERROR = void 0;
        const utils_1 = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/llhttp/utils.js");
        (function(ERROR) {
            ERROR[ERROR["OK"] = 0] = "OK";
            ERROR[ERROR["INTERNAL"] = 1] = "INTERNAL";
            ERROR[ERROR["STRICT"] = 2] = "STRICT";
            ERROR[ERROR["LF_EXPECTED"] = 3] = "LF_EXPECTED";
            ERROR[ERROR["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
            ERROR[ERROR["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
            ERROR[ERROR["INVALID_METHOD"] = 6] = "INVALID_METHOD";
            ERROR[ERROR["INVALID_URL"] = 7] = "INVALID_URL";
            ERROR[ERROR["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
            ERROR[ERROR["INVALID_VERSION"] = 9] = "INVALID_VERSION";
            ERROR[ERROR["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
            ERROR[ERROR["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
            ERROR[ERROR["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
            ERROR[ERROR["INVALID_STATUS"] = 13] = "INVALID_STATUS";
            ERROR[ERROR["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
            ERROR[ERROR["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
            ERROR[ERROR["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
            ERROR[ERROR["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
            ERROR[ERROR["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
            ERROR[ERROR["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
            ERROR[ERROR["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
            ERROR[ERROR["PAUSED"] = 21] = "PAUSED";
            ERROR[ERROR["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
            ERROR[ERROR["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
            ERROR[ERROR["USER"] = 24] = "USER";
        })(exports1.ERROR || (exports1.ERROR = {}));
        (function(TYPE) {
            TYPE[TYPE["BOTH"] = 0] = "BOTH";
            TYPE[TYPE["REQUEST"] = 1] = "REQUEST";
            TYPE[TYPE["RESPONSE"] = 2] = "RESPONSE";
        })(exports1.TYPE || (exports1.TYPE = {}));
        (function(FLAGS) {
            FLAGS[FLAGS["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
            FLAGS[FLAGS["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
            FLAGS[FLAGS["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
            FLAGS[FLAGS["CHUNKED"] = 8] = "CHUNKED";
            FLAGS[FLAGS["UPGRADE"] = 16] = "UPGRADE";
            FLAGS[FLAGS["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
            FLAGS[FLAGS["SKIPBODY"] = 64] = "SKIPBODY";
            FLAGS[FLAGS["TRAILING"] = 128] = "TRAILING";
            FLAGS[FLAGS["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
        })(exports1.FLAGS || (exports1.FLAGS = {}));
        (function(LENIENT_FLAGS) {
            LENIENT_FLAGS[LENIENT_FLAGS["HEADERS"] = 1] = "HEADERS";
            LENIENT_FLAGS[LENIENT_FLAGS["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
            LENIENT_FLAGS[LENIENT_FLAGS["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
        })(exports1.LENIENT_FLAGS || (exports1.LENIENT_FLAGS = {}));
        var METHODS;
        (function(METHODS) {
            METHODS[METHODS["DELETE"] = 0] = "DELETE";
            METHODS[METHODS["GET"] = 1] = "GET";
            METHODS[METHODS["HEAD"] = 2] = "HEAD";
            METHODS[METHODS["POST"] = 3] = "POST";
            METHODS[METHODS["PUT"] = 4] = "PUT";
            METHODS[METHODS["CONNECT"] = 5] = "CONNECT";
            METHODS[METHODS["OPTIONS"] = 6] = "OPTIONS";
            METHODS[METHODS["TRACE"] = 7] = "TRACE";
            METHODS[METHODS["COPY"] = 8] = "COPY";
            METHODS[METHODS["LOCK"] = 9] = "LOCK";
            METHODS[METHODS["MKCOL"] = 10] = "MKCOL";
            METHODS[METHODS["MOVE"] = 11] = "MOVE";
            METHODS[METHODS["PROPFIND"] = 12] = "PROPFIND";
            METHODS[METHODS["PROPPATCH"] = 13] = "PROPPATCH";
            METHODS[METHODS["SEARCH"] = 14] = "SEARCH";
            METHODS[METHODS["UNLOCK"] = 15] = "UNLOCK";
            METHODS[METHODS["BIND"] = 16] = "BIND";
            METHODS[METHODS["REBIND"] = 17] = "REBIND";
            METHODS[METHODS["UNBIND"] = 18] = "UNBIND";
            METHODS[METHODS["ACL"] = 19] = "ACL";
            METHODS[METHODS["REPORT"] = 20] = "REPORT";
            METHODS[METHODS["MKACTIVITY"] = 21] = "MKACTIVITY";
            METHODS[METHODS["CHECKOUT"] = 22] = "CHECKOUT";
            METHODS[METHODS["MERGE"] = 23] = "MERGE";
            METHODS[METHODS["M-SEARCH"] = 24] = "M-SEARCH";
            METHODS[METHODS["NOTIFY"] = 25] = "NOTIFY";
            METHODS[METHODS["SUBSCRIBE"] = 26] = "SUBSCRIBE";
            METHODS[METHODS["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
            METHODS[METHODS["PATCH"] = 28] = "PATCH";
            METHODS[METHODS["PURGE"] = 29] = "PURGE";
            METHODS[METHODS["MKCALENDAR"] = 30] = "MKCALENDAR";
            METHODS[METHODS["LINK"] = 31] = "LINK";
            METHODS[METHODS["UNLINK"] = 32] = "UNLINK";
            METHODS[METHODS["SOURCE"] = 33] = "SOURCE";
            METHODS[METHODS["PRI"] = 34] = "PRI";
            METHODS[METHODS["DESCRIBE"] = 35] = "DESCRIBE";
            METHODS[METHODS["ANNOUNCE"] = 36] = "ANNOUNCE";
            METHODS[METHODS["SETUP"] = 37] = "SETUP";
            METHODS[METHODS["PLAY"] = 38] = "PLAY";
            METHODS[METHODS["PAUSE"] = 39] = "PAUSE";
            METHODS[METHODS["TEARDOWN"] = 40] = "TEARDOWN";
            METHODS[METHODS["GET_PARAMETER"] = 41] = "GET_PARAMETER";
            METHODS[METHODS["SET_PARAMETER"] = 42] = "SET_PARAMETER";
            METHODS[METHODS["REDIRECT"] = 43] = "REDIRECT";
            METHODS[METHODS["RECORD"] = 44] = "RECORD";
            METHODS[METHODS["FLUSH"] = 45] = "FLUSH";
        })(METHODS = exports1.METHODS || (exports1.METHODS = {}));
        exports1.METHODS_HTTP = [
            METHODS.DELETE,
            METHODS.GET,
            METHODS.HEAD,
            METHODS.POST,
            METHODS.PUT,
            METHODS.CONNECT,
            METHODS.OPTIONS,
            METHODS.TRACE,
            METHODS.COPY,
            METHODS.LOCK,
            METHODS.MKCOL,
            METHODS.MOVE,
            METHODS.PROPFIND,
            METHODS.PROPPATCH,
            METHODS.SEARCH,
            METHODS.UNLOCK,
            METHODS.BIND,
            METHODS.REBIND,
            METHODS.UNBIND,
            METHODS.ACL,
            METHODS.REPORT,
            METHODS.MKACTIVITY,
            METHODS.CHECKOUT,
            METHODS.MERGE,
            METHODS['M-SEARCH'],
            METHODS.NOTIFY,
            METHODS.SUBSCRIBE,
            METHODS.UNSUBSCRIBE,
            METHODS.PATCH,
            METHODS.PURGE,
            METHODS.MKCALENDAR,
            METHODS.LINK,
            METHODS.UNLINK,
            METHODS.PRI,
            METHODS.SOURCE
        ];
        exports1.METHODS_ICE = [
            METHODS.SOURCE
        ];
        exports1.METHODS_RTSP = [
            METHODS.OPTIONS,
            METHODS.DESCRIBE,
            METHODS.ANNOUNCE,
            METHODS.SETUP,
            METHODS.PLAY,
            METHODS.PAUSE,
            METHODS.TEARDOWN,
            METHODS.GET_PARAMETER,
            METHODS.SET_PARAMETER,
            METHODS.REDIRECT,
            METHODS.RECORD,
            METHODS.FLUSH,
            METHODS.GET,
            METHODS.POST
        ];
        exports1.METHOD_MAP = utils_1.enumToMap(METHODS);
        exports1.H_METHOD_MAP = {};
        Object.keys(exports1.METHOD_MAP).forEach((key)=>{
            if (/^H/.test(key)) exports1.H_METHOD_MAP[key] = exports1.METHOD_MAP[key];
        });
        (function(FINISH) {
            FINISH[FINISH["SAFE"] = 0] = "SAFE";
            FINISH[FINISH["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
            FINISH[FINISH["UNSAFE"] = 2] = "UNSAFE";
        })(exports1.FINISH || (exports1.FINISH = {}));
        exports1.ALPHA = [];
        for(let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++){
            exports1.ALPHA.push(String.fromCharCode(i));
            exports1.ALPHA.push(String.fromCharCode(i + 0x20));
        }
        exports1.NUM_MAP = {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9
        };
        exports1.HEX_MAP = {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9,
            A: 0XA,
            B: 0XB,
            C: 0XC,
            D: 0XD,
            E: 0XE,
            F: 0XF,
            a: 0xa,
            b: 0xb,
            c: 0xc,
            d: 0xd,
            e: 0xe,
            f: 0xf
        };
        exports1.NUM = [
            '0',
            '1',
            '2',
            '3',
            '4',
            '5',
            '6',
            '7',
            '8',
            '9'
        ];
        exports1.ALPHANUM = exports1.ALPHA.concat(exports1.NUM);
        exports1.MARK = [
            '-',
            '_',
            '.',
            '!',
            '~',
            '*',
            '\'',
            '(',
            ')'
        ];
        exports1.USERINFO_CHARS = exports1.ALPHANUM.concat(exports1.MARK).concat([
            '%',
            ';',
            ':',
            '&',
            '=',
            '+',
            '$',
            ','
        ]);
        exports1.STRICT_URL_CHAR = [
            '!',
            '"',
            '$',
            '%',
            '&',
            '\'',
            '(',
            ')',
            '*',
            '+',
            ',',
            '-',
            '.',
            '/',
            ':',
            ';',
            '<',
            '=',
            '>',
            '@',
            '[',
            '\\',
            ']',
            '^',
            '_',
            '`',
            '{',
            '|',
            '}',
            '~'
        ].concat(exports1.ALPHANUM);
        exports1.URL_CHAR = exports1.STRICT_URL_CHAR.concat([
            '\t',
            '\f'
        ]);
        for(let i = 0x80; i <= 0xff; i++)exports1.URL_CHAR.push(i);
        exports1.HEX = exports1.NUM.concat([
            'a',
            'b',
            'c',
            'd',
            'e',
            'f',
            'A',
            'B',
            'C',
            'D',
            'E',
            'F'
        ]);
        exports1.STRICT_TOKEN = [
            '!',
            '#',
            '$',
            '%',
            '&',
            '\'',
            '*',
            '+',
            '-',
            '.',
            '^',
            '_',
            '`',
            '|',
            '~'
        ].concat(exports1.ALPHANUM);
        exports1.TOKEN = exports1.STRICT_TOKEN.concat([
            ' '
        ]);
        exports1.HEADER_CHARS = [
            '\t'
        ];
        for(let i = 32; i <= 255; i++)if (127 !== i) exports1.HEADER_CHARS.push(i);
        exports1.CONNECTION_TOKEN_CHARS = exports1.HEADER_CHARS.filter((c)=>44 !== c);
        exports1.MAJOR = exports1.NUM_MAP;
        exports1.MINOR = exports1.MAJOR;
        var HEADER_STATE;
        (function(HEADER_STATE) {
            HEADER_STATE[HEADER_STATE["GENERAL"] = 0] = "GENERAL";
            HEADER_STATE[HEADER_STATE["CONNECTION"] = 1] = "CONNECTION";
            HEADER_STATE[HEADER_STATE["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
            HEADER_STATE[HEADER_STATE["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
            HEADER_STATE[HEADER_STATE["UPGRADE"] = 4] = "UPGRADE";
            HEADER_STATE[HEADER_STATE["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
            HEADER_STATE[HEADER_STATE["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
            HEADER_STATE[HEADER_STATE["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
            HEADER_STATE[HEADER_STATE["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
        })(HEADER_STATE = exports1.HEADER_STATE || (exports1.HEADER_STATE = {}));
        exports1.SPECIAL_HEADERS = {
            connection: HEADER_STATE.CONNECTION,
            'content-length': HEADER_STATE.CONTENT_LENGTH,
            'proxy-connection': HEADER_STATE.CONNECTION,
            'transfer-encoding': HEADER_STATE.TRANSFER_ENCODING,
            upgrade: HEADER_STATE.UPGRADE
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/llhttp/llhttp-wasm.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { Buffer: Buffer1 } = __webpack_require__("node:buffer");
        module.exports = Buffer1.from('AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB9ysPC0GQMQ8LQdcxDwtBoi0PC0HUJw8LQeArDwtBnywPC0HrMQ8LQdUfDwtByjEPC0HeJQ8LQdQeDwtB9BwPC0GnMg8LQbEdDwtBoB0PC0G5MQ8LQbwwDwtBkiEPC0GzJg8LQeksDwtBrB4PC0HUKw8LQfcmDwtBgCYPC0GwIQ8LQf4eDwtBjSMPC0GJLQ8LQfciDwtBoDEPC0GuHw8LQcYlDwtB6B4PC0GTIg8LQcIvDwtBwx0PC0GLLA8LQeEdDwtBjS8PC0HqIQ8LQbQtDwtB0i8PC0HfMg8LQdIyDwtB8DAPC0GpIg8LQfkjDwtBmR4PC0G1LA8LQZswDwtBkjIPC0G2Kw8LQcIiDwtB+DIPC0GeJQ8LQdAiDwtBuh4PC0GBHg8LAAtB1iEhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBxhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9go2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7Ro2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBqhs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7RM2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBwhk2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlBQ2AhBBGCEECyAEC1kBAn8CQCAALQAoQQFGDQAgAC8BMiIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEwIgFBAnFFDQEMAgsgAC8BMCIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATIiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtXACAAQRhqQgA3AwAgAEIANwMAIABBOGpCADcDACAAQTBqQgA3AwAgAEEoakIANwMAIABBIGpCADcDACAAQRBqQgA3AwAgAEEIakIANwMAIABB3QE2AhwLBgAgABAyC5otAQt/IwBBEGsiCiQAQaTQACgCACIJRQRAQeTTACgCACIFRQRAQfDTAEJ/NwIAQejTAEKAgISAgIDAADcCAEHk0wAgCkEIakFwcUHYqtWqBXMiBTYCAEH40wBBADYCAEHI0wBBADYCAAtBzNMAQYDUBDYCAEGc0ABBgNQENgIAQbDQACAFNgIAQazQAEF/NgIAQdDTAEGArAM2AgADQCABQcjQAGogAUG80ABqIgI2AgAgAiABQbTQAGoiAzYCACABQcDQAGogAzYCACABQdDQAGogAUHE0ABqIgM2AgAgAyACNgIAIAFB2NAAaiABQczQAGoiAjYCACACIAM2AgAgAUHU0ABqIAI2AgAgAUEgaiIBQYACRw0AC0GM1ARBwasDNgIAQajQAEH00wAoAgA2AgBBmNAAQcCrAzYCAEGk0ABBiNQENgIAQcz/B0E4NgIAQYjUBCEJCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFNBEBBjNAAKAIAIgZBECAAQRNqQXBxIABBC0kbIgRBA3YiAHYiAUEDcQRAAkAgAUEBcSAAckEBcyICQQN0IgBBtNAAaiIBIABBvNAAaigCACIAKAIIIgNGBEBBjNAAIAZBfiACd3E2AgAMAQsgASADNgIIIAMgATYCDAsgAEEIaiEBIAAgAkEDdCICQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDBELQZTQACgCACIIIARPDQEgAQRAAkBBAiAAdCICQQAgAmtyIAEgAHRxaCIAQQN0IgJBtNAAaiIBIAJBvNAAaigCACICKAIIIgNGBEBBjNAAIAZBfiAAd3EiBjYCAAwBCyABIAM2AgggAyABNgIMCyACIARBA3I2AgQgAEEDdCIAIARrIQUgACACaiAFNgIAIAIgBGoiBCAFQQFyNgIEIAgEQCAIQXhxQbTQAGohAEGg0AAoAgAhAwJ/QQEgCEEDdnQiASAGcUUEQEGM0AAgASAGcjYCACAADAELIAAoAggLIgEgAzYCDCAAIAM2AgggAyAANgIMIAMgATYCCAsgAkEIaiEBQaDQACAENgIAQZTQACAFNgIADBELQZDQACgCACILRQ0BIAtoQQJ0QbzSAGooAgAiACgCBEF4cSAEayEFIAAhAgNAAkAgAigCECIBRQRAIAJBFGooAgAiAUUNAQsgASgCBEF4cSAEayIDIAVJIQIgAyAFIAIbIQUgASAAIAIbIQAgASECDAELCyAAKAIYIQkgACgCDCIDIABHBEBBnNAAKAIAGiADIAAoAggiATYCCCABIAM2AgwMEAsgAEEUaiICKAIAIgFFBEAgACgCECIBRQ0DIABBEGohAgsDQCACIQcgASIDQRRqIgIoAgAiAQ0AIANBEGohAiADKAIQIgENAAsgB0EANgIADA8LQX8hBCAAQb9/Sw0AIABBE2oiAUFwcSEEQZDQACgCACIIRQ0AQQAgBGshBQJAAkACQAJ/QQAgBEGAAkkNABpBHyAEQf///wdLDQAaIARBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmoLIgZBAnRBvNIAaigCACICRQRAQQAhAUEAIQMMAQtBACEBIARBGSAGQQF2a0EAIAZBH0cbdCEAQQAhAwNAAkAgAigCBEF4cSAEayIHIAVPDQAgAiEDIAciBQ0AQQAhBSACIQEMAwsgASACQRRqKAIAIgcgByACIABBHXZBBHFqQRBqKAIAIgJGGyABIAcbIQEgAEEBdCEAIAINAAsLIAEgA3JFBEBBACEDQQIgBnQiAEEAIABrciAIcSIARQ0DIABoQQJ0QbzSAGooAgAhAQsgAUUNAQsDQCABKAIEQXhxIARrIgIgBUkhACACIAUgABshBSABIAMgABshAyABKAIQIgAEfyAABSABQRRqKAIACyIBDQALCyADRQ0AIAVBlNAAKAIAIARrTw0AIAMoAhghByADIAMoAgwiAEcEQEGc0AAoAgAaIAAgAygCCCIBNgIIIAEgADYCDAwOCyADQRRqIgIoAgAiAUUEQCADKAIQIgFFDQMgA0EQaiECCwNAIAIhBiABIgBBFGoiAigCACIBDQAgAEEQaiECIAAoAhAiAQ0ACyAGQQA2AgAMDQtBlNAAKAIAIgMgBE8EQEGg0AAoAgAhAQJAIAMgBGsiAkEQTwRAIAEgBGoiACACQQFyNgIEIAEgA2ogAjYCACABIARBA3I2AgQMAQsgASADQQNyNgIEIAEgA2oiACAAKAIEQQFyNgIEQQAhAEEAIQILQZTQACACNgIAQaDQACAANgIAIAFBCGohAQwPC0GY0AAoAgAiAyAESwRAIAQgCWoiACADIARrIgFBAXI2AgRBpNAAIAA2AgBBmNAAIAE2AgAgCSAEQQNyNgIEIAlBCGohAQwPC0EAIQEgBAJ/QeTTACgCAARAQezTACgCAAwBC0Hw0wBCfzcCAEHo0wBCgICEgICAwAA3AgBB5NMAIApBDGpBcHFB2KrVqgVzNgIAQfjTAEEANgIAQcjTAEEANgIAQYCABAsiACAEQccAaiIFaiIGQQAgAGsiB3EiAk8EQEH80wBBMDYCAAwPCwJAQcTTACgCACIBRQ0AQbzTACgCACIIIAJqIQAgACABTSAAIAhLcQ0AQQAhAUH80wBBMDYCAAwPC0HI0wAtAABBBHENBAJAAkAgCQRAQczTACEBA0AgASgCACIAIAlNBEAgACABKAIEaiAJSw0DCyABKAIIIgENAAsLQQAQMyIAQX9GDQUgAiEGQejTACgCACIBQQFrIgMgAHEEQCACIABrIAAgA2pBACABa3FqIQYLIAQgBk8NBSAGQf7///8HSw0FQcTTACgCACIDBEBBvNMAKAIAIgcgBmohASABIAdNDQYgASADSw0GCyAGEDMiASAARw0BDAcLIAYgA2sgB3EiBkH+////B0sNBCAGEDMhACAAIAEoAgAgASgCBGpGDQMgACEBCwJAIAYgBEHIAGpPDQAgAUF/Rg0AQezTACgCACIAIAUgBmtqQQAgAGtxIgBB/v///wdLBEAgASEADAcLIAAQM0F/RwRAIAAgBmohBiABIQAMBwtBACAGaxAzGgwECyABIgBBf0cNBQwDC0EAIQMMDAtBACEADAoLIABBf0cNAgtByNMAQcjTACgCAEEEcjYCAAsgAkH+////B0sNASACEDMhAEEAEDMhASAAQX9GDQEgAUF/Rg0BIAAgAU8NASABIABrIgYgBEE4ak0NAQtBvNMAQbzTACgCACAGaiIBNgIAQcDTACgCACABSQRAQcDTACABNgIACwJAAkACQEGk0AAoAgAiAgRAQczTACEBA0AgACABKAIAIgMgASgCBCIFakYNAiABKAIIIgENAAsMAgtBnNAAKAIAIgFBAEcgACABT3FFBEBBnNAAIAA2AgALQQAhAUHQ0wAgBjYCAEHM0wAgADYCAEGs0ABBfzYCAEGw0ABB5NMAKAIANgIAQdjTAEEANgIAA0AgAUHI0ABqIAFBvNAAaiICNgIAIAIgAUG00ABqIgM2AgAgAUHA0ABqIAM2AgAgAUHQ0ABqIAFBxNAAaiIDNgIAIAMgAjYCACABQdjQAGogAUHM0ABqIgI2AgAgAiADNgIAIAFB1NAAaiACNgIAIAFBIGoiAUGAAkcNAAtBeCAAa0EPcSIBIABqIgIgBkE4ayIDIAFrIgFBAXI2AgRBqNAAQfTTACgCADYCAEGY0AAgATYCAEGk0AAgAjYCACAAIANqQTg2AgQMAgsgACACTQ0AIAIgA0kNACABKAIMQQhxDQBBeCACa0EPcSIAIAJqIgNBmNAAKAIAIAZqIgcgAGsiAEEBcjYCBCABIAUgBmo2AgRBqNAAQfTTACgCADYCAEGY0AAgADYCAEGk0AAgAzYCACACIAdqQTg2AgQMAQsgAEGc0AAoAgBJBEBBnNAAIAA2AgALIAAgBmohA0HM0wAhAQJAAkACQANAIAMgASgCAEcEQCABKAIIIgENAQwCCwsgAS0ADEEIcUUNAQtBzNMAIQEDQCABKAIAIgMgAk0EQCADIAEoAgRqIgUgAksNAwsgASgCCCEBDAALAAsgASAANgIAIAEgASgCBCAGajYCBCAAQXggAGtBD3FqIgkgBEEDcjYCBCADQXggA2tBD3FqIgYgBCAJaiIEayEBIAIgBkYEQEGk0AAgBDYCAEGY0ABBmNAAKAIAIAFqIgA2AgAgBCAAQQFyNgIEDAgLQaDQACgCACAGRgRAQaDQACAENgIAQZTQAEGU0AAoAgAgAWoiADYCACAEIABBAXI2AgQgACAEaiAANgIADAgLIAYoAgQiBUEDcUEBRw0GIAVBeHEhCCAFQf8BTQRAIAVBA3YhAyAGKAIIIgAgBigCDCICRgRAQYzQAEGM0AAoAgBBfiADd3E2AgAMBwsgAiAANgIIIAAgAjYCDAwGCyAGKAIYIQcgBiAGKAIMIgBHBEAgACAGKAIIIgI2AgggAiAANgIMDAULIAZBFGoiAigCACIFRQRAIAYoAhAiBUUNBCAGQRBqIQILA0AgAiEDIAUiAEEUaiICKAIAIgUNACAAQRBqIQIgACgCECIFDQALIANBADYCAAwEC0F4IABrQQ9xIgEgAGoiByAGQThrIgMgAWsiAUEBcjYCBCAAIANqQTg2AgQgAiAFQTcgBWtBD3FqQT9rIgMgAyACQRBqSRsiA0EjNgIEQajQAEH00wAoAgA2AgBBmNAAIAE2AgBBpNAAIAc2AgAgA0EQakHU0wApAgA3AgAgA0HM0wApAgA3AghB1NMAIANBCGo2AgBB0NMAIAY2AgBBzNMAIAA2AgBB2NMAQQA2AgAgA0EkaiEBA0AgAUEHNgIAIAUgAUEEaiIBSw0ACyACIANGDQAgAyADKAIEQX5xNgIEIAMgAyACayIFNgIAIAIgBUEBcjYCBCAFQf8BTQRAIAVBeHFBtNAAaiEAAn9BjNAAKAIAIgFBASAFQQN2dCIDcUUEQEGM0AAgASADcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbzSAGohAEGQ0AAoAgAiA0EBIAF0IgZxRQRAIAAgAjYCAEGQ0AAgAyAGcjYCACACIAA2AhggAiACNgIIIAIgAjYCDAwBCyAFQRkgAUEBdmtBACABQR9HG3QhASAAKAIAIQMCQANAIAMiACgCBEF4cSAFRg0BIAFBHXYhAyABQQF0IQEgACADQQRxakEQaiIGKAIAIgMNAAsgBiACNgIAIAIgADYCGCACIAI2AgwgAiACNgIIDAELIAAoAggiASACNgIMIAAgAjYCCCACQQA2AhggAiAANgIMIAIgATYCCAtBmNAAKAIAIgEgBE0NAEGk0AAoAgAiACAEaiICIAEgBGsiAUEBcjYCBEGY0AAgATYCAEGk0AAgAjYCACAAIARBA3I2AgQgAEEIaiEBDAgLQQAhAUH80wBBMDYCAAwHC0EAIQALIAdFDQACQCAGKAIcIgJBAnRBvNIAaiIDKAIAIAZGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAdBEEEUIAcoAhAgBkYbaiAANgIAIABFDQELIAAgBzYCGCAGKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAGQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAIaiEBIAYgCGoiBigCBCEFCyAGIAVBfnE2AgQgASAEaiABNgIAIAQgAUEBcjYCBCABQf8BTQRAIAFBeHFBtNAAaiEAAn9BjNAAKAIAIgJBASABQQN2dCIBcUUEQEGM0AAgASACcjYCACAADAELIAAoAggLIgEgBDYCDCAAIAQ2AgggBCAANgIMIAQgATYCCAwBC0EfIQUgAUH///8HTQRAIAFBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmohBQsgBCAFNgIcIARCADcCECAFQQJ0QbzSAGohAEGQ0AAoAgAiAkEBIAV0IgNxRQRAIAAgBDYCAEGQ0AAgAiADcjYCACAEIAA2AhggBCAENgIIIAQgBDYCDAwBCyABQRkgBUEBdmtBACAFQR9HG3QhBSAAKAIAIQACQANAIAAiAigCBEF4cSABRg0BIAVBHXYhACAFQQF0IQUgAiAAQQRxakEQaiIDKAIAIgANAAsgAyAENgIAIAQgAjYCGCAEIAQ2AgwgBCAENgIIDAELIAIoAggiACAENgIMIAIgBDYCCCAEQQA2AhggBCACNgIMIAQgADYCCAsgCUEIaiEBDAILAkAgB0UNAAJAIAMoAhwiAUECdEG80gBqIgIoAgAgA0YEQCACIAA2AgAgAA0BQZDQACAIQX4gAXdxIgg2AgAMAgsgB0EQQRQgBygCECADRhtqIAA2AgAgAEUNAQsgACAHNgIYIAMoAhAiAQRAIAAgATYCECABIAA2AhgLIANBFGooAgAiAUUNACAAQRRqIAE2AgAgASAANgIYCwJAIAVBD00EQCADIAQgBWoiAEEDcjYCBCAAIANqIgAgACgCBEEBcjYCBAwBCyADIARqIgIgBUEBcjYCBCADIARBA3I2AgQgAiAFaiAFNgIAIAVB/wFNBEAgBUF4cUG00ABqIQACf0GM0AAoAgAiAUEBIAVBA3Z0IgVxRQRAQYzQACABIAVyNgIAIAAMAQsgACgCCAsiASACNgIMIAAgAjYCCCACIAA2AgwgAiABNgIIDAELQR8hASAFQf///wdNBEAgBUEmIAVBCHZnIgBrdkEBcSAAQQF0a0E+aiEBCyACIAE2AhwgAkIANwIQIAFBAnRBvNIAaiEAQQEgAXQiBCAIcUUEQCAAIAI2AgBBkNAAIAQgCHI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEEAkADQCAEIgAoAgRBeHEgBUYNASABQR12IQQgAUEBdCEBIAAgBEEEcWpBEGoiBigCACIEDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLIANBCGohAQwBCwJAIAlFDQACQCAAKAIcIgFBAnRBvNIAaiICKAIAIABGBEAgAiADNgIAIAMNAUGQ0AAgC0F+IAF3cTYCAAwCCyAJQRBBFCAJKAIQIABGG2ogAzYCACADRQ0BCyADIAk2AhggACgCECIBBEAgAyABNgIQIAEgAzYCGAsgAEEUaigCACIBRQ0AIANBFGogATYCACABIAM2AhgLAkAgBUEPTQRAIAAgBCAFaiIBQQNyNgIEIAAgAWoiASABKAIEQQFyNgIEDAELIAAgBGoiByAFQQFyNgIEIAAgBEEDcjYCBCAFIAdqIAU2AgAgCARAIAhBeHFBtNAAaiEBQaDQACgCACEDAn9BASAIQQN2dCICIAZxRQRAQYzQACACIAZyNgIAIAEMAQsgASgCCAsiAiADNgIMIAEgAzYCCCADIAE2AgwgAyACNgIIC0Gg0AAgBzYCAEGU0AAgBTYCAAsgAEEIaiEBCyAKQRBqJAAgAQtDACAARQRAPwBBEHQPCwJAIABB//8DcQ0AIABBAEgNACAAQRB2QAAiAEF/RgRAQfzTAEEwNgIAQX8PCyAAQRB0DwsACwvcPyIAQYAICwkBAAAAAgAAAAMAQZQICwUEAAAABQBBpAgLCQYAAAAHAAAACABB3AgLii1JbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AFJlc3BvbnNlIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fbWV0aG9kAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAF4TAAAmEwAAMBAAAPAXAACdEwAAFRIAADkXAADwEgAAChAAAHUSAACtEgAAghMAAE8UAAB/EAAAoBUAACMUAACJEgAAixQAAE0VAADUEQAAzxQAABAYAADJFgAA3BYAAMERAADgFwAAuxQAAHQUAAB8FQAA5RQAAAgXAAAfEAAAZRUAAKMUAAAoFQAAAhUAAJkVAAAsEAAAixkAAE8PAADUDgAAahAAAM4QAAACFwAAiQ4AAG4TAAAcEwAAZhQAAFYXAADBEwAAzRMAAGwTAABoFwAAZhcAAF8XAAAiEwAAzg8AAGkOAADYDgAAYxYAAMsTAACqDgAAKBcAACYXAADFEwAAXRYAAOgRAABnEwAAZRMAAPIWAABzEwAAHRcAAPkWAADzEQAAzw4AAM4VAAAMEgAAsxEAAKURAABhEAAAMhcAALsTAEH5NQsBAQBBkDYL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB/TcLAQEAQZE4C14CAwICAgICAAACAgACAgACAgICAgICAgICAAQAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEH9OQsBAQBBkToLXgIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAQfA7Cw1sb3NlZWVwLWFsaXZlAEGJPAsBAQBBoDwL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBiT4LAQEAQaA+C+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGwwAALXwEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGQwgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBwMIACy1yYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AQfnCAAsFAQIAAQMAQZDDAAvgAQQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5xAALBQECAAEDAEGQxQAL4AEEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cYACwQBAAABAEGRxwAL3wEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH6yAALBAEAAAIAQZDJAAtfAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAQfrKAAsEAQAAAQBBkMsACwEBAEGqywALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEH6zAALBAEAAAEAQZDNAAsBAQBBms0ACwYCAAAAAAIAQbHNAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB8M4AC5YBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv', 'base64');
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { Buffer: Buffer1 } = __webpack_require__("node:buffer");
        module.exports = Buffer1.from('AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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AAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4otSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwBB+TULAQEAQZA2C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQf03CwEBAEGROAteAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgBB/TkLAQEAQZE6C14CAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEHwOwsNbG9zZWVlcC1hbGl2ZQBBiTwLAQEAQaA8C+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQYk+CwEBAEGgPgvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBsMAAC18BAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBBkMIACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQcDCAAstcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAEH5wgALBQECAAEDAEGQwwAL4AEEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cQACwUBAgABAwBBkMUAC+ABBAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnGAAsEAQAAAQBBkccAC98BAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+sgACwQBAAACAEGQyQALXwMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAEH6ygALBAEAAAEAQZDLAAsBAQBBqssAC0ECAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB+swACwQBAAABAEGQzQALAQEAQZrNAAsGAgAAAAACAEGxzQALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQfDOAAuWAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==', 'base64');
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/llhttp/utils.js" (__unused_rspack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.enumToMap = void 0;
        function enumToMap(obj) {
            const res = {};
            Object.keys(obj).forEach((key)=>{
                const value = obj[key];
                if ('number' == typeof value) res[key] = value;
            });
            return res;
        }
        exports1.enumToMap = enumToMap;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-agent.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { kClients } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const Agent = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/agent.js");
        const { kAgent, kMockAgentSet, kMockAgentGet, kDispatches, kIsMockActive, kNetConnect, kGetNetConnect, kOptions, kFactory } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-symbols.js");
        const MockClient = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-client.js");
        const MockPool = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-pool.js");
        const { matchValue, buildMockOptions } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-utils.js");
        const { InvalidArgumentError, UndiciError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const Dispatcher = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/dispatcher.js");
        const Pluralizer = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/pluralizer.js");
        const PendingInterceptorsFormatter = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js");
        class MockAgent extends Dispatcher {
            constructor(opts){
                super(opts);
                this[kNetConnect] = true;
                this[kIsMockActive] = true;
                if (opts?.agent && 'function' != typeof opts.agent.dispatch) throw new InvalidArgumentError('Argument opts.agent must implement Agent');
                const agent = opts?.agent ? opts.agent : new Agent(opts);
                this[kAgent] = agent;
                this[kClients] = agent[kClients];
                this[kOptions] = buildMockOptions(opts);
            }
            get(origin) {
                let dispatcher = this[kMockAgentGet](origin);
                if (!dispatcher) {
                    dispatcher = this[kFactory](origin);
                    this[kMockAgentSet](origin, dispatcher);
                }
                return dispatcher;
            }
            dispatch(opts, handler) {
                this.get(opts.origin);
                return this[kAgent].dispatch(opts, handler);
            }
            async close() {
                await this[kAgent].close();
                this[kClients].clear();
            }
            deactivate() {
                this[kIsMockActive] = false;
            }
            activate() {
                this[kIsMockActive] = true;
            }
            enableNetConnect(matcher) {
                if ('string' == typeof matcher || 'function' == typeof matcher || matcher instanceof RegExp) if (Array.isArray(this[kNetConnect])) this[kNetConnect].push(matcher);
                else this[kNetConnect] = [
                    matcher
                ];
                else if (void 0 === matcher) this[kNetConnect] = true;
                else throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.');
            }
            disableNetConnect() {
                this[kNetConnect] = false;
            }
            get isMockActive() {
                return this[kIsMockActive];
            }
            [kMockAgentSet](origin, dispatcher) {
                this[kClients].set(origin, dispatcher);
            }
            [kFactory](origin) {
                const mockOptions = Object.assign({
                    agent: this
                }, this[kOptions]);
                return this[kOptions] && 1 === this[kOptions].connections ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
            }
            [kMockAgentGet](origin) {
                const client = this[kClients].get(origin);
                if (client) return client;
                if ('string' != typeof origin) {
                    const dispatcher = this[kFactory]('http://localhost:9999');
                    this[kMockAgentSet](origin, dispatcher);
                    return dispatcher;
                }
                for (const [keyMatcher, nonExplicitDispatcher] of Array.from(this[kClients]))if (nonExplicitDispatcher && 'string' != typeof keyMatcher && matchValue(keyMatcher, origin)) {
                    const dispatcher = this[kFactory](origin);
                    this[kMockAgentSet](origin, dispatcher);
                    dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
                    return dispatcher;
                }
            }
            [kGetNetConnect]() {
                return this[kNetConnect];
            }
            pendingInterceptors() {
                const mockAgentClients = this[kClients];
                return Array.from(mockAgentClients.entries()).flatMap(([origin, scope])=>scope[kDispatches].map((dispatch)=>({
                            ...dispatch,
                            origin
                        }))).filter(({ pending })=>pending);
            }
            assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
                const pending = this.pendingInterceptors();
                if (0 === pending.length) return;
                const pluralizer = new Pluralizer('interceptor', 'interceptors').pluralize(pending.length);
                throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
            }
        }
        module.exports = MockAgent;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-client.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { promisify } = __webpack_require__("node:util");
        const Client = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/client.js");
        const { buildMockDispatch } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-utils.js");
        const { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-symbols.js");
        const { MockInterceptor } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-interceptor.js");
        const Symbols = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const { InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        class MockClient extends Client {
            constructor(origin, opts){
                super(origin, opts);
                if (!opts || !opts.agent || 'function' != typeof opts.agent.dispatch) throw new InvalidArgumentError('Argument opts.agent must implement Agent');
                this[kMockAgent] = opts.agent;
                this[kOrigin] = origin;
                this[kDispatches] = [];
                this[kConnected] = 1;
                this[kOriginalDispatch] = this.dispatch;
                this[kOriginalClose] = this.close.bind(this);
                this.dispatch = buildMockDispatch.call(this);
                this.close = this[kClose];
            }
            get [Symbols.kConnected]() {
                return this[kConnected];
            }
            intercept(opts) {
                return new MockInterceptor(opts, this[kDispatches]);
            }
            async [kClose]() {
                await promisify(this[kOriginalClose])();
                this[kConnected] = 0;
                this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
            }
        }
        module.exports = MockClient;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-errors.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { UndiciError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const kMockNotMatchedError = Symbol.for('undici.error.UND_MOCK_ERR_MOCK_NOT_MATCHED');
        class MockNotMatchedError extends UndiciError {
            constructor(message){
                super(message);
                Error.captureStackTrace(this, MockNotMatchedError);
                this.name = 'MockNotMatchedError';
                this.message = message || 'The request does not match any registered mock dispatches';
                this.code = 'UND_MOCK_ERR_MOCK_NOT_MATCHED';
            }
            static [Symbol.hasInstance](instance) {
                return instance && true === instance[kMockNotMatchedError];
            }
            [kMockNotMatchedError] = true;
        }
        module.exports = {
            MockNotMatchedError
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-interceptor.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { getResponseData, buildKey, addMockDispatch } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-utils.js");
        const { kDispatches, kDispatchKey, kDefaultHeaders, kDefaultTrailers, kContentLength, kMockDispatch } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-symbols.js");
        const { InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        const { buildURL } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        class MockScope {
            constructor(mockDispatch){
                this[kMockDispatch] = mockDispatch;
            }
            delay(waitInMs) {
                if ('number' != typeof waitInMs || !Number.isInteger(waitInMs) || waitInMs <= 0) throw new InvalidArgumentError('waitInMs must be a valid integer > 0');
                this[kMockDispatch].delay = waitInMs;
                return this;
            }
            persist() {
                this[kMockDispatch].persist = true;
                return this;
            }
            times(repeatTimes) {
                if ('number' != typeof repeatTimes || !Number.isInteger(repeatTimes) || repeatTimes <= 0) throw new InvalidArgumentError('repeatTimes must be a valid integer > 0');
                this[kMockDispatch].times = repeatTimes;
                return this;
            }
        }
        class MockInterceptor {
            constructor(opts, mockDispatches){
                if ('object' != typeof opts) throw new InvalidArgumentError('opts must be an object');
                if (void 0 === opts.path) throw new InvalidArgumentError('opts.path must be defined');
                if (void 0 === opts.method) opts.method = 'GET';
                if ('string' == typeof opts.path) if (opts.query) opts.path = buildURL(opts.path, opts.query);
                else {
                    const parsedURL = new URL(opts.path, 'data://');
                    opts.path = parsedURL.pathname + parsedURL.search;
                }
                if ('string' == typeof opts.method) opts.method = opts.method.toUpperCase();
                this[kDispatchKey] = buildKey(opts);
                this[kDispatches] = mockDispatches;
                this[kDefaultHeaders] = {};
                this[kDefaultTrailers] = {};
                this[kContentLength] = false;
            }
            createMockScopeDispatchData({ statusCode, data, responseOptions }) {
                const responseData = getResponseData(data);
                const contentLength = this[kContentLength] ? {
                    'content-length': responseData.length
                } : {};
                const headers = {
                    ...this[kDefaultHeaders],
                    ...contentLength,
                    ...responseOptions.headers
                };
                const trailers = {
                    ...this[kDefaultTrailers],
                    ...responseOptions.trailers
                };
                return {
                    statusCode,
                    data,
                    headers,
                    trailers
                };
            }
            validateReplyParameters(replyParameters) {
                if (void 0 === replyParameters.statusCode) throw new InvalidArgumentError('statusCode must be defined');
                if ('object' != typeof replyParameters.responseOptions || null === replyParameters.responseOptions) throw new InvalidArgumentError('responseOptions must be an object');
            }
            reply(replyOptionsCallbackOrStatusCode) {
                if ('function' == typeof replyOptionsCallbackOrStatusCode) {
                    const wrappedDefaultsCallback = (opts)=>{
                        const resolvedData = replyOptionsCallbackOrStatusCode(opts);
                        if ('object' != typeof resolvedData || null === resolvedData) throw new InvalidArgumentError('reply options callback must return an object');
                        const replyParameters = {
                            data: '',
                            responseOptions: {},
                            ...resolvedData
                        };
                        this.validateReplyParameters(replyParameters);
                        return {
                            ...this.createMockScopeDispatchData(replyParameters)
                        };
                    };
                    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
                    return new MockScope(newMockDispatch);
                }
                const replyParameters = {
                    statusCode: replyOptionsCallbackOrStatusCode,
                    data: void 0 === arguments[1] ? '' : arguments[1],
                    responseOptions: void 0 === arguments[2] ? {} : arguments[2]
                };
                this.validateReplyParameters(replyParameters);
                const dispatchData = this.createMockScopeDispatchData(replyParameters);
                const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
                return new MockScope(newMockDispatch);
            }
            replyWithError(error) {
                if (void 0 === error) throw new InvalidArgumentError('error must be defined');
                const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], {
                    error
                });
                return new MockScope(newMockDispatch);
            }
            defaultReplyHeaders(headers) {
                if (void 0 === headers) throw new InvalidArgumentError('headers must be defined');
                this[kDefaultHeaders] = headers;
                return this;
            }
            defaultReplyTrailers(trailers) {
                if (void 0 === trailers) throw new InvalidArgumentError('trailers must be defined');
                this[kDefaultTrailers] = trailers;
                return this;
            }
            replyContentLength() {
                this[kContentLength] = true;
                return this;
            }
        }
        module.exports.MockInterceptor = MockInterceptor;
        module.exports.MockScope = MockScope;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-pool.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { promisify } = __webpack_require__("node:util");
        const Pool = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/pool.js");
        const { buildMockDispatch } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-utils.js");
        const { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-symbols.js");
        const { MockInterceptor } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-interceptor.js");
        const Symbols = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const { InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/errors.js");
        class MockPool extends Pool {
            constructor(origin, opts){
                super(origin, opts);
                if (!opts || !opts.agent || 'function' != typeof opts.agent.dispatch) throw new InvalidArgumentError('Argument opts.agent must implement Agent');
                this[kMockAgent] = opts.agent;
                this[kOrigin] = origin;
                this[kDispatches] = [];
                this[kConnected] = 1;
                this[kOriginalDispatch] = this.dispatch;
                this[kOriginalClose] = this.close.bind(this);
                this.dispatch = buildMockDispatch.call(this);
                this.close = this[kClose];
            }
            get [Symbols.kConnected]() {
                return this[kConnected];
            }
            intercept(opts) {
                return new MockInterceptor(opts, this[kDispatches]);
            }
            async [kClose]() {
                await promisify(this[kOriginalClose])();
                this[kConnected] = 0;
                this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
            }
        }
        module.exports = MockPool;
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-symbols.js" (module) {
        "use strict";
        module.exports = {
            kAgent: Symbol('agent'),
            kOptions: Symbol('options'),
            kFactory: Symbol('factory'),
            kDispatches: Symbol('dispatches'),
            kDispatchKey: Symbol('dispatch key'),
            kDefaultHeaders: Symbol('default headers'),
            kDefaultTrailers: Symbol('default trailers'),
            kContentLength: Symbol('content length'),
            kMockAgent: Symbol('mock agent'),
            kMockAgentSet: Symbol('mock agent set'),
            kMockAgentGet: Symbol('mock agent get'),
            kMockDispatch: Symbol('mock dispatch'),
            kClose: Symbol('close'),
            kOriginalClose: Symbol('original agent close'),
            kOrigin: Symbol('origin'),
            kIsMockActive: Symbol('is mock active'),
            kNetConnect: Symbol('net connect'),
            kGetNetConnect: Symbol('get net connect'),
            kConnected: Symbol('connected')
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-utils.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { MockNotMatchedError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-errors.js");
        const { kDispatches, kMockAgent, kOriginalDispatch, kOrigin, kGetNetConnect } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/mock-symbols.js");
        const { buildURL } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { STATUS_CODES } = __webpack_require__("node:http");
        const { types: { isPromise } } = __webpack_require__("node:util");
        function matchValue(match, value) {
            if ('string' == typeof match) return match === value;
            if (match instanceof RegExp) return match.test(value);
            if ('function' == typeof match) return true === match(value);
            return false;
        }
        function lowerCaseEntries(headers) {
            return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue])=>[
                    headerName.toLocaleLowerCase(),
                    headerValue
                ]));
        }
        function getHeaderByName(headers, key) {
            if (Array.isArray(headers)) {
                for(let i = 0; i < headers.length; i += 2)if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) return headers[i + 1];
                return;
            }
            if ('function' == typeof headers.get) return headers.get(key);
            return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
        }
        function buildHeadersFromArray(headers) {
            const clone = headers.slice();
            const entries = [];
            for(let index = 0; index < clone.length; index += 2)entries.push([
                clone[index],
                clone[index + 1]
            ]);
            return Object.fromEntries(entries);
        }
        function matchHeaders(mockDispatch, headers) {
            if ('function' == typeof mockDispatch.headers) {
                if (Array.isArray(headers)) headers = buildHeadersFromArray(headers);
                return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {});
            }
            if (void 0 === mockDispatch.headers) return true;
            if ('object' != typeof headers || 'object' != typeof mockDispatch.headers) return false;
            for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)){
                const headerValue = getHeaderByName(headers, matchHeaderName);
                if (!matchValue(matchHeaderValue, headerValue)) return false;
            }
            return true;
        }
        function safeUrl(path) {
            if ('string' != typeof path) return path;
            const pathSegments = path.split('?');
            if (2 !== pathSegments.length) return path;
            const qp = new URLSearchParams(pathSegments.pop());
            qp.sort();
            return [
                ...pathSegments,
                qp.toString()
            ].join('?');
        }
        function matchKey(mockDispatch, { path, method, body, headers }) {
            const pathMatch = matchValue(mockDispatch.path, path);
            const methodMatch = matchValue(mockDispatch.method, method);
            const bodyMatch = void 0 !== mockDispatch.body ? matchValue(mockDispatch.body, body) : true;
            const headersMatch = matchHeaders(mockDispatch, headers);
            return pathMatch && methodMatch && bodyMatch && headersMatch;
        }
        function getResponseData(data) {
            if (Buffer.isBuffer(data)) return data;
            if (data instanceof Uint8Array) return data;
            if (data instanceof ArrayBuffer) return data;
            if ('object' == typeof data) return JSON.stringify(data);
            return data.toString();
        }
        function getMockDispatch(mockDispatches, key) {
            const basePath = key.query ? buildURL(key.path, key.query) : key.path;
            const resolvedPath = 'string' == typeof basePath ? safeUrl(basePath) : basePath;
            let matchedMockDispatches = mockDispatches.filter(({ consumed })=>!consumed).filter(({ path })=>matchValue(safeUrl(path), resolvedPath));
            if (0 === matchedMockDispatches.length) throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
            matchedMockDispatches = matchedMockDispatches.filter(({ method })=>matchValue(method, key.method));
            if (0 === matchedMockDispatches.length) throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`);
            matchedMockDispatches = matchedMockDispatches.filter(({ body })=>void 0 !== body ? matchValue(body, key.body) : true);
            if (0 === matchedMockDispatches.length) throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`);
            matchedMockDispatches = matchedMockDispatches.filter((mockDispatch)=>matchHeaders(mockDispatch, key.headers));
            if (0 === matchedMockDispatches.length) {
                const headers = 'object' == typeof key.headers ? JSON.stringify(key.headers) : key.headers;
                throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`);
            }
            return matchedMockDispatches[0];
        }
        function addMockDispatch(mockDispatches, key, data) {
            const baseData = {
                timesInvoked: 0,
                times: 1,
                persist: false,
                consumed: false
            };
            const replyData = 'function' == typeof data ? {
                callback: data
            } : {
                ...data
            };
            const newMockDispatch = {
                ...baseData,
                ...key,
                pending: true,
                data: {
                    error: null,
                    ...replyData
                }
            };
            mockDispatches.push(newMockDispatch);
            return newMockDispatch;
        }
        function deleteMockDispatch(mockDispatches, key) {
            const index = mockDispatches.findIndex((dispatch)=>{
                if (!dispatch.consumed) return false;
                return matchKey(dispatch, key);
            });
            if (-1 !== index) mockDispatches.splice(index, 1);
        }
        function buildKey(opts) {
            const { path, method, body, headers, query } = opts;
            return {
                path,
                method,
                body,
                headers,
                query
            };
        }
        function generateKeyValues(data) {
            const keys = Object.keys(data);
            const result = [];
            for(let i = 0; i < keys.length; ++i){
                const key = keys[i];
                const value = data[key];
                const name = Buffer.from(`${key}`);
                if (Array.isArray(value)) for(let j = 0; j < value.length; ++j)result.push(name, Buffer.from(`${value[j]}`));
                else result.push(name, Buffer.from(`${value}`));
            }
            return result;
        }
        function getStatusText(statusCode) {
            return STATUS_CODES[statusCode] || 'unknown';
        }
        async function getResponse(body) {
            const buffers = [];
            for await (const data of body)buffers.push(data);
            return Buffer.concat(buffers).toString('utf8');
        }
        function mockDispatch(opts, handler) {
            const key = buildKey(opts);
            const mockDispatch = getMockDispatch(this[kDispatches], key);
            mockDispatch.timesInvoked++;
            if (mockDispatch.data.callback) mockDispatch.data = {
                ...mockDispatch.data,
                ...mockDispatch.data.callback(opts)
            };
            const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch;
            const { timesInvoked, times } = mockDispatch;
            mockDispatch.consumed = !persist && timesInvoked >= times;
            mockDispatch.pending = timesInvoked < times;
            if (null !== error) {
                deleteMockDispatch(this[kDispatches], key);
                handler.onError(error);
                return true;
            }
            if ('number' == typeof delay && delay > 0) setTimeout(()=>{
                handleReply(this[kDispatches]);
            }, delay);
            else handleReply(this[kDispatches]);
            function handleReply(mockDispatches, _data = data) {
                const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
                const body = 'function' == typeof _data ? _data({
                    ...opts,
                    headers: optsHeaders
                }) : _data;
                if (isPromise(body)) return void body.then((newData)=>handleReply(mockDispatches, newData));
                const responseData = getResponseData(body);
                const responseHeaders = generateKeyValues(headers);
                const responseTrailers = generateKeyValues(trailers);
                handler.onConnect?.((err)=>handler.onError(err), null);
                handler.onHeaders?.(statusCode, responseHeaders, resume, getStatusText(statusCode));
                handler.onData?.(Buffer.from(responseData));
                handler.onComplete?.(responseTrailers);
                deleteMockDispatch(mockDispatches, key);
            }
            function resume() {}
            return true;
        }
        function buildMockDispatch() {
            const agent = this[kMockAgent];
            const origin = this[kOrigin];
            const originalDispatch = this[kOriginalDispatch];
            return function(opts, handler) {
                if (agent.isMockActive) try {
                    mockDispatch.call(this, opts, handler);
                } catch (error) {
                    if (error instanceof MockNotMatchedError) {
                        const netConnect = agent[kGetNetConnect]();
                        if (false === netConnect) throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
                        if (checkNetConnect(netConnect, origin)) originalDispatch.call(this, opts, handler);
                        else throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
                    } else throw error;
                }
                else originalDispatch.call(this, opts, handler);
            };
        }
        function checkNetConnect(netConnect, origin) {
            const url = new URL(origin);
            if (true === netConnect) return true;
            if (Array.isArray(netConnect) && netConnect.some((matcher)=>matchValue(matcher, url.host))) return true;
            return false;
        }
        function buildMockOptions(opts) {
            if (opts) {
                const { agent, ...mockOptions } = opts;
                return mockOptions;
            }
        }
        module.exports = {
            getResponseData,
            getMockDispatch,
            addMockDispatch,
            deleteMockDispatch,
            buildKey,
            generateKeyValues,
            matchValue,
            getResponse,
            getStatusText,
            mockDispatch,
            buildMockDispatch,
            checkNetConnect,
            buildMockOptions,
            getHeaderByName,
            buildHeadersFromArray
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { Transform } = __webpack_require__("node:stream");
        const { Console } = __webpack_require__("node:console");
        const PERSISTENT = process.versions.icu ? '' : 'Y ';
        const NOT_PERSISTENT = process.versions.icu ? '' : 'N ';
        module.exports = class {
            constructor({ disableColors } = {}){
                this.transform = new Transform({
                    transform (chunk, _enc, cb) {
                        cb(null, chunk);
                    }
                });
                this.logger = new Console({
                    stdout: this.transform,
                    inspectOptions: {
                        colors: !disableColors && !process.env.CI
                    }
                });
            }
            format(pendingInterceptors) {
                const withPrettyHeaders = pendingInterceptors.map(({ method, path, data: { statusCode }, persist, times, timesInvoked, origin })=>({
                        Method: method,
                        Origin: origin,
                        Path: path,
                        'Status code': statusCode,
                        Persistent: persist ? PERSISTENT : NOT_PERSISTENT,
                        Invocations: timesInvoked,
                        Remaining: persist ? 1 / 0 : times - timesInvoked
                    }));
                this.logger.table(withPrettyHeaders);
                return this.transform.read().toString();
            }
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/mock/pluralizer.js" (module) {
        "use strict";
        const singulars = {
            pronoun: 'it',
            is: 'is',
            was: 'was',
            this: 'this'
        };
        const plurals = {
            pronoun: 'they',
            is: 'are',
            was: 'were',
            this: 'these'
        };
        module.exports = class {
            constructor(singular, plural){
                this.singular = singular;
                this.plural = plural;
            }
            pluralize(count) {
                const one = 1 === count;
                const keys = one ? singulars : plurals;
                const noun = one ? this.singular : this.plural;
                return {
                    ...keys,
                    count,
                    noun
                };
            }
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/util/timers.js" (module) {
        "use strict";
        let fastNow = 0;
        const RESOLUTION_MS = 1e3;
        const TICK_MS = (RESOLUTION_MS >> 1) - 1;
        let fastNowTimeout;
        const kFastTimer = Symbol('kFastTimer');
        const fastTimers = [];
        const NOT_IN_LIST = -2;
        const TO_BE_CLEARED = -1;
        const PENDING = 0;
        const ACTIVE = 1;
        function onTick() {
            fastNow += TICK_MS;
            let idx = 0;
            let len = fastTimers.length;
            while(idx < len){
                const timer = fastTimers[idx];
                if (timer._state === PENDING) {
                    timer._idleStart = fastNow - TICK_MS;
                    timer._state = ACTIVE;
                } else if (timer._state === ACTIVE && fastNow >= timer._idleStart + timer._idleTimeout) {
                    timer._state = TO_BE_CLEARED;
                    timer._idleStart = -1;
                    timer._onTimeout(timer._timerArg);
                }
                if (timer._state === TO_BE_CLEARED) {
                    timer._state = NOT_IN_LIST;
                    if (0 !== --len) fastTimers[idx] = fastTimers[len];
                } else ++idx;
            }
            fastTimers.length = len;
            if (0 !== fastTimers.length) refreshTimeout();
        }
        function refreshTimeout() {
            if (fastNowTimeout) fastNowTimeout.refresh();
            else {
                clearTimeout(fastNowTimeout);
                fastNowTimeout = setTimeout(onTick, TICK_MS);
                if (fastNowTimeout.unref) fastNowTimeout.unref();
            }
        }
        class FastTimer {
            [kFastTimer] = true;
            _state = NOT_IN_LIST;
            _idleTimeout = -1;
            _idleStart = -1;
            _onTimeout;
            _timerArg;
            constructor(callback, delay, arg){
                this._onTimeout = callback;
                this._idleTimeout = delay;
                this._timerArg = arg;
                this.refresh();
            }
            refresh() {
                if (this._state === NOT_IN_LIST) fastTimers.push(this);
                if (!fastNowTimeout || 1 === fastTimers.length) refreshTimeout();
                this._state = PENDING;
            }
            clear() {
                this._state = TO_BE_CLEARED;
                this._idleStart = -1;
            }
        }
        module.exports = {
            setTimeout (callback, delay, arg) {
                return delay <= RESOLUTION_MS ? setTimeout(callback, delay, arg) : new FastTimer(callback, delay, arg);
            },
            clearTimeout (timeout) {
                if (timeout[kFastTimer]) timeout.clear();
                else clearTimeout(timeout);
            },
            setFastTimeout (callback, delay, arg) {
                return new FastTimer(callback, delay, arg);
            },
            clearFastTimeout (timeout) {
                timeout.clear();
            },
            now () {
                return fastNow;
            },
            tick (delay = 0) {
                fastNow += delay - RESOLUTION_MS + 1;
                onTick();
                onTick();
            },
            reset () {
                fastNow = 0;
                fastTimers.length = 0;
                clearTimeout(fastNowTimeout);
                fastNowTimeout = null;
            },
            kFastTimer
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cache/cache.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { kConstruct } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cache/symbols.js");
        const { urlEquals, getFieldValues } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cache/util.js");
        const { kEnumerableProperty, isDisturbed } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/webidl.js");
        const { Response, cloneResponse, fromInnerResponse } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/response.js");
        const { Request, fromInnerRequest } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/request.js");
        const { kState } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/symbols.js");
        const { fetching } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/index.js");
        const { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/util.js");
        const assert = __webpack_require__("node:assert");
        class Cache {
            #relevantRequestResponseList;
            constructor(){
                if (arguments[0] !== kConstruct) webidl.illegalConstructor();
                webidl.util.markAsUncloneable(this);
                this.#relevantRequestResponseList = arguments[1];
            }
            async match(request, options = {}) {
                webidl.brandCheck(this, Cache);
                const prefix = 'Cache.match';
                webidl.argumentLengthCheck(arguments, 1, prefix);
                request = webidl.converters.RequestInfo(request, prefix, 'request');
                options = webidl.converters.CacheQueryOptions(options, prefix, 'options');
                const p = this.#internalMatchAll(request, options, 1);
                if (0 === p.length) return;
                return p[0];
            }
            async matchAll(request, options = {}) {
                webidl.brandCheck(this, Cache);
                const prefix = 'Cache.matchAll';
                if (void 0 !== request) request = webidl.converters.RequestInfo(request, prefix, 'request');
                options = webidl.converters.CacheQueryOptions(options, prefix, 'options');
                return this.#internalMatchAll(request, options);
            }
            async add(request) {
                webidl.brandCheck(this, Cache);
                const prefix = 'Cache.add';
                webidl.argumentLengthCheck(arguments, 1, prefix);
                request = webidl.converters.RequestInfo(request, prefix, 'request');
                const requests = [
                    request
                ];
                const responseArrayPromise = this.addAll(requests);
                return await responseArrayPromise;
            }
            async addAll(requests) {
                webidl.brandCheck(this, Cache);
                const prefix = 'Cache.addAll';
                webidl.argumentLengthCheck(arguments, 1, prefix);
                const responsePromises = [];
                const requestList = [];
                for (let request of requests){
                    if (void 0 === request) throw webidl.errors.conversionFailed({
                        prefix,
                        argument: 'Argument 1',
                        types: [
                            'undefined is not allowed'
                        ]
                    });
                    request = webidl.converters.RequestInfo(request);
                    if ('string' == typeof request) continue;
                    const r = request[kState];
                    if (!urlIsHttpHttpsScheme(r.url) || 'GET' !== r.method) throw webidl.errors.exception({
                        header: prefix,
                        message: 'Expected http/s scheme when method is not GET.'
                    });
                }
                const fetchControllers = [];
                for (const request of requests){
                    const r = new Request(request)[kState];
                    if (!urlIsHttpHttpsScheme(r.url)) throw webidl.errors.exception({
                        header: prefix,
                        message: 'Expected http/s scheme.'
                    });
                    r.initiator = 'fetch';
                    r.destination = 'subresource';
                    requestList.push(r);
                    const responsePromise = createDeferredPromise();
                    fetchControllers.push(fetching({
                        request: r,
                        processResponse (response) {
                            if ('error' === response.type || 206 === response.status || response.status < 200 || response.status > 299) responsePromise.reject(webidl.errors.exception({
                                header: 'Cache.addAll',
                                message: 'Received an invalid status code or the request failed.'
                            }));
                            else if (response.headersList.contains('vary')) {
                                const fieldValues = getFieldValues(response.headersList.get('vary'));
                                for (const fieldValue of fieldValues)if ('*' === fieldValue) {
                                    responsePromise.reject(webidl.errors.exception({
                                        header: 'Cache.addAll',
                                        message: 'invalid vary field value'
                                    }));
                                    for (const controller of fetchControllers)controller.abort();
                                    return;
                                }
                            }
                        },
                        processResponseEndOfBody (response) {
                            if (response.aborted) return void responsePromise.reject(new DOMException('aborted', 'AbortError'));
                            responsePromise.resolve(response);
                        }
                    }));
                    responsePromises.push(responsePromise.promise);
                }
                const p = Promise.all(responsePromises);
                const responses = await p;
                const operations = [];
                let index = 0;
                for (const response of responses){
                    const operation = {
                        type: 'put',
                        request: requestList[index],
                        response
                    };
                    operations.push(operation);
                    index++;
                }
                const cacheJobPromise = createDeferredPromise();
                let errorData = null;
                try {
                    this.#batchCacheOperations(operations);
                } catch (e) {
                    errorData = e;
                }
                queueMicrotask(()=>{
                    if (null === errorData) cacheJobPromise.resolve(void 0);
                    else cacheJobPromise.reject(errorData);
                });
                return cacheJobPromise.promise;
            }
            async put(request, response) {
                webidl.brandCheck(this, Cache);
                const prefix = 'Cache.put';
                webidl.argumentLengthCheck(arguments, 2, prefix);
                request = webidl.converters.RequestInfo(request, prefix, 'request');
                response = webidl.converters.Response(response, prefix, 'response');
                let innerRequest = null;
                innerRequest = request instanceof Request ? request[kState] : new Request(request)[kState];
                if (!urlIsHttpHttpsScheme(innerRequest.url) || 'GET' !== innerRequest.method) throw webidl.errors.exception({
                    header: prefix,
                    message: 'Expected an http/s scheme when method is not GET'
                });
                const innerResponse = response[kState];
                if (206 === innerResponse.status) throw webidl.errors.exception({
                    header: prefix,
                    message: 'Got 206 status'
                });
                if (innerResponse.headersList.contains('vary')) {
                    const fieldValues = getFieldValues(innerResponse.headersList.get('vary'));
                    for (const fieldValue of fieldValues)if ('*' === fieldValue) throw webidl.errors.exception({
                        header: prefix,
                        message: 'Got * vary field value'
                    });
                }
                if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) throw webidl.errors.exception({
                    header: prefix,
                    message: 'Response body is locked or disturbed'
                });
                const clonedResponse = cloneResponse(innerResponse);
                const bodyReadPromise = createDeferredPromise();
                if (null != innerResponse.body) {
                    const stream = innerResponse.body.stream;
                    const reader = stream.getReader();
                    readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
                } else bodyReadPromise.resolve(void 0);
                const operations = [];
                const operation = {
                    type: 'put',
                    request: innerRequest,
                    response: clonedResponse
                };
                operations.push(operation);
                const bytes = await bodyReadPromise.promise;
                if (null != clonedResponse.body) clonedResponse.body.source = bytes;
                const cacheJobPromise = createDeferredPromise();
                let errorData = null;
                try {
                    this.#batchCacheOperations(operations);
                } catch (e) {
                    errorData = e;
                }
                queueMicrotask(()=>{
                    if (null === errorData) cacheJobPromise.resolve();
                    else cacheJobPromise.reject(errorData);
                });
                return cacheJobPromise.promise;
            }
            async delete(request, options = {}) {
                webidl.brandCheck(this, Cache);
                const prefix = 'Cache.delete';
                webidl.argumentLengthCheck(arguments, 1, prefix);
                request = webidl.converters.RequestInfo(request, prefix, 'request');
                options = webidl.converters.CacheQueryOptions(options, prefix, 'options');
                let r = null;
                if (request instanceof Request) {
                    r = request[kState];
                    if ('GET' !== r.method && !options.ignoreMethod) return false;
                } else {
                    assert('string' == typeof request);
                    r = new Request(request)[kState];
                }
                const operations = [];
                const operation = {
                    type: 'delete',
                    request: r,
                    options
                };
                operations.push(operation);
                const cacheJobPromise = createDeferredPromise();
                let errorData = null;
                let requestResponses;
                try {
                    requestResponses = this.#batchCacheOperations(operations);
                } catch (e) {
                    errorData = e;
                }
                queueMicrotask(()=>{
                    if (null === errorData) cacheJobPromise.resolve(!!requestResponses?.length);
                    else cacheJobPromise.reject(errorData);
                });
                return cacheJobPromise.promise;
            }
            async keys(request, options = {}) {
                webidl.brandCheck(this, Cache);
                const prefix = 'Cache.keys';
                if (void 0 !== request) request = webidl.converters.RequestInfo(request, prefix, 'request');
                options = webidl.converters.CacheQueryOptions(options, prefix, 'options');
                let r = null;
                if (void 0 !== request) {
                    if (request instanceof Request) {
                        r = request[kState];
                        if ('GET' !== r.method && !options.ignoreMethod) return [];
                    } else if ('string' == typeof request) r = new Request(request)[kState];
                }
                const promise = createDeferredPromise();
                const requests = [];
                if (void 0 === request) for (const requestResponse of this.#relevantRequestResponseList)requests.push(requestResponse[0]);
                else {
                    const requestResponses = this.#queryCache(r, options);
                    for (const requestResponse of requestResponses)requests.push(requestResponse[0]);
                }
                queueMicrotask(()=>{
                    const requestList = [];
                    for (const request of requests){
                        const requestObject = fromInnerRequest(request, new AbortController().signal, 'immutable');
                        requestList.push(requestObject);
                    }
                    promise.resolve(Object.freeze(requestList));
                });
                return promise.promise;
            }
            #batchCacheOperations(operations) {
                const cache = this.#relevantRequestResponseList;
                const backupCache = [
                    ...cache
                ];
                const addedItems = [];
                const resultList = [];
                try {
                    for (const operation of operations){
                        if ('delete' !== operation.type && 'put' !== operation.type) throw webidl.errors.exception({
                            header: 'Cache.#batchCacheOperations',
                            message: 'operation type does not match "delete" or "put"'
                        });
                        if ('delete' === operation.type && null != operation.response) throw webidl.errors.exception({
                            header: 'Cache.#batchCacheOperations',
                            message: 'delete operation should not have an associated response'
                        });
                        if (this.#queryCache(operation.request, operation.options, addedItems).length) throw new DOMException('???', 'InvalidStateError');
                        let requestResponses;
                        if ('delete' === operation.type) {
                            requestResponses = this.#queryCache(operation.request, operation.options);
                            if (0 === requestResponses.length) return [];
                            for (const requestResponse of requestResponses){
                                const idx = cache.indexOf(requestResponse);
                                assert(-1 !== idx);
                                cache.splice(idx, 1);
                            }
                        } else if ('put' === operation.type) {
                            if (null == operation.response) throw webidl.errors.exception({
                                header: 'Cache.#batchCacheOperations',
                                message: 'put operation should have an associated response'
                            });
                            const r = operation.request;
                            if (!urlIsHttpHttpsScheme(r.url)) throw webidl.errors.exception({
                                header: 'Cache.#batchCacheOperations',
                                message: 'expected http or https scheme'
                            });
                            if ('GET' !== r.method) throw webidl.errors.exception({
                                header: 'Cache.#batchCacheOperations',
                                message: 'not get method'
                            });
                            if (null != operation.options) throw webidl.errors.exception({
                                header: 'Cache.#batchCacheOperations',
                                message: 'options must not be defined'
                            });
                            requestResponses = this.#queryCache(operation.request);
                            for (const requestResponse of requestResponses){
                                const idx = cache.indexOf(requestResponse);
                                assert(-1 !== idx);
                                cache.splice(idx, 1);
                            }
                            cache.push([
                                operation.request,
                                operation.response
                            ]);
                            addedItems.push([
                                operation.request,
                                operation.response
                            ]);
                        }
                        resultList.push([
                            operation.request,
                            operation.response
                        ]);
                    }
                    return resultList;
                } catch (e) {
                    this.#relevantRequestResponseList.length = 0;
                    this.#relevantRequestResponseList = backupCache;
                    throw e;
                }
            }
            #queryCache(requestQuery, options, targetStorage) {
                const resultList = [];
                const storage = targetStorage ?? this.#relevantRequestResponseList;
                for (const requestResponse of storage){
                    const [cachedRequest, cachedResponse] = requestResponse;
                    if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) resultList.push(requestResponse);
                }
                return resultList;
            }
            #requestMatchesCachedItem(requestQuery, request, response = null, options) {
                const queryURL = new URL(requestQuery.url);
                const cachedURL = new URL(request.url);
                if (options?.ignoreSearch) {
                    cachedURL.search = '';
                    queryURL.search = '';
                }
                if (!urlEquals(queryURL, cachedURL, true)) return false;
                if (null == response || options?.ignoreVary || !response.headersList.contains('vary')) return true;
                const fieldValues = getFieldValues(response.headersList.get('vary'));
                for (const fieldValue of fieldValues){
                    if ('*' === fieldValue) return false;
                    const requestValue = request.headersList.get(fieldValue);
                    const queryValue = requestQuery.headersList.get(fieldValue);
                    if (requestValue !== queryValue) return false;
                }
                return true;
            }
            #internalMatchAll(request, options, maxResponses = 1 / 0) {
                let r = null;
                if (void 0 !== request) {
                    if (request instanceof Request) {
                        r = request[kState];
                        if ('GET' !== r.method && !options.ignoreMethod) return [];
                    } else if ('string' == typeof request) r = new Request(request)[kState];
                }
                const responses = [];
                if (void 0 === request) for (const requestResponse of this.#relevantRequestResponseList)responses.push(requestResponse[1]);
                else {
                    const requestResponses = this.#queryCache(r, options);
                    for (const requestResponse of requestResponses)responses.push(requestResponse[1]);
                }
                const responseList = [];
                for (const response of responses){
                    const responseObject = fromInnerResponse(response, 'immutable');
                    responseList.push(responseObject.clone());
                    if (responseList.length >= maxResponses) break;
                }
                return Object.freeze(responseList);
            }
        }
        Object.defineProperties(Cache.prototype, {
            [Symbol.toStringTag]: {
                value: 'Cache',
                configurable: true
            },
            match: kEnumerableProperty,
            matchAll: kEnumerableProperty,
            add: kEnumerableProperty,
            addAll: kEnumerableProperty,
            put: kEnumerableProperty,
            delete: kEnumerableProperty,
            keys: kEnumerableProperty
        });
        const cacheQueryOptionConverters = [
            {
                key: 'ignoreSearch',
                converter: webidl.converters.boolean,
                defaultValue: ()=>false
            },
            {
                key: 'ignoreMethod',
                converter: webidl.converters.boolean,
                defaultValue: ()=>false
            },
            {
                key: 'ignoreVary',
                converter: webidl.converters.boolean,
                defaultValue: ()=>false
            }
        ];
        webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
        webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
            ...cacheQueryOptionConverters,
            {
                key: 'cacheName',
                converter: webidl.converters.DOMString
            }
        ]);
        webidl.converters.Response = webidl.interfaceConverter(Response);
        webidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(webidl.converters.RequestInfo);
        module.exports = {
            Cache
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cache/cachestorage.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { kConstruct } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cache/symbols.js");
        const { Cache } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cache/cache.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/webidl.js");
        const { kEnumerableProperty } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        class CacheStorage {
            #caches = new Map();
            constructor(){
                if (arguments[0] !== kConstruct) webidl.illegalConstructor();
                webidl.util.markAsUncloneable(this);
            }
            async match(request, options = {}) {
                webidl.brandCheck(this, CacheStorage);
                webidl.argumentLengthCheck(arguments, 1, 'CacheStorage.match');
                request = webidl.converters.RequestInfo(request);
                options = webidl.converters.MultiCacheQueryOptions(options);
                if (null != options.cacheName) {
                    if (this.#caches.has(options.cacheName)) {
                        const cacheList = this.#caches.get(options.cacheName);
                        const cache = new Cache(kConstruct, cacheList);
                        return await cache.match(request, options);
                    }
                } else for (const cacheList of this.#caches.values()){
                    const cache = new Cache(kConstruct, cacheList);
                    const response = await cache.match(request, options);
                    if (void 0 !== response) return response;
                }
            }
            async has(cacheName) {
                webidl.brandCheck(this, CacheStorage);
                const prefix = 'CacheStorage.has';
                webidl.argumentLengthCheck(arguments, 1, prefix);
                cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName');
                return this.#caches.has(cacheName);
            }
            async open(cacheName) {
                webidl.brandCheck(this, CacheStorage);
                const prefix = 'CacheStorage.open';
                webidl.argumentLengthCheck(arguments, 1, prefix);
                cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName');
                if (this.#caches.has(cacheName)) {
                    const cache = this.#caches.get(cacheName);
                    return new Cache(kConstruct, cache);
                }
                const cache = [];
                this.#caches.set(cacheName, cache);
                return new Cache(kConstruct, cache);
            }
            async delete(cacheName) {
                webidl.brandCheck(this, CacheStorage);
                const prefix = 'CacheStorage.delete';
                webidl.argumentLengthCheck(arguments, 1, prefix);
                cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName');
                return this.#caches.delete(cacheName);
            }
            async keys() {
                webidl.brandCheck(this, CacheStorage);
                const keys = this.#caches.keys();
                return [
                    ...keys
                ];
            }
        }
        Object.defineProperties(CacheStorage.prototype, {
            [Symbol.toStringTag]: {
                value: 'CacheStorage',
                configurable: true
            },
            match: kEnumerableProperty,
            has: kEnumerableProperty,
            open: kEnumerableProperty,
            delete: kEnumerableProperty,
            keys: kEnumerableProperty
        });
        module.exports = {
            CacheStorage
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cache/symbols.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        module.exports = {
            kConstruct: __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js").kConstruct
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cache/util.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const assert = __webpack_require__("node:assert");
        const { URLSerializer } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/data-url.js");
        const { isValidHeaderName } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/util.js");
        function urlEquals(A, B, excludeFragment = false) {
            const serializedA = URLSerializer(A, excludeFragment);
            const serializedB = URLSerializer(B, excludeFragment);
            return serializedA === serializedB;
        }
        function getFieldValues(header) {
            assert(null !== header);
            const values = [];
            for (let value of header.split(',')){
                value = value.trim();
                if (isValidHeaderName(value)) values.push(value);
            }
            return values;
        }
        module.exports = {
            urlEquals,
            getFieldValues
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cookies/constants.js" (module) {
        "use strict";
        const maxAttributeValueSize = 1024;
        const maxNameValuePairSize = 4096;
        module.exports = {
            maxAttributeValueSize,
            maxNameValuePairSize
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cookies/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { parseSetCookie } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cookies/parse.js");
        const { stringify } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cookies/util.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/webidl.js");
        const { Headers } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/headers.js");
        function getCookies(headers) {
            webidl.argumentLengthCheck(arguments, 1, 'getCookies');
            webidl.brandCheck(headers, Headers, {
                strict: false
            });
            const cookie = headers.get('cookie');
            const out = {};
            if (!cookie) return out;
            for (const piece of cookie.split(';')){
                const [name, ...value] = piece.split('=');
                out[name.trim()] = value.join('=');
            }
            return out;
        }
        function deleteCookie(headers, name, attributes) {
            webidl.brandCheck(headers, Headers, {
                strict: false
            });
            const prefix = 'deleteCookie';
            webidl.argumentLengthCheck(arguments, 2, prefix);
            name = webidl.converters.DOMString(name, prefix, 'name');
            attributes = webidl.converters.DeleteCookieAttributes(attributes);
            setCookie(headers, {
                name,
                value: '',
                expires: new Date(0),
                ...attributes
            });
        }
        function getSetCookies(headers) {
            webidl.argumentLengthCheck(arguments, 1, 'getSetCookies');
            webidl.brandCheck(headers, Headers, {
                strict: false
            });
            const cookies = headers.getSetCookie();
            if (!cookies) return [];
            return cookies.map((pair)=>parseSetCookie(pair));
        }
        function setCookie(headers, cookie) {
            webidl.argumentLengthCheck(arguments, 2, 'setCookie');
            webidl.brandCheck(headers, Headers, {
                strict: false
            });
            cookie = webidl.converters.Cookie(cookie);
            const str = stringify(cookie);
            if (str) headers.append('Set-Cookie', str);
        }
        webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
            {
                converter: webidl.nullableConverter(webidl.converters.DOMString),
                key: 'path',
                defaultValue: ()=>null
            },
            {
                converter: webidl.nullableConverter(webidl.converters.DOMString),
                key: 'domain',
                defaultValue: ()=>null
            }
        ]);
        webidl.converters.Cookie = webidl.dictionaryConverter([
            {
                converter: webidl.converters.DOMString,
                key: 'name'
            },
            {
                converter: webidl.converters.DOMString,
                key: 'value'
            },
            {
                converter: webidl.nullableConverter((value)=>{
                    if ('number' == typeof value) return webidl.converters['unsigned long long'](value);
                    return new Date(value);
                }),
                key: 'expires',
                defaultValue: ()=>null
            },
            {
                converter: webidl.nullableConverter(webidl.converters['long long']),
                key: 'maxAge',
                defaultValue: ()=>null
            },
            {
                converter: webidl.nullableConverter(webidl.converters.DOMString),
                key: 'domain',
                defaultValue: ()=>null
            },
            {
                converter: webidl.nullableConverter(webidl.converters.DOMString),
                key: 'path',
                defaultValue: ()=>null
            },
            {
                converter: webidl.nullableConverter(webidl.converters.boolean),
                key: 'secure',
                defaultValue: ()=>null
            },
            {
                converter: webidl.nullableConverter(webidl.converters.boolean),
                key: 'httpOnly',
                defaultValue: ()=>null
            },
            {
                converter: webidl.converters.USVString,
                key: 'sameSite',
                allowedValues: [
                    'Strict',
                    'Lax',
                    'None'
                ]
            },
            {
                converter: webidl.sequenceConverter(webidl.converters.DOMString),
                key: 'unparsed',
                defaultValue: ()=>new Array(0)
            }
        ]);
        module.exports = {
            getCookies,
            deleteCookie,
            getSetCookies,
            setCookie
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cookies/parse.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { maxNameValuePairSize, maxAttributeValueSize } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cookies/constants.js");
        const { isCTLExcludingHtab } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cookies/util.js");
        const { collectASequenceOfCodePointsFast } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/data-url.js");
        const assert = __webpack_require__("node:assert");
        function parseSetCookie(header) {
            if (isCTLExcludingHtab(header)) return null;
            let nameValuePair = '';
            let unparsedAttributes = '';
            let name = '';
            let value = '';
            if (header.includes(';')) {
                const position = {
                    position: 0
                };
                nameValuePair = collectASequenceOfCodePointsFast(';', header, position);
                unparsedAttributes = header.slice(position.position);
            } else nameValuePair = header;
            if (nameValuePair.includes('=')) {
                const position = {
                    position: 0
                };
                name = collectASequenceOfCodePointsFast('=', nameValuePair, position);
                value = nameValuePair.slice(position.position + 1);
            } else value = nameValuePair;
            name = name.trim();
            value = value.trim();
            if (name.length + value.length > maxNameValuePairSize) return null;
            return {
                name,
                value,
                ...parseUnparsedAttributes(unparsedAttributes)
            };
        }
        function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
            if (0 === unparsedAttributes.length) return cookieAttributeList;
            assert(';' === unparsedAttributes[0]);
            unparsedAttributes = unparsedAttributes.slice(1);
            let cookieAv = '';
            if (unparsedAttributes.includes(';')) {
                cookieAv = collectASequenceOfCodePointsFast(';', unparsedAttributes, {
                    position: 0
                });
                unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
            } else {
                cookieAv = unparsedAttributes;
                unparsedAttributes = '';
            }
            let attributeName = '';
            let attributeValue = '';
            if (cookieAv.includes('=')) {
                const position = {
                    position: 0
                };
                attributeName = collectASequenceOfCodePointsFast('=', cookieAv, position);
                attributeValue = cookieAv.slice(position.position + 1);
            } else attributeName = cookieAv;
            attributeName = attributeName.trim();
            attributeValue = attributeValue.trim();
            if (attributeValue.length > maxAttributeValueSize) return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
            const attributeNameLowercase = attributeName.toLowerCase();
            if ('expires' === attributeNameLowercase) {
                const expiryTime = new Date(attributeValue);
                cookieAttributeList.expires = expiryTime;
            } else if ('max-age' === attributeNameLowercase) {
                const charCode = attributeValue.charCodeAt(0);
                if ((charCode < 48 || charCode > 57) && '-' !== attributeValue[0]) return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
                if (!/^\d+$/.test(attributeValue)) return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
                const deltaSeconds = Number(attributeValue);
                cookieAttributeList.maxAge = deltaSeconds;
            } else if ('domain' === attributeNameLowercase) {
                let cookieDomain = attributeValue;
                if ('.' === cookieDomain[0]) cookieDomain = cookieDomain.slice(1);
                cookieDomain = cookieDomain.toLowerCase();
                cookieAttributeList.domain = cookieDomain;
            } else if ('path' === attributeNameLowercase) {
                let cookiePath = '';
                cookiePath = 0 === attributeValue.length || '/' !== attributeValue[0] ? '/' : attributeValue;
                cookieAttributeList.path = cookiePath;
            } else if ('secure' === attributeNameLowercase) cookieAttributeList.secure = true;
            else if ('httponly' === attributeNameLowercase) cookieAttributeList.httpOnly = true;
            else if ('samesite' === attributeNameLowercase) {
                let enforcement = 'Default';
                const attributeValueLowercase = attributeValue.toLowerCase();
                if (attributeValueLowercase.includes('none')) enforcement = 'None';
                if (attributeValueLowercase.includes('strict')) enforcement = 'Strict';
                if (attributeValueLowercase.includes('lax')) enforcement = 'Lax';
                cookieAttributeList.sameSite = enforcement;
            } else {
                cookieAttributeList.unparsed ??= [];
                cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
            }
            return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        module.exports = {
            parseSetCookie,
            parseUnparsedAttributes
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/cookies/util.js" (module) {
        "use strict";
        function isCTLExcludingHtab(value) {
            for(let i = 0; i < value.length; ++i){
                const code = value.charCodeAt(i);
                if (code >= 0x00 && code <= 0x08 || code >= 0x0A && code <= 0x1F || 0x7F === code) return true;
            }
            return false;
        }
        function validateCookieName(name) {
            for(let i = 0; i < name.length; ++i){
                const code = name.charCodeAt(i);
                if (code < 0x21 || code > 0x7E || 0x22 === code || 0x28 === code || 0x29 === code || 0x3C === code || 0x3E === code || 0x40 === code || 0x2C === code || 0x3B === code || 0x3A === code || 0x5C === code || 0x2F === code || 0x5B === code || 0x5D === code || 0x3F === code || 0x3D === code || 0x7B === code || 0x7D === code) throw new Error('Invalid cookie name');
            }
        }
        function validateCookieValue(value) {
            let len = value.length;
            let i = 0;
            if ('"' === value[0]) {
                if (1 === len || '"' !== value[len - 1]) throw new Error('Invalid cookie value');
                --len;
                ++i;
            }
            while(i < len){
                const code = value.charCodeAt(i++);
                if (code < 0x21 || code > 0x7E || 0x22 === code || 0x2C === code || 0x3B === code || 0x5C === code) throw new Error('Invalid cookie value');
            }
        }
        function validateCookiePath(path) {
            for(let i = 0; i < path.length; ++i){
                const code = path.charCodeAt(i);
                if (code < 0x20 || 0x7F === code || 0x3B === code) throw new Error('Invalid cookie path');
            }
        }
        function validateCookieDomain(domain) {
            if (domain.startsWith('-') || domain.endsWith('.') || domain.endsWith('-')) throw new Error('Invalid cookie domain');
        }
        const IMFDays = [
            'Sun',
            'Mon',
            'Tue',
            'Wed',
            'Thu',
            'Fri',
            'Sat'
        ];
        const IMFMonths = [
            'Jan',
            'Feb',
            'Mar',
            'Apr',
            'May',
            'Jun',
            'Jul',
            'Aug',
            'Sep',
            'Oct',
            'Nov',
            'Dec'
        ];
        const IMFPaddedNumbers = Array(61).fill(0).map((_, i)=>i.toString().padStart(2, '0'));
        function toIMFDate(date) {
            if ('number' == typeof date) date = new Date(date);
            return `${IMFDays[date.getUTCDay()]}, ${IMFPaddedNumbers[date.getUTCDate()]} ${IMFMonths[date.getUTCMonth()]} ${date.getUTCFullYear()} ${IMFPaddedNumbers[date.getUTCHours()]}:${IMFPaddedNumbers[date.getUTCMinutes()]}:${IMFPaddedNumbers[date.getUTCSeconds()]} GMT`;
        }
        function validateCookieMaxAge(maxAge) {
            if (maxAge < 0) throw new Error('Invalid cookie max-age');
        }
        function stringify(cookie) {
            if (0 === cookie.name.length) return null;
            validateCookieName(cookie.name);
            validateCookieValue(cookie.value);
            const out = [
                `${cookie.name}=${cookie.value}`
            ];
            if (cookie.name.startsWith('__Secure-')) cookie.secure = true;
            if (cookie.name.startsWith('__Host-')) {
                cookie.secure = true;
                cookie.domain = null;
                cookie.path = '/';
            }
            if (cookie.secure) out.push('Secure');
            if (cookie.httpOnly) out.push('HttpOnly');
            if ('number' == typeof cookie.maxAge) {
                validateCookieMaxAge(cookie.maxAge);
                out.push(`Max-Age=${cookie.maxAge}`);
            }
            if (cookie.domain) {
                validateCookieDomain(cookie.domain);
                out.push(`Domain=${cookie.domain}`);
            }
            if (cookie.path) {
                validateCookiePath(cookie.path);
                out.push(`Path=${cookie.path}`);
            }
            if (cookie.expires && 'Invalid Date' !== cookie.expires.toString()) out.push(`Expires=${toIMFDate(cookie.expires)}`);
            if (cookie.sameSite) out.push(`SameSite=${cookie.sameSite}`);
            for (const part of cookie.unparsed){
                if (!part.includes('=')) throw new Error('Invalid unparsed');
                const [key, ...value] = part.split('=');
                out.push(`${key.trim()}=${value.join('=')}`);
            }
            return out.join('; ');
        }
        module.exports = {
            isCTLExcludingHtab,
            validateCookieName,
            validateCookiePath,
            validateCookieValue,
            toIMFDate,
            stringify
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/eventsource/eventsource-stream.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { Transform } = __webpack_require__("node:stream");
        const { isASCIINumber, isValidLastEventId } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/eventsource/util.js");
        const BOM = [
            0xEF,
            0xBB,
            0xBF
        ];
        const LF = 0x0A;
        const CR = 0x0D;
        const COLON = 0x3A;
        const SPACE = 0x20;
        class EventSourceStream extends Transform {
            state = null;
            checkBOM = true;
            crlfCheck = false;
            eventEndCheck = false;
            buffer = null;
            pos = 0;
            event = {
                data: void 0,
                event: void 0,
                id: void 0,
                retry: void 0
            };
            constructor(options = {}){
                options.readableObjectMode = true;
                super(options);
                this.state = options.eventSourceSettings || {};
                if (options.push) this.push = options.push;
            }
            _transform(chunk, _encoding, callback) {
                if (0 === chunk.length) return void callback();
                if (this.buffer) this.buffer = Buffer.concat([
                    this.buffer,
                    chunk
                ]);
                else this.buffer = chunk;
                if (this.checkBOM) switch(this.buffer.length){
                    case 1:
                        if (this.buffer[0] === BOM[0]) return void callback();
                        this.checkBOM = false;
                        callback();
                        return;
                    case 2:
                        if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1]) return void callback();
                        this.checkBOM = false;
                        break;
                    case 3:
                        if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
                            this.buffer = Buffer.alloc(0);
                            this.checkBOM = false;
                            callback();
                            return;
                        }
                        this.checkBOM = false;
                        break;
                    default:
                        if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) this.buffer = this.buffer.subarray(3);
                        this.checkBOM = false;
                        break;
                }
                while(this.pos < this.buffer.length){
                    if (this.eventEndCheck) {
                        if (this.crlfCheck) {
                            if (this.buffer[this.pos] === LF) {
                                this.buffer = this.buffer.subarray(this.pos + 1);
                                this.pos = 0;
                                this.crlfCheck = false;
                                continue;
                            }
                            this.crlfCheck = false;
                        }
                        if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
                            if (this.buffer[this.pos] === CR) this.crlfCheck = true;
                            this.buffer = this.buffer.subarray(this.pos + 1);
                            this.pos = 0;
                            if (void 0 !== this.event.data || this.event.event || this.event.id || this.event.retry) this.processEvent(this.event);
                            this.clearEvent();
                            continue;
                        }
                        this.eventEndCheck = false;
                        continue;
                    }
                    if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
                        if (this.buffer[this.pos] === CR) this.crlfCheck = true;
                        this.parseLine(this.buffer.subarray(0, this.pos), this.event);
                        this.buffer = this.buffer.subarray(this.pos + 1);
                        this.pos = 0;
                        this.eventEndCheck = true;
                        continue;
                    }
                    this.pos++;
                }
                callback();
            }
            parseLine(line, event) {
                if (0 === line.length) return;
                const colonPosition = line.indexOf(COLON);
                if (0 === colonPosition) return;
                let field = '';
                let value = '';
                if (-1 !== colonPosition) {
                    field = line.subarray(0, colonPosition).toString('utf8');
                    let valueStart = colonPosition + 1;
                    if (line[valueStart] === SPACE) ++valueStart;
                    value = line.subarray(valueStart).toString('utf8');
                } else {
                    field = line.toString('utf8');
                    value = '';
                }
                switch(field){
                    case 'data':
                        if (void 0 === event[field]) event[field] = value;
                        else event[field] += `\n${value}`;
                        break;
                    case 'retry':
                        if (isASCIINumber(value)) event[field] = value;
                        break;
                    case 'id':
                        if (isValidLastEventId(value)) event[field] = value;
                        break;
                    case 'event':
                        if (value.length > 0) event[field] = value;
                        break;
                }
            }
            processEvent(event) {
                if (event.retry && isASCIINumber(event.retry)) this.state.reconnectionTime = parseInt(event.retry, 10);
                if (event.id && isValidLastEventId(event.id)) this.state.lastEventId = event.id;
                if (void 0 !== event.data) this.push({
                    type: event.event || 'message',
                    options: {
                        data: event.data,
                        lastEventId: this.state.lastEventId,
                        origin: this.state.origin
                    }
                });
            }
            clearEvent() {
                this.event = {
                    data: void 0,
                    event: void 0,
                    id: void 0,
                    retry: void 0
                };
            }
        }
        module.exports = {
            EventSourceStream
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/eventsource/eventsource.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { pipeline } = __webpack_require__("node:stream");
        const { fetching } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/index.js");
        const { makeRequest } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/request.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/webidl.js");
        const { EventSourceStream } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/eventsource/eventsource-stream.js");
        const { parseMIMEType } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/data-url.js");
        const { createFastMessageEvent } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/events.js");
        const { isNetworkError } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/response.js");
        const { delay } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/eventsource/util.js");
        const { kEnumerableProperty } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { environmentSettingsObject } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/util.js");
        let experimentalWarned = false;
        const defaultReconnectionTime = 3000;
        const CONNECTING = 0;
        const OPEN = 1;
        const CLOSED = 2;
        const ANONYMOUS = 'anonymous';
        const USE_CREDENTIALS = 'use-credentials';
        class EventSource extends EventTarget {
            #events = {
                open: null,
                error: null,
                message: null
            };
            #url = null;
            #withCredentials = false;
            #readyState = CONNECTING;
            #request = null;
            #controller = null;
            #dispatcher;
            #state;
            constructor(url, eventSourceInitDict = {}){
                super();
                webidl.util.markAsUncloneable(this);
                const prefix = 'EventSource constructor';
                webidl.argumentLengthCheck(arguments, 1, prefix);
                if (!experimentalWarned) {
                    experimentalWarned = true;
                    process.emitWarning('EventSource is experimental, expect them to change at any time.', {
                        code: 'UNDICI-ES'
                    });
                }
                url = webidl.converters.USVString(url, prefix, 'url');
                eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, 'eventSourceInitDict');
                this.#dispatcher = eventSourceInitDict.dispatcher;
                this.#state = {
                    lastEventId: '',
                    reconnectionTime: defaultReconnectionTime
                };
                const settings = environmentSettingsObject;
                let urlRecord;
                try {
                    urlRecord = new URL(url, settings.settingsObject.baseUrl);
                    this.#state.origin = urlRecord.origin;
                } catch (e) {
                    throw new DOMException(e, 'SyntaxError');
                }
                this.#url = urlRecord.href;
                let corsAttributeState = ANONYMOUS;
                if (eventSourceInitDict.withCredentials) {
                    corsAttributeState = USE_CREDENTIALS;
                    this.#withCredentials = true;
                }
                const initRequest = {
                    redirect: 'follow',
                    keepalive: true,
                    mode: 'cors',
                    credentials: 'anonymous' === corsAttributeState ? 'same-origin' : 'omit',
                    referrer: 'no-referrer'
                };
                initRequest.client = environmentSettingsObject.settingsObject;
                initRequest.headersList = [
                    [
                        'accept',
                        {
                            name: 'accept',
                            value: 'text/event-stream'
                        }
                    ]
                ];
                initRequest.cache = 'no-store';
                initRequest.initiator = 'other';
                initRequest.urlList = [
                    new URL(this.#url)
                ];
                this.#request = makeRequest(initRequest);
                this.#connect();
            }
            get readyState() {
                return this.#readyState;
            }
            get url() {
                return this.#url;
            }
            get withCredentials() {
                return this.#withCredentials;
            }
            #connect() {
                if (this.#readyState === CLOSED) return;
                this.#readyState = CONNECTING;
                const fetchParams = {
                    request: this.#request,
                    dispatcher: this.#dispatcher
                };
                const processEventSourceEndOfBody = (response)=>{
                    if (isNetworkError(response)) {
                        this.dispatchEvent(new Event('error'));
                        this.close();
                    }
                    this.#reconnect();
                };
                fetchParams.processResponseEndOfBody = processEventSourceEndOfBody;
                fetchParams.processResponse = (response)=>{
                    if (isNetworkError(response)) if (!response.aborted) return void this.#reconnect();
                    else {
                        this.close();
                        this.dispatchEvent(new Event('error'));
                        return;
                    }
                    const contentType = response.headersList.get('content-type', true);
                    const mimeType = null !== contentType ? parseMIMEType(contentType) : 'failure';
                    const contentTypeValid = 'failure' !== mimeType && 'text/event-stream' === mimeType.essence;
                    if (200 !== response.status || false === contentTypeValid) {
                        this.close();
                        this.dispatchEvent(new Event('error'));
                        return;
                    }
                    this.#readyState = OPEN;
                    this.dispatchEvent(new Event('open'));
                    this.#state.origin = response.urlList[response.urlList.length - 1].origin;
                    const eventSourceStream = new EventSourceStream({
                        eventSourceSettings: this.#state,
                        push: (event)=>{
                            this.dispatchEvent(createFastMessageEvent(event.type, event.options));
                        }
                    });
                    pipeline(response.body.stream, eventSourceStream, (error)=>{
                        if (error?.aborted === false) {
                            this.close();
                            this.dispatchEvent(new Event('error'));
                        }
                    });
                };
                this.#controller = fetching(fetchParams);
            }
            async #reconnect() {
                if (this.#readyState === CLOSED) return;
                this.#readyState = CONNECTING;
                this.dispatchEvent(new Event('error'));
                await delay(this.#state.reconnectionTime);
                if (this.#readyState !== CONNECTING) return;
                if (this.#state.lastEventId.length) this.#request.headersList.set('last-event-id', this.#state.lastEventId, true);
                this.#connect();
            }
            close() {
                webidl.brandCheck(this, EventSource);
                if (this.#readyState === CLOSED) return;
                this.#readyState = CLOSED;
                this.#controller.abort();
                this.#request = null;
            }
            get onopen() {
                return this.#events.open;
            }
            set onopen(fn) {
                if (this.#events.open) this.removeEventListener('open', this.#events.open);
                if ('function' == typeof fn) {
                    this.#events.open = fn;
                    this.addEventListener('open', fn);
                } else this.#events.open = null;
            }
            get onmessage() {
                return this.#events.message;
            }
            set onmessage(fn) {
                if (this.#events.message) this.removeEventListener('message', this.#events.message);
                if ('function' == typeof fn) {
                    this.#events.message = fn;
                    this.addEventListener('message', fn);
                } else this.#events.message = null;
            }
            get onerror() {
                return this.#events.error;
            }
            set onerror(fn) {
                if (this.#events.error) this.removeEventListener('error', this.#events.error);
                if ('function' == typeof fn) {
                    this.#events.error = fn;
                    this.addEventListener('error', fn);
                } else this.#events.error = null;
            }
        }
        const constantsPropertyDescriptors = {
            CONNECTING: {
                __proto__: null,
                configurable: false,
                enumerable: true,
                value: CONNECTING,
                writable: false
            },
            OPEN: {
                __proto__: null,
                configurable: false,
                enumerable: true,
                value: OPEN,
                writable: false
            },
            CLOSED: {
                __proto__: null,
                configurable: false,
                enumerable: true,
                value: CLOSED,
                writable: false
            }
        };
        Object.defineProperties(EventSource, constantsPropertyDescriptors);
        Object.defineProperties(EventSource.prototype, constantsPropertyDescriptors);
        Object.defineProperties(EventSource.prototype, {
            close: kEnumerableProperty,
            onerror: kEnumerableProperty,
            onmessage: kEnumerableProperty,
            onopen: kEnumerableProperty,
            readyState: kEnumerableProperty,
            url: kEnumerableProperty,
            withCredentials: kEnumerableProperty
        });
        webidl.converters.EventSourceInitDict = webidl.dictionaryConverter([
            {
                key: 'withCredentials',
                converter: webidl.converters.boolean,
                defaultValue: ()=>false
            },
            {
                key: 'dispatcher',
                converter: webidl.converters.any
            }
        ]);
        module.exports = {
            EventSource,
            defaultReconnectionTime
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/eventsource/util.js" (module) {
        "use strict";
        function isValidLastEventId(value) {
            return -1 === value.indexOf('\u0000');
        }
        function isASCIINumber(value) {
            if (0 === value.length) return false;
            for(let i = 0; i < value.length; i++)if (value.charCodeAt(i) < 0x30 || value.charCodeAt(i) > 0x39) return false;
            return true;
        }
        function delay(ms) {
            return new Promise((resolve)=>{
                setTimeout(resolve, ms).unref();
            });
        }
        module.exports = {
            isValidLastEventId,
            isASCIINumber,
            delay
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/body.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { ReadableStreamFrom, isBlobLike, isReadableStreamLike, readableStreamClose, createDeferredPromise, fullyReadBody, extractMimeType, utf8DecodeBytes } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/util.js");
        const { FormData } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/formdata.js");
        const { kState } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/symbols.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/webidl.js");
        const { Blob: Blob1 } = __webpack_require__("node:buffer");
        const assert = __webpack_require__("node:assert");
        const { isErrored, isDisturbed } = __webpack_require__("node:stream");
        const { isArrayBuffer } = __webpack_require__("node:util/types");
        const { serializeAMimeType } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/data-url.js");
        const { multipartFormDataParser } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/formdata-parser.js");
        let random;
        try {
            const crypto = __webpack_require__("node:crypto");
            random = (max)=>crypto.randomInt(0, max);
        } catch  {
            random = (max)=>Math.floor(Math.random(max));
        }
        const textEncoder = new TextEncoder();
        function noop() {}
        const hasFinalizationRegistry = globalThis.FinalizationRegistry && 0 !== process.version.indexOf('v18');
        let streamRegistry;
        if (hasFinalizationRegistry) streamRegistry = new FinalizationRegistry((weakRef)=>{
            const stream = weakRef.deref();
            if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) stream.cancel('Response object has been garbage collected').catch(noop);
        });
        function extractBody(object, keepalive = false) {
            let stream = null;
            stream = object instanceof ReadableStream ? object : isBlobLike(object) ? object.stream() : new ReadableStream({
                async pull (controller) {
                    const buffer = 'string' == typeof source ? textEncoder.encode(source) : source;
                    if (buffer.byteLength) controller.enqueue(buffer);
                    queueMicrotask(()=>readableStreamClose(controller));
                },
                start () {},
                type: 'bytes'
            });
            assert(isReadableStreamLike(stream));
            let action = null;
            let source = null;
            let length = null;
            let type = null;
            if ('string' == typeof object) {
                source = object;
                type = 'text/plain;charset=UTF-8';
            } else if (object instanceof URLSearchParams) {
                source = object.toString();
                type = 'application/x-www-form-urlencoded;charset=UTF-8';
            } else if (isArrayBuffer(object)) source = new Uint8Array(object.slice());
            else if (ArrayBuffer.isView(object)) source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
            else if (util.isFormDataLike(object)) {
                const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, '0')}`;
                const prefix = `--${boundary}\r\nContent-Disposition: form-data`;
                /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */ const escape = (str)=>str.replace(/\n/g, '%0A').replace(/\r/g, '%0D').replace(/"/g, '%22');
                const normalizeLinefeeds = (value)=>value.replace(/\r?\n|\r/g, '\r\n');
                const blobParts = [];
                const rn = new Uint8Array([
                    13,
                    10
                ]);
                length = 0;
                let hasUnknownSizeValue = false;
                for (const [name, value] of object)if ('string' == typeof value) {
                    const chunk = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"` + `\r\n\r\n${normalizeLinefeeds(value)}\r\n`);
                    blobParts.push(chunk);
                    length += chunk.byteLength;
                } else {
                    const chunk = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : '') + '\r\n' + `Content-Type: ${value.type || 'application/octet-stream'}\r\n\r\n`);
                    blobParts.push(chunk, value, rn);
                    if ('number' == typeof value.size) length += chunk.byteLength + value.size + rn.byteLength;
                    else hasUnknownSizeValue = true;
                }
                const chunk = textEncoder.encode(`--${boundary}--\r\n`);
                blobParts.push(chunk);
                length += chunk.byteLength;
                if (hasUnknownSizeValue) length = null;
                source = object;
                action = async function*() {
                    for (const part of blobParts)if (part.stream) yield* part.stream();
                    else yield part;
                };
                type = `multipart/form-data; boundary=${boundary}`;
            } else if (isBlobLike(object)) {
                source = object;
                length = object.size;
                if (object.type) type = object.type;
            } else if ('function' == typeof object[Symbol.asyncIterator]) {
                if (keepalive) throw new TypeError('keepalive');
                if (util.isDisturbed(object) || object.locked) throw new TypeError('Response body object should not be disturbed or locked');
                stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
            }
            if ('string' == typeof source || util.isBuffer(source)) length = Buffer.byteLength(source);
            if (null != action) {
                let iterator;
                stream = new ReadableStream({
                    async start () {
                        iterator = action(object)[Symbol.asyncIterator]();
                    },
                    async pull (controller) {
                        const { value, done } = await iterator.next();
                        if (done) queueMicrotask(()=>{
                            controller.close();
                            controller.byobRequest?.respond(0);
                        });
                        else if (!isErrored(stream)) {
                            const buffer = new Uint8Array(value);
                            if (buffer.byteLength) controller.enqueue(buffer);
                        }
                        return controller.desiredSize > 0;
                    },
                    async cancel (reason) {
                        await iterator.return();
                    },
                    type: 'bytes'
                });
            }
            const body = {
                stream,
                source,
                length
            };
            return [
                body,
                type
            ];
        }
        function safelyExtractBody(object, keepalive = false) {
            if (object instanceof ReadableStream) {
                assert(!util.isDisturbed(object), 'The body has already been consumed.');
                assert(!object.locked, 'The stream is locked.');
            }
            return extractBody(object, keepalive);
        }
        function cloneBody(instance, body) {
            const [out1, out2] = body.stream.tee();
            body.stream = out1;
            return {
                stream: out2,
                length: body.length,
                source: body.source
            };
        }
        function throwIfAborted(state) {
            if (state.aborted) throw new DOMException('The operation was aborted.', 'AbortError');
        }
        function bodyMixinMethods(instance) {
            const methods = {
                blob () {
                    return consumeBody(this, (bytes)=>{
                        let mimeType = bodyMimeType(this);
                        if (null === mimeType) mimeType = '';
                        else if (mimeType) mimeType = serializeAMimeType(mimeType);
                        return new Blob1([
                            bytes
                        ], {
                            type: mimeType
                        });
                    }, instance);
                },
                arrayBuffer () {
                    return consumeBody(this, (bytes)=>new Uint8Array(bytes).buffer, instance);
                },
                text () {
                    return consumeBody(this, utf8DecodeBytes, instance);
                },
                json () {
                    return consumeBody(this, parseJSONFromBytes, instance);
                },
                formData () {
                    return consumeBody(this, (value)=>{
                        const mimeType = bodyMimeType(this);
                        if (null !== mimeType) switch(mimeType.essence){
                            case 'multipart/form-data':
                                {
                                    const parsed = multipartFormDataParser(value, mimeType);
                                    if ('failure' === parsed) throw new TypeError('Failed to parse body as FormData.');
                                    const fd = new FormData();
                                    fd[kState] = parsed;
                                    return fd;
                                }
                            case 'application/x-www-form-urlencoded':
                                {
                                    const entries = new URLSearchParams(value.toString());
                                    const fd = new FormData();
                                    for (const [name, value] of entries)fd.append(name, value);
                                    return fd;
                                }
                        }
                        throw new TypeError('Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".');
                    }, instance);
                },
                bytes () {
                    return consumeBody(this, (bytes)=>new Uint8Array(bytes), instance);
                }
            };
            return methods;
        }
        function mixinBody(prototype) {
            Object.assign(prototype.prototype, bodyMixinMethods(prototype));
        }
        async function consumeBody(object, convertBytesToJSValue, instance) {
            webidl.brandCheck(object, instance);
            if (bodyUnusable(object)) throw new TypeError('Body is unusable: Body has already been read');
            throwIfAborted(object[kState]);
            const promise = createDeferredPromise();
            const errorSteps = (error)=>promise.reject(error);
            const successSteps = (data)=>{
                try {
                    promise.resolve(convertBytesToJSValue(data));
                } catch (e) {
                    errorSteps(e);
                }
            };
            if (null == object[kState].body) {
                successSteps(Buffer.allocUnsafe(0));
                return promise.promise;
            }
            await fullyReadBody(object[kState].body, successSteps, errorSteps);
            return promise.promise;
        }
        function bodyUnusable(object) {
            const body = object[kState].body;
            return null != body && (body.stream.locked || util.isDisturbed(body.stream));
        }
        function parseJSONFromBytes(bytes) {
            return JSON.parse(utf8DecodeBytes(bytes));
        }
        function bodyMimeType(requestOrResponse) {
            const headers = requestOrResponse[kState].headersList;
            const mimeType = extractMimeType(headers);
            if ('failure' === mimeType) return null;
            return mimeType;
        }
        module.exports = {
            extractBody,
            safelyExtractBody,
            cloneBody,
            mixinBody,
            streamRegistry,
            hasFinalizationRegistry,
            bodyUnusable
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/constants.js" (module) {
        "use strict";
        const corsSafeListedMethods = [
            'GET',
            'HEAD',
            'POST'
        ];
        const corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
        const nullBodyStatus = [
            101,
            204,
            205,
            304
        ];
        const redirectStatus = [
            301,
            302,
            303,
            307,
            308
        ];
        const redirectStatusSet = new Set(redirectStatus);
        const badPorts = [
            '1',
            '7',
            '9',
            '11',
            '13',
            '15',
            '17',
            '19',
            '20',
            '21',
            '22',
            '23',
            '25',
            '37',
            '42',
            '43',
            '53',
            '69',
            '77',
            '79',
            '87',
            '95',
            '101',
            '102',
            '103',
            '104',
            '109',
            '110',
            '111',
            '113',
            '115',
            '117',
            '119',
            '123',
            '135',
            '137',
            '139',
            '143',
            '161',
            '179',
            '389',
            '427',
            '465',
            '512',
            '513',
            '514',
            '515',
            '526',
            '530',
            '531',
            '532',
            '540',
            '548',
            '554',
            '556',
            '563',
            '587',
            '601',
            '636',
            '989',
            '990',
            '993',
            '995',
            '1719',
            '1720',
            '1723',
            '2049',
            '3659',
            '4045',
            '4190',
            '5060',
            '5061',
            '6000',
            '6566',
            '6665',
            '6666',
            '6667',
            '6668',
            '6669',
            '6679',
            '6697',
            '10080'
        ];
        const badPortsSet = new Set(badPorts);
        const referrerPolicy = [
            '',
            'no-referrer',
            'no-referrer-when-downgrade',
            'same-origin',
            'origin',
            'strict-origin',
            'origin-when-cross-origin',
            'strict-origin-when-cross-origin',
            'unsafe-url'
        ];
        const referrerPolicySet = new Set(referrerPolicy);
        const requestRedirect = [
            'follow',
            'manual',
            'error'
        ];
        const safeMethods = [
            'GET',
            'HEAD',
            'OPTIONS',
            'TRACE'
        ];
        const safeMethodsSet = new Set(safeMethods);
        const requestMode = [
            'navigate',
            'same-origin',
            'no-cors',
            'cors'
        ];
        const requestCredentials = [
            'omit',
            'same-origin',
            'include'
        ];
        const requestCache = [
            'default',
            'no-store',
            'reload',
            'no-cache',
            'force-cache',
            'only-if-cached'
        ];
        const requestBodyHeader = [
            'content-encoding',
            'content-language',
            'content-location',
            'content-type',
            'content-length'
        ];
        const requestDuplex = [
            'half'
        ];
        const forbiddenMethods = [
            'CONNECT',
            'TRACE',
            'TRACK'
        ];
        const forbiddenMethodsSet = new Set(forbiddenMethods);
        const subresource = [
            'audio',
            'audioworklet',
            'font',
            'image',
            'manifest',
            'paintworklet',
            "script",
            'style',
            'track',
            'video',
            'xslt',
            ''
        ];
        const subresourceSet = new Set(subresource);
        module.exports = {
            subresource,
            forbiddenMethods,
            requestBodyHeader,
            referrerPolicy,
            requestRedirect,
            requestMode,
            requestCredentials,
            requestCache,
            redirectStatus,
            corsSafeListedMethods,
            nullBodyStatus,
            safeMethods,
            badPorts,
            requestDuplex,
            subresourceSet,
            badPortsSet,
            redirectStatusSet,
            corsSafeListedMethodsSet,
            safeMethodsSet,
            forbiddenMethodsSet,
            referrerPolicySet
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/data-url.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const assert = __webpack_require__("node:assert");
        const encoder = new TextEncoder();
        const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/;
        const HTTP_WHITESPACE_REGEX = /[\u000A\u000D\u0009\u0020]/;
        const ASCII_WHITESPACE_REPLACE_REGEX = /[\u0009\u000A\u000C\u000D\u0020]/g;
        const HTTP_QUOTED_STRING_TOKENS = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
        function dataURLProcessor(dataURL) {
            assert('data:' === dataURL.protocol);
            let input = URLSerializer(dataURL, true);
            input = input.slice(5);
            const position = {
                position: 0
            };
            let mimeType = collectASequenceOfCodePointsFast(',', input, position);
            const mimeTypeLength = mimeType.length;
            mimeType = removeASCIIWhitespace(mimeType, true, true);
            if (position.position >= input.length) return 'failure';
            position.position++;
            const encodedBody = input.slice(mimeTypeLength + 1);
            let body = stringPercentDecode(encodedBody);
            if (/;(\u0020){0,}base64$/i.test(mimeType)) {
                const stringBody = isomorphicDecode(body);
                body = forgivingBase64(stringBody);
                if ('failure' === body) return 'failure';
                mimeType = mimeType.slice(0, -6);
                mimeType = mimeType.replace(/(\u0020)+$/, '');
                mimeType = mimeType.slice(0, -1);
            }
            if (mimeType.startsWith(';')) mimeType = 'text/plain' + mimeType;
            let mimeTypeRecord = parseMIMEType(mimeType);
            if ('failure' === mimeTypeRecord) mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII');
            return {
                mimeType: mimeTypeRecord,
                body
            };
        }
        function URLSerializer(url, excludeFragment = false) {
            if (!excludeFragment) return url.href;
            const href = url.href;
            const hashLength = url.hash.length;
            const serialized = 0 === hashLength ? href : href.substring(0, href.length - hashLength);
            if (!hashLength && href.endsWith('#')) return serialized.slice(0, -1);
            return serialized;
        }
        function collectASequenceOfCodePoints(condition, input, position) {
            let result = '';
            while(position.position < input.length && condition(input[position.position])){
                result += input[position.position];
                position.position++;
            }
            return result;
        }
        function collectASequenceOfCodePointsFast(char, input, position) {
            const idx = input.indexOf(char, position.position);
            const start = position.position;
            if (-1 === idx) {
                position.position = input.length;
                return input.slice(start);
            }
            position.position = idx;
            return input.slice(start, position.position);
        }
        function stringPercentDecode(input) {
            const bytes = encoder.encode(input);
            return percentDecode(bytes);
        }
        function isHexCharByte(byte) {
            return byte >= 0x30 && byte <= 0x39 || byte >= 0x41 && byte <= 0x46 || byte >= 0x61 && byte <= 0x66;
        }
        function hexByteToNumber(byte) {
            return byte >= 0x30 && byte <= 0x39 ? byte - 48 : (0xDF & byte) - 55;
        }
        function percentDecode(input) {
            const length = input.length;
            const output = new Uint8Array(length);
            let j = 0;
            for(let i = 0; i < length; ++i){
                const byte = input[i];
                if (0x25 !== byte) output[j++] = byte;
                else if (0x25 !== byte || isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2])) {
                    output[j++] = hexByteToNumber(input[i + 1]) << 4 | hexByteToNumber(input[i + 2]);
                    i += 2;
                } else output[j++] = 0x25;
            }
            return length === j ? output : output.subarray(0, j);
        }
        function parseMIMEType(input) {
            input = removeHTTPWhitespace(input, true, true);
            const position = {
                position: 0
            };
            const type = collectASequenceOfCodePointsFast('/', input, position);
            if (0 === type.length || !HTTP_TOKEN_CODEPOINTS.test(type)) return 'failure';
            if (position.position > input.length) return 'failure';
            position.position++;
            let subtype = collectASequenceOfCodePointsFast(';', input, position);
            subtype = removeHTTPWhitespace(subtype, false, true);
            if (0 === subtype.length || !HTTP_TOKEN_CODEPOINTS.test(subtype)) return 'failure';
            const typeLowercase = type.toLowerCase();
            const subtypeLowercase = subtype.toLowerCase();
            const mimeType = {
                type: typeLowercase,
                subtype: subtypeLowercase,
                parameters: new Map(),
                essence: `${typeLowercase}/${subtypeLowercase}`
            };
            while(position.position < input.length){
                position.position++;
                collectASequenceOfCodePoints((char)=>HTTP_WHITESPACE_REGEX.test(char), input, position);
                let parameterName = collectASequenceOfCodePoints((char)=>';' !== char && '=' !== char, input, position);
                parameterName = parameterName.toLowerCase();
                if (position.position < input.length) {
                    if (';' === input[position.position]) continue;
                    position.position++;
                }
                if (position.position > input.length) break;
                let parameterValue = null;
                if ('"' === input[position.position]) {
                    parameterValue = collectAnHTTPQuotedString(input, position, true);
                    collectASequenceOfCodePointsFast(';', input, position);
                } else {
                    parameterValue = collectASequenceOfCodePointsFast(';', input, position);
                    parameterValue = removeHTTPWhitespace(parameterValue, false, true);
                    if (0 === parameterValue.length) continue;
                }
                if (0 !== parameterName.length && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (0 === parameterValue.length || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) mimeType.parameters.set(parameterName, parameterValue);
            }
            return mimeType;
        }
        function forgivingBase64(data) {
            data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, '');
            let dataLength = data.length;
            if (dataLength % 4 === 0) {
                if (0x003D === data.charCodeAt(dataLength - 1)) {
                    --dataLength;
                    if (0x003D === data.charCodeAt(dataLength - 1)) --dataLength;
                }
            }
            if (dataLength % 4 === 1) return 'failure';
            if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) return 'failure';
            const buffer = Buffer.from(data, 'base64');
            return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        }
        function collectAnHTTPQuotedString(input, position, extractValue) {
            const positionStart = position.position;
            let value = '';
            assert('"' === input[position.position]);
            position.position++;
            while(true){
                value += collectASequenceOfCodePoints((char)=>'"' !== char && '\\' !== char, input, position);
                if (position.position >= input.length) break;
                const quoteOrBackslash = input[position.position];
                position.position++;
                if ('\\' === quoteOrBackslash) {
                    if (position.position >= input.length) {
                        value += '\\';
                        break;
                    }
                    value += input[position.position];
                    position.position++;
                } else {
                    assert('"' === quoteOrBackslash);
                    break;
                }
            }
            if (extractValue) return value;
            return input.slice(positionStart, position.position);
        }
        function serializeAMimeType(mimeType) {
            assert('failure' !== mimeType);
            const { parameters, essence } = mimeType;
            let serialization = essence;
            for (let [name, value] of parameters.entries()){
                serialization += ';';
                serialization += name;
                serialization += '=';
                if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
                    value = value.replace(/(\\|")/g, '\\$1');
                    value = '"' + value;
                    value += '"';
                }
                serialization += value;
            }
            return serialization;
        }
        function isHTTPWhiteSpace(char) {
            return 0x00d === char || 0x00a === char || 0x009 === char || 0x020 === char;
        }
        function removeHTTPWhitespace(str, leading = true, trailing = true) {
            return removeChars(str, leading, trailing, isHTTPWhiteSpace);
        }
        function isASCIIWhitespace(char) {
            return 0x00d === char || 0x00a === char || 0x009 === char || 0x00c === char || 0x020 === char;
        }
        function removeASCIIWhitespace(str, leading = true, trailing = true) {
            return removeChars(str, leading, trailing, isASCIIWhitespace);
        }
        function removeChars(str, leading, trailing, predicate) {
            let lead = 0;
            let trail = str.length - 1;
            if (leading) while(lead < str.length && predicate(str.charCodeAt(lead)))lead++;
            if (trailing) while(trail > 0 && predicate(str.charCodeAt(trail)))trail--;
            return 0 === lead && trail === str.length - 1 ? str : str.slice(lead, trail + 1);
        }
        function isomorphicDecode(input) {
            const length = input.length;
            if (65535 > length) return String.fromCharCode.apply(null, input);
            let result = '';
            let i = 0;
            let addition = 65535;
            while(i < length){
                if (i + addition > length) addition = length - i;
                result += String.fromCharCode.apply(null, input.subarray(i, i += addition));
            }
            return result;
        }
        function minimizeSupportedMimeType(mimeType) {
            switch(mimeType.essence){
                case "application/ecmascript":
                case "application/javascript":
                case "application/x-ecmascript":
                case "application/x-javascript":
                case "text/ecmascript":
                case "text/javascript":
                case "text/javascript1.0":
                case "text/javascript1.1":
                case "text/javascript1.2":
                case "text/javascript1.3":
                case "text/javascript1.4":
                case "text/javascript1.5":
                case "text/jscript":
                case "text/livescript":
                case "text/x-ecmascript":
                case "text/x-javascript":
                    return "text/javascript";
                case 'application/json':
                case 'text/json':
                    return 'application/json';
                case 'image/svg+xml':
                    return 'image/svg+xml';
                case 'text/xml':
                case 'application/xml':
                    return 'application/xml';
            }
            if (mimeType.subtype.endsWith('+json')) return 'application/json';
            if (mimeType.subtype.endsWith('+xml')) return 'application/xml';
            return '';
        }
        module.exports = {
            dataURLProcessor,
            URLSerializer,
            collectASequenceOfCodePoints,
            collectASequenceOfCodePointsFast,
            stringPercentDecode,
            parseMIMEType,
            collectAnHTTPQuotedString,
            serializeAMimeType,
            removeChars,
            removeHTTPWhitespace,
            minimizeSupportedMimeType,
            HTTP_TOKEN_CODEPOINTS,
            isomorphicDecode
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/dispatcher-weakref.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { kConnected, kSize } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        class CompatWeakRef {
            constructor(value){
                this.value = value;
            }
            deref() {
                return 0 === this.value[kConnected] && 0 === this.value[kSize] ? void 0 : this.value;
            }
        }
        class CompatFinalizer {
            constructor(finalizer){
                this.finalizer = finalizer;
            }
            register(dispatcher, key) {
                if (dispatcher.on) dispatcher.on('disconnect', ()=>{
                    if (0 === dispatcher[kConnected] && 0 === dispatcher[kSize]) this.finalizer(key);
                });
            }
            unregister(key) {}
        }
        module.exports = function() {
            if (process.env.NODE_V8_COVERAGE && process.version.startsWith('v18')) {
                process._rawDebug('Using compatibility WeakRef and FinalizationRegistry');
                return {
                    WeakRef: CompatWeakRef,
                    FinalizationRegistry: CompatFinalizer
                };
            }
            return {
                WeakRef,
                FinalizationRegistry
            };
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/file.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { Blob: Blob1, File } = __webpack_require__("node:buffer");
        const { kState } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/symbols.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/webidl.js");
        class FileLike {
            constructor(blobLike, fileName, options = {}){
                const n = fileName;
                const t = options.type;
                const d = options.lastModified ?? Date.now();
                this[kState] = {
                    blobLike,
                    name: n,
                    type: t,
                    lastModified: d
                };
            }
            stream(...args) {
                webidl.brandCheck(this, FileLike);
                return this[kState].blobLike.stream(...args);
            }
            arrayBuffer(...args) {
                webidl.brandCheck(this, FileLike);
                return this[kState].blobLike.arrayBuffer(...args);
            }
            slice(...args) {
                webidl.brandCheck(this, FileLike);
                return this[kState].blobLike.slice(...args);
            }
            text(...args) {
                webidl.brandCheck(this, FileLike);
                return this[kState].blobLike.text(...args);
            }
            get size() {
                webidl.brandCheck(this, FileLike);
                return this[kState].blobLike.size;
            }
            get type() {
                webidl.brandCheck(this, FileLike);
                return this[kState].blobLike.type;
            }
            get name() {
                webidl.brandCheck(this, FileLike);
                return this[kState].name;
            }
            get lastModified() {
                webidl.brandCheck(this, FileLike);
                return this[kState].lastModified;
            }
            get [Symbol.toStringTag]() {
                return 'File';
            }
        }
        webidl.converters.Blob = webidl.interfaceConverter(Blob1);
        function isFileLike(object) {
            return object instanceof File || object && ('function' == typeof object.stream || 'function' == typeof object.arrayBuffer) && 'File' === object[Symbol.toStringTag];
        }
        module.exports = {
            FileLike,
            isFileLike
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/formdata-parser.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { isUSVString, bufferToLowerCasedHeaderName } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { utf8DecodeBytes } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/util.js");
        const { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/data-url.js");
        const { isFileLike } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/file.js");
        const { makeEntry } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/formdata.js");
        const assert = __webpack_require__("node:assert");
        const { File: NodeFile } = __webpack_require__("node:buffer");
        const File = globalThis.File ?? NodeFile;
        const formDataNameBuffer = Buffer.from('form-data; name="');
        const filenameBuffer = Buffer.from('; filename');
        const dd = Buffer.from('--');
        const ddcrlf = Buffer.from('--\r\n');
        function isAsciiString(chars) {
            for(let i = 0; i < chars.length; ++i)if ((-128 & chars.charCodeAt(i)) !== 0) return false;
            return true;
        }
        function validateBoundary(boundary) {
            const length = boundary.length;
            if (length < 27 || length > 70) return false;
            for(let i = 0; i < length; ++i){
                const cp = boundary.charCodeAt(i);
                if (!(cp >= 0x30 && cp <= 0x39 || cp >= 0x41 && cp <= 0x5a || cp >= 0x61 && cp <= 0x7a || 0x27 === cp || 0x2d === cp || 0x5f === cp)) return false;
            }
            return true;
        }
        function multipartFormDataParser(input, mimeType) {
            assert('failure' !== mimeType && 'multipart/form-data' === mimeType.essence);
            const boundaryString = mimeType.parameters.get('boundary');
            if (void 0 === boundaryString) return 'failure';
            const boundary = Buffer.from(`--${boundaryString}`, 'utf8');
            const entryList = [];
            const position = {
                position: 0
            };
            while(0x0d === input[position.position] && 0x0a === input[position.position + 1])position.position += 2;
            let trailing = input.length;
            while(0x0a === input[trailing - 1] && 0x0d === input[trailing - 2])trailing -= 2;
            if (trailing !== input.length) input = input.subarray(0, trailing);
            while(true){
                if (!input.subarray(position.position, position.position + boundary.length).equals(boundary)) return 'failure';
                position.position += boundary.length;
                if (position.position === input.length - 2 && bufferStartsWith(input, dd, position) || position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position)) return entryList;
                if (0x0d !== input[position.position] || 0x0a !== input[position.position + 1]) return 'failure';
                position.position += 2;
                const result = parseMultipartFormDataHeaders(input, position);
                if ('failure' === result) return 'failure';
                let { name, filename, contentType, encoding } = result;
                position.position += 2;
                let body;
                {
                    const boundaryIndex = input.indexOf(boundary.subarray(2), position.position);
                    if (-1 === boundaryIndex) return 'failure';
                    body = input.subarray(position.position, boundaryIndex - 4);
                    position.position += body.length;
                    if ('base64' === encoding) body = Buffer.from(body.toString(), 'base64');
                }
                if (0x0d !== input[position.position] || 0x0a !== input[position.position + 1]) return 'failure';
                position.position += 2;
                let value;
                if (null !== filename) {
                    contentType ??= 'text/plain';
                    if (!isAsciiString(contentType)) contentType = '';
                    value = new File([
                        body
                    ], filename, {
                        type: contentType
                    });
                } else value = utf8DecodeBytes(Buffer.from(body));
                assert(isUSVString(name));
                assert('string' == typeof value && isUSVString(value) || isFileLike(value));
                entryList.push(makeEntry(name, value, filename));
            }
        }
        function parseMultipartFormDataHeaders(input, position) {
            let name = null;
            let filename = null;
            let contentType = null;
            let encoding = null;
            while(true){
                if (0x0d === input[position.position] && 0x0a === input[position.position + 1]) {
                    if (null === name) return 'failure';
                    return {
                        name,
                        filename,
                        contentType,
                        encoding
                    };
                }
                let headerName = collectASequenceOfBytes((char)=>0x0a !== char && 0x0d !== char && 0x3a !== char, input, position);
                headerName = removeChars(headerName, true, true, (char)=>0x9 === char || 0x20 === char);
                if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) return 'failure';
                if (0x3a !== input[position.position]) return 'failure';
                position.position++;
                collectASequenceOfBytes((char)=>0x20 === char || 0x09 === char, input, position);
                switch(bufferToLowerCasedHeaderName(headerName)){
                    case 'content-disposition':
                        name = filename = null;
                        if (!bufferStartsWith(input, formDataNameBuffer, position)) return 'failure';
                        position.position += 17;
                        name = parseMultipartFormDataName(input, position);
                        if (null === name) return 'failure';
                        if (bufferStartsWith(input, filenameBuffer, position)) {
                            let check = position.position + filenameBuffer.length;
                            if (0x2a === input[check]) {
                                position.position += 1;
                                check += 1;
                            }
                            if (0x3d !== input[check] || 0x22 !== input[check + 1]) return 'failure';
                            position.position += 12;
                            filename = parseMultipartFormDataName(input, position);
                            if (null === filename) return 'failure';
                        }
                        break;
                    case 'content-type':
                        {
                            let headerValue = collectASequenceOfBytes((char)=>0x0a !== char && 0x0d !== char, input, position);
                            headerValue = removeChars(headerValue, false, true, (char)=>0x9 === char || 0x20 === char);
                            contentType = isomorphicDecode(headerValue);
                            break;
                        }
                    case 'content-transfer-encoding':
                        {
                            let headerValue = collectASequenceOfBytes((char)=>0x0a !== char && 0x0d !== char, input, position);
                            headerValue = removeChars(headerValue, false, true, (char)=>0x9 === char || 0x20 === char);
                            encoding = isomorphicDecode(headerValue);
                            break;
                        }
                    default:
                        collectASequenceOfBytes((char)=>0x0a !== char && 0x0d !== char, input, position);
                }
                if (0x0d !== input[position.position] && 0x0a !== input[position.position + 1]) return 'failure';
                position.position += 2;
            }
        }
        function parseMultipartFormDataName(input, position) {
            assert(0x22 === input[position.position - 1]);
            let name = collectASequenceOfBytes((char)=>0x0a !== char && 0x0d !== char && 0x22 !== char, input, position);
            if (0x22 !== input[position.position]) return null;
            position.position++;
            name = new TextDecoder().decode(name).replace(/%0A/ig, '\n').replace(/%0D/ig, '\r').replace(/%22/g, '"');
            return name;
        }
        function collectASequenceOfBytes(condition, input, position) {
            let start = position.position;
            while(start < input.length && condition(input[start]))++start;
            return input.subarray(position.position, position.position = start);
        }
        function removeChars(buf, leading, trailing, predicate) {
            let lead = 0;
            let trail = buf.length - 1;
            if (leading) while(lead < buf.length && predicate(buf[lead]))lead++;
            if (trailing) while(trail > 0 && predicate(buf[trail]))trail--;
            return 0 === lead && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1);
        }
        function bufferStartsWith(buffer, start, position) {
            if (buffer.length < start.length) return false;
            for(let i = 0; i < start.length; i++)if (start[i] !== buffer[position.position + i]) return false;
            return true;
        }
        module.exports = {
            multipartFormDataParser,
            validateBoundary
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/formdata.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { isBlobLike, iteratorMixin } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/util.js");
        const { kState } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/symbols.js");
        const { kEnumerableProperty } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { FileLike, isFileLike } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/file.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/webidl.js");
        const { File: NativeFile } = __webpack_require__("node:buffer");
        const nodeUtil = __webpack_require__("node:util");
        const File = globalThis.File ?? NativeFile;
        class FormData {
            constructor(form){
                webidl.util.markAsUncloneable(this);
                if (void 0 !== form) throw webidl.errors.conversionFailed({
                    prefix: 'FormData constructor',
                    argument: 'Argument 1',
                    types: [
                        'undefined'
                    ]
                });
                this[kState] = [];
            }
            append(name, value, filename) {
                webidl.brandCheck(this, FormData);
                const prefix = 'FormData.append';
                webidl.argumentLengthCheck(arguments, 2, prefix);
                if (3 === arguments.length && !isBlobLike(value)) throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
                name = webidl.converters.USVString(name, prefix, 'name');
                value = isBlobLike(value) ? webidl.converters.Blob(value, prefix, 'value', {
                    strict: false
                }) : webidl.converters.USVString(value, prefix, 'value');
                filename = 3 === arguments.length ? webidl.converters.USVString(filename, prefix, 'filename') : void 0;
                const entry = makeEntry(name, value, filename);
                this[kState].push(entry);
            }
            delete(name) {
                webidl.brandCheck(this, FormData);
                const prefix = 'FormData.delete';
                webidl.argumentLengthCheck(arguments, 1, prefix);
                name = webidl.converters.USVString(name, prefix, 'name');
                this[kState] = this[kState].filter((entry)=>entry.name !== name);
            }
            get(name) {
                webidl.brandCheck(this, FormData);
                const prefix = 'FormData.get';
                webidl.argumentLengthCheck(arguments, 1, prefix);
                name = webidl.converters.USVString(name, prefix, 'name');
                const idx = this[kState].findIndex((entry)=>entry.name === name);
                if (-1 === idx) return null;
                return this[kState][idx].value;
            }
            getAll(name) {
                webidl.brandCheck(this, FormData);
                const prefix = 'FormData.getAll';
                webidl.argumentLengthCheck(arguments, 1, prefix);
                name = webidl.converters.USVString(name, prefix, 'name');
                return this[kState].filter((entry)=>entry.name === name).map((entry)=>entry.value);
            }
            has(name) {
                webidl.brandCheck(this, FormData);
                const prefix = 'FormData.has';
                webidl.argumentLengthCheck(arguments, 1, prefix);
                name = webidl.converters.USVString(name, prefix, 'name');
                return -1 !== this[kState].findIndex((entry)=>entry.name === name);
            }
            set(name, value, filename) {
                webidl.brandCheck(this, FormData);
                const prefix = 'FormData.set';
                webidl.argumentLengthCheck(arguments, 2, prefix);
                if (3 === arguments.length && !isBlobLike(value)) throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
                name = webidl.converters.USVString(name, prefix, 'name');
                value = isBlobLike(value) ? webidl.converters.Blob(value, prefix, 'name', {
                    strict: false
                }) : webidl.converters.USVString(value, prefix, 'name');
                filename = 3 === arguments.length ? webidl.converters.USVString(filename, prefix, 'name') : void 0;
                const entry = makeEntry(name, value, filename);
                const idx = this[kState].findIndex((entry)=>entry.name === name);
                if (-1 !== idx) this[kState] = [
                    ...this[kState].slice(0, idx),
                    entry,
                    ...this[kState].slice(idx + 1).filter((entry)=>entry.name !== name)
                ];
                else this[kState].push(entry);
            }
            [nodeUtil.inspect.custom](depth, options) {
                const state = this[kState].reduce((a, b)=>{
                    if (a[b.name]) if (Array.isArray(a[b.name])) a[b.name].push(b.value);
                    else a[b.name] = [
                        a[b.name],
                        b.value
                    ];
                    else a[b.name] = b.value;
                    return a;
                }, {
                    __proto__: null
                });
                options.depth ??= depth;
                options.colors ??= true;
                const output = nodeUtil.formatWithOptions(options, state);
                return `FormData ${output.slice(output.indexOf(']') + 2)}`;
            }
        }
        iteratorMixin('FormData', FormData, kState, 'name', 'value');
        Object.defineProperties(FormData.prototype, {
            append: kEnumerableProperty,
            delete: kEnumerableProperty,
            get: kEnumerableProperty,
            getAll: kEnumerableProperty,
            has: kEnumerableProperty,
            set: kEnumerableProperty,
            [Symbol.toStringTag]: {
                value: 'FormData',
                configurable: true
            }
        });
        function makeEntry(name, value, filename) {
            if ('string' == typeof value) ;
            else {
                if (!isFileLike(value)) value = value instanceof Blob ? new File([
                    value
                ], 'blob', {
                    type: value.type
                }) : new FileLike(value, 'blob', {
                    type: value.type
                });
                if (void 0 !== filename) {
                    const options = {
                        type: value.type,
                        lastModified: value.lastModified
                    };
                    value = value instanceof NativeFile ? new File([
                        value
                    ], filename, options) : new FileLike(value, filename, options);
                }
            }
            return {
                name,
                value
            };
        }
        module.exports = {
            FormData,
            makeEntry
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/global.js" (module) {
        "use strict";
        const globalOrigin = Symbol.for('undici.globalOrigin.1');
        function getGlobalOrigin() {
            return globalThis[globalOrigin];
        }
        function setGlobalOrigin(newOrigin) {
            if (void 0 === newOrigin) return void Object.defineProperty(globalThis, globalOrigin, {
                value: void 0,
                writable: true,
                enumerable: false,
                configurable: false
            });
            const parsedURL = new URL(newOrigin);
            if ('http:' !== parsedURL.protocol && 'https:' !== parsedURL.protocol) throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
            Object.defineProperty(globalThis, globalOrigin, {
                value: parsedURL,
                writable: true,
                enumerable: false,
                configurable: false
            });
        }
        module.exports = {
            getGlobalOrigin,
            setGlobalOrigin
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/headers.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { kConstruct } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const { kEnumerableProperty } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { iteratorMixin, isValidHeaderName, isValidHeaderValue } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/util.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/webidl.js");
        const assert = __webpack_require__("node:assert");
        const util = __webpack_require__("node:util");
        const kHeadersMap = Symbol('headers map');
        const kHeadersSortedMap = Symbol('headers map sorted');
        function isHTTPWhiteSpaceCharCode(code) {
            return 0x00a === code || 0x00d === code || 0x009 === code || 0x020 === code;
        }
        function headerValueNormalize(potentialValue) {
            let i = 0;
            let j = potentialValue.length;
            while(j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1)))--j;
            while(j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i)))++i;
            return 0 === i && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
        }
        function fill(headers, object) {
            if (Array.isArray(object)) for(let i = 0; i < object.length; ++i){
                const header = object[i];
                if (2 !== header.length) throw webidl.errors.exception({
                    header: 'Headers constructor',
                    message: `expected name/value pair to be length 2, found ${header.length}.`
                });
                appendHeader(headers, header[0], header[1]);
            }
            else if ('object' == typeof object && null !== object) {
                const keys = Object.keys(object);
                for(let i = 0; i < keys.length; ++i)appendHeader(headers, keys[i], object[keys[i]]);
            } else throw webidl.errors.conversionFailed({
                prefix: 'Headers constructor',
                argument: 'Argument 1',
                types: [
                    'sequence<sequence<ByteString>>',
                    'record<ByteString, ByteString>'
                ]
            });
        }
        function appendHeader(headers, name, value) {
            value = headerValueNormalize(value);
            if (isValidHeaderName(name)) {
                if (!isValidHeaderValue(value)) throw webidl.errors.invalidArgument({
                    prefix: 'Headers.append',
                    value,
                    type: 'header value'
                });
            } else throw webidl.errors.invalidArgument({
                prefix: 'Headers.append',
                value: name,
                type: 'header name'
            });
            if ('immutable' === getHeadersGuard(headers)) throw new TypeError('immutable');
            return getHeadersList(headers).append(name, value, false);
        }
        function compareHeaderName(a, b) {
            return a[0] < b[0] ? -1 : 1;
        }
        class HeadersList {
            cookies = null;
            constructor(init){
                if (init instanceof HeadersList) {
                    this[kHeadersMap] = new Map(init[kHeadersMap]);
                    this[kHeadersSortedMap] = init[kHeadersSortedMap];
                    this.cookies = null === init.cookies ? null : [
                        ...init.cookies
                    ];
                } else {
                    this[kHeadersMap] = new Map(init);
                    this[kHeadersSortedMap] = null;
                }
            }
            contains(name, isLowerCase) {
                return this[kHeadersMap].has(isLowerCase ? name : name.toLowerCase());
            }
            clear() {
                this[kHeadersMap].clear();
                this[kHeadersSortedMap] = null;
                this.cookies = null;
            }
            append(name, value, isLowerCase) {
                this[kHeadersSortedMap] = null;
                const lowercaseName = isLowerCase ? name : name.toLowerCase();
                const exists = this[kHeadersMap].get(lowercaseName);
                if (exists) {
                    const delimiter = 'cookie' === lowercaseName ? '; ' : ', ';
                    this[kHeadersMap].set(lowercaseName, {
                        name: exists.name,
                        value: `${exists.value}${delimiter}${value}`
                    });
                } else this[kHeadersMap].set(lowercaseName, {
                    name,
                    value
                });
                if ('set-cookie' === lowercaseName) (this.cookies ??= []).push(value);
            }
            set(name, value, isLowerCase) {
                this[kHeadersSortedMap] = null;
                const lowercaseName = isLowerCase ? name : name.toLowerCase();
                if ('set-cookie' === lowercaseName) this.cookies = [
                    value
                ];
                this[kHeadersMap].set(lowercaseName, {
                    name,
                    value
                });
            }
            delete(name, isLowerCase) {
                this[kHeadersSortedMap] = null;
                if (!isLowerCase) name = name.toLowerCase();
                if ('set-cookie' === name) this.cookies = null;
                this[kHeadersMap].delete(name);
            }
            get(name, isLowerCase) {
                return this[kHeadersMap].get(isLowerCase ? name : name.toLowerCase())?.value ?? null;
            }
            *[Symbol.iterator]() {
                for (const { 0: name, 1: { value } } of this[kHeadersMap])yield [
                    name,
                    value
                ];
            }
            get entries() {
                const headers = {};
                if (0 !== this[kHeadersMap].size) for (const { name, value } of this[kHeadersMap].values())headers[name] = value;
                return headers;
            }
            rawValues() {
                return this[kHeadersMap].values();
            }
            get entriesList() {
                const headers = [];
                if (0 !== this[kHeadersMap].size) for (const { 0: lowerName, 1: { name, value } } of this[kHeadersMap])if ('set-cookie' === lowerName) for (const cookie of this.cookies)headers.push([
                    name,
                    cookie
                ]);
                else headers.push([
                    name,
                    value
                ]);
                return headers;
            }
            toSortedArray() {
                const size = this[kHeadersMap].size;
                const array = new Array(size);
                if (size <= 32) {
                    if (0 === size) return array;
                    const iterator = this[kHeadersMap][Symbol.iterator]();
                    const firstValue = iterator.next().value;
                    array[0] = [
                        firstValue[0],
                        firstValue[1].value
                    ];
                    assert(null !== firstValue[1].value);
                    for(let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value; i < size; ++i){
                        value = iterator.next().value;
                        x = array[i] = [
                            value[0],
                            value[1].value
                        ];
                        assert(null !== x[1]);
                        left = 0;
                        right = i;
                        while(left < right){
                            pivot = left + (right - left >> 1);
                            if (array[pivot][0] <= x[0]) left = pivot + 1;
                            else right = pivot;
                        }
                        if (i !== pivot) {
                            j = i;
                            while(j > left)array[j] = array[--j];
                            array[left] = x;
                        }
                    }
                    if (!iterator.next().done) throw new TypeError('Unreachable');
                    return array;
                }
                {
                    let i = 0;
                    for (const { 0: name, 1: { value } } of this[kHeadersMap]){
                        array[i++] = [
                            name,
                            value
                        ];
                        assert(null !== value);
                    }
                    return array.sort(compareHeaderName);
                }
            }
        }
        class Headers {
            #guard;
            #headersList;
            constructor(init){
                webidl.util.markAsUncloneable(this);
                if (init === kConstruct) return;
                this.#headersList = new HeadersList();
                this.#guard = 'none';
                if (void 0 !== init) {
                    init = webidl.converters.HeadersInit(init, 'Headers contructor', 'init');
                    fill(this, init);
                }
            }
            append(name, value) {
                webidl.brandCheck(this, Headers);
                webidl.argumentLengthCheck(arguments, 2, 'Headers.append');
                const prefix = 'Headers.append';
                name = webidl.converters.ByteString(name, prefix, 'name');
                value = webidl.converters.ByteString(value, prefix, 'value');
                return appendHeader(this, name, value);
            }
            delete(name) {
                webidl.brandCheck(this, Headers);
                webidl.argumentLengthCheck(arguments, 1, 'Headers.delete');
                const prefix = 'Headers.delete';
                name = webidl.converters.ByteString(name, prefix, 'name');
                if (!isValidHeaderName(name)) throw webidl.errors.invalidArgument({
                    prefix: 'Headers.delete',
                    value: name,
                    type: 'header name'
                });
                if ('immutable' === this.#guard) throw new TypeError('immutable');
                if (!this.#headersList.contains(name, false)) return;
                this.#headersList.delete(name, false);
            }
            get(name) {
                webidl.brandCheck(this, Headers);
                webidl.argumentLengthCheck(arguments, 1, 'Headers.get');
                const prefix = 'Headers.get';
                name = webidl.converters.ByteString(name, prefix, 'name');
                if (!isValidHeaderName(name)) throw webidl.errors.invalidArgument({
                    prefix,
                    value: name,
                    type: 'header name'
                });
                return this.#headersList.get(name, false);
            }
            has(name) {
                webidl.brandCheck(this, Headers);
                webidl.argumentLengthCheck(arguments, 1, 'Headers.has');
                const prefix = 'Headers.has';
                name = webidl.converters.ByteString(name, prefix, 'name');
                if (!isValidHeaderName(name)) throw webidl.errors.invalidArgument({
                    prefix,
                    value: name,
                    type: 'header name'
                });
                return this.#headersList.contains(name, false);
            }
            set(name, value) {
                webidl.brandCheck(this, Headers);
                webidl.argumentLengthCheck(arguments, 2, 'Headers.set');
                const prefix = 'Headers.set';
                name = webidl.converters.ByteString(name, prefix, 'name');
                value = webidl.converters.ByteString(value, prefix, 'value');
                value = headerValueNormalize(value);
                if (isValidHeaderName(name)) {
                    if (!isValidHeaderValue(value)) throw webidl.errors.invalidArgument({
                        prefix,
                        value,
                        type: 'header value'
                    });
                } else throw webidl.errors.invalidArgument({
                    prefix,
                    value: name,
                    type: 'header name'
                });
                if ('immutable' === this.#guard) throw new TypeError('immutable');
                this.#headersList.set(name, value, false);
            }
            getSetCookie() {
                webidl.brandCheck(this, Headers);
                const list = this.#headersList.cookies;
                if (list) return [
                    ...list
                ];
                return [];
            }
            get [kHeadersSortedMap]() {
                if (this.#headersList[kHeadersSortedMap]) return this.#headersList[kHeadersSortedMap];
                const headers = [];
                const names = this.#headersList.toSortedArray();
                const cookies = this.#headersList.cookies;
                if (null === cookies || 1 === cookies.length) return this.#headersList[kHeadersSortedMap] = names;
                for(let i = 0; i < names.length; ++i){
                    const { 0: name, 1: value } = names[i];
                    if ('set-cookie' === name) for(let j = 0; j < cookies.length; ++j)headers.push([
                        name,
                        cookies[j]
                    ]);
                    else headers.push([
                        name,
                        value
                    ]);
                }
                return this.#headersList[kHeadersSortedMap] = headers;
            }
            [util.inspect.custom](depth, options) {
                options.depth ??= depth;
                return `Headers ${util.formatWithOptions(options, this.#headersList.entries)}`;
            }
            static getHeadersGuard(o) {
                return o.#guard;
            }
            static setHeadersGuard(o, guard) {
                o.#guard = guard;
            }
            static getHeadersList(o) {
                return o.#headersList;
            }
            static setHeadersList(o, list) {
                o.#headersList = list;
            }
        }
        const { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers;
        Reflect.deleteProperty(Headers, 'getHeadersGuard');
        Reflect.deleteProperty(Headers, 'setHeadersGuard');
        Reflect.deleteProperty(Headers, 'getHeadersList');
        Reflect.deleteProperty(Headers, 'setHeadersList');
        iteratorMixin('Headers', Headers, kHeadersSortedMap, 0, 1);
        Object.defineProperties(Headers.prototype, {
            append: kEnumerableProperty,
            delete: kEnumerableProperty,
            get: kEnumerableProperty,
            has: kEnumerableProperty,
            set: kEnumerableProperty,
            getSetCookie: kEnumerableProperty,
            [Symbol.toStringTag]: {
                value: 'Headers',
                configurable: true
            },
            [util.inspect.custom]: {
                enumerable: false
            }
        });
        webidl.converters.HeadersInit = function(V, prefix, argument) {
            if ('Object' === webidl.util.Type(V)) {
                const iterator = Reflect.get(V, Symbol.iterator);
                if (!util.types.isProxy(V) && iterator === Headers.prototype.entries) try {
                    return getHeadersList(V).entriesList;
                } catch  {}
                if ('function' == typeof iterator) return webidl.converters['sequence<sequence<ByteString>>'](V, prefix, argument, iterator.bind(V));
                return webidl.converters['record<ByteString, ByteString>'](V, prefix, argument);
            }
            throw webidl.errors.conversionFailed({
                prefix: 'Headers constructor',
                argument: 'Argument 1',
                types: [
                    'sequence<sequence<ByteString>>',
                    'record<ByteString, ByteString>'
                ]
            });
        };
        module.exports = {
            fill,
            compareHeaderName,
            Headers,
            HeadersList,
            getHeadersGuard,
            setHeadersGuard,
            setHeadersList,
            getHeadersList
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { makeNetworkError, makeAppropriateNetworkError, filterResponse, makeResponse, fromInnerResponse } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/response.js");
        const { HeadersList } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/headers.js");
        const { Request, cloneRequest } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/request.js");
        const zlib = __webpack_require__("node:zlib");
        const { bytesMatch, makePolicyContainer, clonePolicyContainer, requestBadPort, TAOCheck, appendRequestOriginHeader, responseLocationURL, requestCurrentURL, setRequestReferrerPolicyOnRedirect, tryUpgradeRequestToAPotentiallyTrustworthyURL, createOpaqueTimingInfo, appendFetchMetadata, corsCheck, crossOriginResourcePolicyCheck, determineRequestsReferrer, coarsenedSharedCurrentTime, createDeferredPromise, isBlobLike, sameOrigin, isCancelled, isAborted, isErrorLike, fullyReadBody, readableStreamClose, isomorphicEncode, urlIsLocal, urlIsHttpHttpsScheme, urlHasHttpsScheme, clampAndCoarsenConnectionTimingInfo, simpleRangeHeaderValue, buildContentRange, createInflate, extractMimeType } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/util.js");
        const { kState, kDispatcher } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/symbols.js");
        const assert = __webpack_require__("node:assert");
        const { safelyExtractBody, extractBody } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/body.js");
        const { redirectStatusSet, nullBodyStatus, safeMethodsSet, requestBodyHeader, subresourceSet } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/constants.js");
        const EE = __webpack_require__("node:events");
        const { Readable, pipeline, finished } = __webpack_require__("node:stream");
        const { addAbortListener, isErrored, isReadable, bufferToLowerCasedHeaderName } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/data-url.js");
        const { getGlobalDispatcher } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/global.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/webidl.js");
        const { STATUS_CODES } = __webpack_require__("node:http");
        const GET_OR_HEAD = [
            'GET',
            'HEAD'
        ];
        const defaultUserAgent = "u" > typeof __UNDICI_IS_NODE__ || "u" > typeof esbuildDetection ? 'node' : 'undici';
        let resolveObjectURL;
        class Fetch extends EE {
            constructor(dispatcher){
                super();
                this.dispatcher = dispatcher;
                this.connection = null;
                this.dump = false;
                this.state = 'ongoing';
            }
            terminate(reason) {
                if ('ongoing' !== this.state) return;
                this.state = 'terminated';
                this.connection?.destroy(reason);
                this.emit('terminated', reason);
            }
            abort(error) {
                if ('ongoing' !== this.state) return;
                this.state = 'aborted';
                if (!error) error = new DOMException('The operation was aborted.', 'AbortError');
                this.serializedAbortReason = error;
                this.connection?.destroy(error);
                this.emit('terminated', error);
            }
        }
        function handleFetchDone(response) {
            finalizeAndReportTiming(response, 'fetch');
        }
        function fetch(input, init) {
            webidl.argumentLengthCheck(arguments, 1, 'globalThis.fetch');
            let p = createDeferredPromise();
            let requestObject;
            try {
                requestObject = new Request(input, init);
            } catch (e) {
                p.reject(e);
                return p.promise;
            }
            const request = requestObject[kState];
            if (requestObject.signal.aborted) {
                abortFetch(p, request, null, requestObject.signal.reason);
                return p.promise;
            }
            const globalObject = request.client.globalObject;
            if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') request.serviceWorkers = 'none';
            let responseObject = null;
            let locallyAborted = false;
            let controller = null;
            addAbortListener(requestObject.signal, ()=>{
                locallyAborted = true;
                assert(null != controller);
                controller.abort(requestObject.signal.reason);
                const realResponse = responseObject?.deref();
                abortFetch(p, request, realResponse, requestObject.signal.reason);
            });
            const processResponse = (response)=>{
                if (locallyAborted) return;
                if (response.aborted) return void abortFetch(p, request, responseObject, controller.serializedAbortReason);
                if ('error' === response.type) return void p.reject(new TypeError('fetch failed', {
                    cause: response.error
                }));
                responseObject = new WeakRef(fromInnerResponse(response, 'immutable'));
                p.resolve(responseObject.deref());
                p = null;
            };
            controller = fetching({
                request,
                processResponseEndOfBody: handleFetchDone,
                processResponse,
                dispatcher: requestObject[kDispatcher]
            });
            return p.promise;
        }
        function finalizeAndReportTiming(response, initiatorType = 'other') {
            if ('error' === response.type && response.aborted) return;
            if (!response.urlList?.length) return;
            const originalURL = response.urlList[0];
            let timingInfo = response.timingInfo;
            let cacheState = response.cacheState;
            if (!urlIsHttpHttpsScheme(originalURL)) return;
            if (null === timingInfo) return;
            if (!response.timingAllowPassed) {
                timingInfo = createOpaqueTimingInfo({
                    startTime: timingInfo.startTime
                });
                cacheState = '';
            }
            timingInfo.endTime = coarsenedSharedCurrentTime();
            response.timingInfo = timingInfo;
            markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis, cacheState);
        }
        const markResourceTiming = performance.markResourceTiming;
        function abortFetch(p, request, responseObject, error) {
            if (p) p.reject(error);
            if (null != request.body && isReadable(request.body?.stream)) request.body.stream.cancel(error).catch((err)=>{
                if ('ERR_INVALID_STATE' === err.code) return;
                throw err;
            });
            if (null == responseObject) return;
            const response = responseObject[kState];
            if (null != response.body && isReadable(response.body?.stream)) response.body.stream.cancel(error).catch((err)=>{
                if ('ERR_INVALID_STATE' === err.code) return;
                throw err;
            });
        }
        function fetching({ request, processRequestBodyChunkLength, processRequestEndOfBody, processResponse, processResponseEndOfBody, processResponseConsumeBody, useParallelQueue = false, dispatcher = getGlobalDispatcher() }) {
            assert(dispatcher);
            let taskDestination = null;
            let crossOriginIsolatedCapability = false;
            if (null != request.client) {
                taskDestination = request.client.globalObject;
                crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
            }
            const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
            const timingInfo = createOpaqueTimingInfo({
                startTime: currentTime
            });
            const fetchParams = {
                controller: new Fetch(dispatcher),
                request,
                timingInfo,
                processRequestBodyChunkLength,
                processRequestEndOfBody,
                processResponse,
                processResponseConsumeBody,
                processResponseEndOfBody,
                taskDestination,
                crossOriginIsolatedCapability
            };
            assert(!request.body || request.body.stream);
            if ('client' === request.window) request.window = request.client?.globalObject?.constructor?.name === 'Window' ? request.client : 'no-window';
            if ('client' === request.origin) request.origin = request.client.origin;
            if ('client' === request.policyContainer) if (null != request.client) request.policyContainer = clonePolicyContainer(request.client.policyContainer);
            else request.policyContainer = makePolicyContainer();
            if (!request.headersList.contains('accept', true)) {
                const value = '*/*';
                request.headersList.append('accept', value, true);
            }
            if (!request.headersList.contains('accept-language', true)) request.headersList.append('accept-language', '*', true);
            request.priority;
            subresourceSet.has(request.destination);
            mainFetch(fetchParams).catch((err)=>{
                fetchParams.controller.terminate(err);
            });
            return fetchParams.controller;
        }
        async function mainFetch(fetchParams, recursive = false) {
            const request = fetchParams.request;
            let response = null;
            if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) response = makeNetworkError('local URLs only');
            tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
            if ('blocked' === requestBadPort(request)) response = makeNetworkError('bad port');
            if ('' === request.referrerPolicy) request.referrerPolicy = request.policyContainer.referrerPolicy;
            if ('no-referrer' !== request.referrer) request.referrer = determineRequestsReferrer(request);
            if (null === response) response = await (async ()=>{
                const currentURL = requestCurrentURL(request);
                if (sameOrigin(currentURL, request.url) && 'basic' === request.responseTainting || 'data:' === currentURL.protocol || 'navigate' === request.mode || 'websocket' === request.mode) {
                    request.responseTainting = 'basic';
                    return await schemeFetch(fetchParams);
                }
                if ('same-origin' === request.mode) return makeNetworkError('request mode cannot be "same-origin"');
                if ('no-cors' === request.mode) {
                    if ('follow' !== request.redirect) return makeNetworkError('redirect mode cannot be "follow" for "no-cors" request');
                    request.responseTainting = 'opaque';
                    return await schemeFetch(fetchParams);
                }
                if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) return makeNetworkError('URL scheme must be a HTTP(S) scheme');
                request.responseTainting = 'cors';
                return await httpFetch(fetchParams);
            })();
            if (recursive) return response;
            if (0 !== response.status && !response.internalResponse) {
                request.responseTainting;
                if ('basic' === request.responseTainting) response = filterResponse(response, 'basic');
                else if ('cors' === request.responseTainting) response = filterResponse(response, 'cors');
                else if ('opaque' === request.responseTainting) response = filterResponse(response, 'opaque');
                else assert(false);
            }
            let internalResponse = 0 === response.status ? response : response.internalResponse;
            if (0 === internalResponse.urlList.length) internalResponse.urlList.push(...request.urlList);
            if (!request.timingAllowFailed) response.timingAllowPassed = true;
            if ('opaque' === response.type && 206 === internalResponse.status && internalResponse.rangeRequested && !request.headers.contains('range', true)) response = internalResponse = makeNetworkError();
            if (0 !== response.status && ('HEAD' === request.method || 'CONNECT' === request.method || nullBodyStatus.includes(internalResponse.status))) {
                internalResponse.body = null;
                fetchParams.controller.dump = true;
            }
            if (request.integrity) {
                const processBodyError = (reason)=>fetchFinale(fetchParams, makeNetworkError(reason));
                if ('opaque' === request.responseTainting || null == response.body) return void processBodyError(response.error);
                const processBody = (bytes)=>{
                    if (!bytesMatch(bytes, request.integrity)) return void processBodyError('integrity mismatch');
                    response.body = safelyExtractBody(bytes)[0];
                    fetchFinale(fetchParams, response);
                };
                await fullyReadBody(response.body, processBody, processBodyError);
            } else fetchFinale(fetchParams, response);
        }
        function schemeFetch(fetchParams) {
            if (isCancelled(fetchParams) && 0 === fetchParams.request.redirectCount) return Promise.resolve(makeAppropriateNetworkError(fetchParams));
            const { request } = fetchParams;
            const { protocol: scheme } = requestCurrentURL(request);
            switch(scheme){
                case 'about:':
                    return Promise.resolve(makeNetworkError('about scheme is not supported'));
                case 'blob:':
                    {
                        if (!resolveObjectURL) resolveObjectURL = __webpack_require__("node:buffer").resolveObjectURL;
                        const blobURLEntry = requestCurrentURL(request);
                        if (0 !== blobURLEntry.search.length) return Promise.resolve(makeNetworkError('NetworkError when attempting to fetch resource.'));
                        const blob = resolveObjectURL(blobURLEntry.toString());
                        if ('GET' !== request.method || !isBlobLike(blob)) return Promise.resolve(makeNetworkError('invalid method'));
                        const response = makeResponse();
                        const fullLength = blob.size;
                        const serializedFullLength = isomorphicEncode(`${fullLength}`);
                        const type = blob.type;
                        if (request.headersList.contains('range', true)) {
                            response.rangeRequested = true;
                            const rangeHeader = request.headersList.get('range', true);
                            const rangeValue = simpleRangeHeaderValue(rangeHeader, true);
                            if ('failure' === rangeValue) return Promise.resolve(makeNetworkError('failed to fetch the data URL'));
                            let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue;
                            if (null === rangeStart) {
                                rangeStart = fullLength - rangeEnd;
                                rangeEnd = rangeStart + rangeEnd - 1;
                            } else {
                                if (rangeStart >= fullLength) return Promise.resolve(makeNetworkError('Range start is greater than the blob\'s size.'));
                                if (null === rangeEnd || rangeEnd >= fullLength) rangeEnd = fullLength - 1;
                            }
                            const slicedBlob = blob.slice(rangeStart, rangeEnd, type);
                            const slicedBodyWithType = extractBody(slicedBlob);
                            response.body = slicedBodyWithType[0];
                            const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`);
                            const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength);
                            response.status = 206;
                            response.statusText = 'Partial Content';
                            response.headersList.set('content-length', serializedSlicedLength, true);
                            response.headersList.set('content-type', type, true);
                            response.headersList.set('content-range', contentRange, true);
                        } else {
                            const bodyWithType = extractBody(blob);
                            response.statusText = 'OK';
                            response.body = bodyWithType[0];
                            response.headersList.set('content-length', serializedFullLength, true);
                            response.headersList.set('content-type', type, true);
                        }
                        return Promise.resolve(response);
                    }
                case 'data:':
                    {
                        const currentURL = requestCurrentURL(request);
                        const dataURLStruct = dataURLProcessor(currentURL);
                        if ('failure' === dataURLStruct) return Promise.resolve(makeNetworkError('failed to fetch the data URL'));
                        const mimeType = serializeAMimeType(dataURLStruct.mimeType);
                        return Promise.resolve(makeResponse({
                            statusText: 'OK',
                            headersList: [
                                [
                                    'content-type',
                                    {
                                        name: 'Content-Type',
                                        value: mimeType
                                    }
                                ]
                            ],
                            body: safelyExtractBody(dataURLStruct.body)[0]
                        }));
                    }
                case 'file:':
                    return Promise.resolve(makeNetworkError('not implemented... yet...'));
                case 'http:':
                case 'https:':
                    return httpFetch(fetchParams).catch((err)=>makeNetworkError(err));
                default:
                    return Promise.resolve(makeNetworkError('unknown scheme'));
            }
        }
        function finalizeResponse(fetchParams, response) {
            fetchParams.request.done = true;
            if (null != fetchParams.processResponseDone) queueMicrotask(()=>fetchParams.processResponseDone(response));
        }
        function fetchFinale(fetchParams, response) {
            let timingInfo = fetchParams.timingInfo;
            const processResponseEndOfBody = ()=>{
                const unsafeEndTime = Date.now();
                if ('document' === fetchParams.request.destination) fetchParams.controller.fullTimingInfo = timingInfo;
                fetchParams.controller.reportTimingSteps = ()=>{
                    if ('https:' !== fetchParams.request.url.protocol) return;
                    timingInfo.endTime = unsafeEndTime;
                    let cacheState = response.cacheState;
                    const bodyInfo = response.bodyInfo;
                    if (!response.timingAllowPassed) {
                        timingInfo = createOpaqueTimingInfo(timingInfo);
                        cacheState = '';
                    }
                    let responseStatus = 0;
                    if ('navigator' !== fetchParams.request.mode || !response.hasCrossOriginRedirects) {
                        responseStatus = response.status;
                        const mimeType = extractMimeType(response.headersList);
                        if ('failure' !== mimeType) bodyInfo.contentType = minimizeSupportedMimeType(mimeType);
                    }
                    if (null != fetchParams.request.initiatorType) markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus);
                };
                const processResponseEndOfBodyTask = ()=>{
                    fetchParams.request.done = true;
                    if (null != fetchParams.processResponseEndOfBody) queueMicrotask(()=>fetchParams.processResponseEndOfBody(response));
                    if (null != fetchParams.request.initiatorType) fetchParams.controller.reportTimingSteps();
                };
                queueMicrotask(()=>processResponseEndOfBodyTask());
            };
            if (null != fetchParams.processResponse) queueMicrotask(()=>{
                fetchParams.processResponse(response);
                fetchParams.processResponse = null;
            });
            const internalResponse = 'error' === response.type ? response : response.internalResponse ?? response;
            if (null == internalResponse.body) processResponseEndOfBody();
            else finished(internalResponse.body.stream, ()=>{
                processResponseEndOfBody();
            });
        }
        async function httpFetch(fetchParams) {
            const request = fetchParams.request;
            let response = null;
            let actualResponse = null;
            const timingInfo = fetchParams.timingInfo;
            request.serviceWorkers;
            if (null === response) {
                if ('follow' === request.redirect) request.serviceWorkers = 'none';
                actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
                if ('cors' === request.responseTainting && 'failure' === corsCheck(request, response)) return makeNetworkError('cors failure');
                if ('failure' === TAOCheck(request, response)) request.timingAllowFailed = true;
            }
            if (('opaque' === request.responseTainting || 'opaque' === response.type) && 'blocked' === crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse)) return makeNetworkError('blocked');
            if (redirectStatusSet.has(actualResponse.status)) {
                if ('manual' !== request.redirect) fetchParams.controller.connection.destroy(void 0, false);
                if ('error' === request.redirect) response = makeNetworkError('unexpected redirect');
                else if ('manual' === request.redirect) response = actualResponse;
                else if ('follow' === request.redirect) response = await httpRedirectFetch(fetchParams, response);
                else assert(false);
            }
            response.timingInfo = timingInfo;
            return response;
        }
        function httpRedirectFetch(fetchParams, response) {
            const request = fetchParams.request;
            const actualResponse = response.internalResponse ? response.internalResponse : response;
            let locationURL;
            try {
                locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash);
                if (null == locationURL) return response;
            } catch (err) {
                return Promise.resolve(makeNetworkError(err));
            }
            if (!urlIsHttpHttpsScheme(locationURL)) return Promise.resolve(makeNetworkError('URL scheme must be a HTTP(S) scheme'));
            if (20 === request.redirectCount) return Promise.resolve(makeNetworkError('redirect count exceeded'));
            request.redirectCount += 1;
            if ('cors' === request.mode && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
            if ('cors' === request.responseTainting && (locationURL.username || locationURL.password)) return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode "cors"'));
            if (303 !== actualResponse.status && null != request.body && null == request.body.source) return Promise.resolve(makeNetworkError());
            if ([
                301,
                302
            ].includes(actualResponse.status) && 'POST' === request.method || 303 === actualResponse.status && !GET_OR_HEAD.includes(request.method)) {
                request.method = 'GET';
                request.body = null;
                for (const headerName of requestBodyHeader)request.headersList.delete(headerName);
            }
            if (!sameOrigin(requestCurrentURL(request), locationURL)) {
                request.headersList.delete('authorization', true);
                request.headersList.delete('proxy-authorization', true);
                request.headersList.delete('cookie', true);
                request.headersList.delete('host', true);
            }
            if (null != request.body) {
                assert(null != request.body.source);
                request.body = safelyExtractBody(request.body.source)[0];
            }
            const timingInfo = fetchParams.timingInfo;
            timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
            if (0 === timingInfo.redirectStartTime) timingInfo.redirectStartTime = timingInfo.startTime;
            request.urlList.push(locationURL);
            setRequestReferrerPolicyOnRedirect(request, actualResponse);
            return mainFetch(fetchParams, true);
        }
        async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
            const request = fetchParams.request;
            let httpFetchParams = null;
            let httpRequest = null;
            let response = null;
            const httpCache = null;
            const revalidatingFlag = false;
            if ('no-window' === request.window && 'error' === request.redirect) {
                httpFetchParams = fetchParams;
                httpRequest = request;
            } else {
                httpRequest = cloneRequest(request);
                httpFetchParams = {
                    ...fetchParams
                };
                httpFetchParams.request = httpRequest;
            }
            const includeCredentials = 'include' === request.credentials || 'same-origin' === request.credentials && 'basic' === request.responseTainting;
            const contentLength = httpRequest.body ? httpRequest.body.length : null;
            let contentLengthHeaderValue = null;
            if (null == httpRequest.body && [
                'POST',
                'PUT'
            ].includes(httpRequest.method)) contentLengthHeaderValue = '0';
            if (null != contentLength) contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
            if (null != contentLengthHeaderValue) httpRequest.headersList.append('content-length', contentLengthHeaderValue, true);
            null != contentLength && httpRequest.keepalive;
            if (httpRequest.referrer instanceof URL) httpRequest.headersList.append('referer', isomorphicEncode(httpRequest.referrer.href), true);
            appendRequestOriginHeader(httpRequest);
            appendFetchMetadata(httpRequest);
            if (!httpRequest.headersList.contains('user-agent', true)) httpRequest.headersList.append('user-agent', defaultUserAgent);
            if ('default' === httpRequest.cache && (httpRequest.headersList.contains('if-modified-since', true) || httpRequest.headersList.contains('if-none-match', true) || httpRequest.headersList.contains('if-unmodified-since', true) || httpRequest.headersList.contains('if-match', true) || httpRequest.headersList.contains('if-range', true))) httpRequest.cache = 'no-store';
            if ('no-cache' === httpRequest.cache && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains('cache-control', true)) httpRequest.headersList.append('cache-control', 'max-age=0', true);
            if ('no-store' === httpRequest.cache || 'reload' === httpRequest.cache) {
                if (!httpRequest.headersList.contains('pragma', true)) httpRequest.headersList.append('pragma', 'no-cache', true);
                if (!httpRequest.headersList.contains('cache-control', true)) httpRequest.headersList.append('cache-control', 'no-cache', true);
            }
            if (httpRequest.headersList.contains('range', true)) httpRequest.headersList.append('accept-encoding', 'identity', true);
            if (!httpRequest.headersList.contains('accept-encoding', true)) if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate', true);
            else httpRequest.headersList.append('accept-encoding', 'gzip, deflate', true);
            httpRequest.headersList.delete('host', true);
            if (null == httpCache) httpRequest.cache = 'no-store';
            'no-store' !== httpRequest.cache && httpRequest.cache;
            if (null == response) {
                if ('only-if-cached' === httpRequest.cache) return makeNetworkError('only if cached');
                const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
                !safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status;
                revalidatingFlag && forwardResponse.status;
                if (null == response) response = forwardResponse;
            }
            response.urlList = [
                ...httpRequest.urlList
            ];
            if (httpRequest.headersList.contains('range', true)) response.rangeRequested = true;
            response.requestIncludesCredentials = includeCredentials;
            if (407 === response.status) {
                if ('no-window' === request.window) return makeNetworkError();
                if (isCancelled(fetchParams)) return makeAppropriateNetworkError(fetchParams);
                return makeNetworkError('proxy authentication required');
            }
            if (421 === response.status && !isNewConnectionFetch && (null == request.body || null != request.body.source)) {
                if (isCancelled(fetchParams)) return makeAppropriateNetworkError(fetchParams);
                fetchParams.controller.connection.destroy();
                response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
            }
            return response;
        }
        async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
            assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
            fetchParams.controller.connection = {
                abort: null,
                destroyed: false,
                destroy (err, abort = true) {
                    if (!this.destroyed) {
                        this.destroyed = true;
                        if (abort) this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'));
                    }
                }
            };
            const request = fetchParams.request;
            let response = null;
            const timingInfo = fetchParams.timingInfo;
            const httpCache = null;
            if (null == httpCache) request.cache = 'no-store';
            request.mode;
            let requestBody = null;
            if (null == request.body && fetchParams.processRequestEndOfBody) queueMicrotask(()=>fetchParams.processRequestEndOfBody());
            else if (null != request.body) {
                const processBodyChunk = async function*(bytes) {
                    if (isCancelled(fetchParams)) return;
                    yield bytes;
                    fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
                };
                const processEndOfBody = ()=>{
                    if (isCancelled(fetchParams)) return;
                    if (fetchParams.processRequestEndOfBody) fetchParams.processRequestEndOfBody();
                };
                const processBodyError = (e)=>{
                    if (isCancelled(fetchParams)) return;
                    if ('AbortError' === e.name) fetchParams.controller.abort();
                    else fetchParams.controller.terminate(e);
                };
                requestBody = async function*() {
                    try {
                        for await (const bytes of request.body.stream)yield* processBodyChunk(bytes);
                        processEndOfBody();
                    } catch (err) {
                        processBodyError(err);
                    }
                }();
            }
            try {
                const { body, status, statusText, headersList, socket } = await dispatch({
                    body: requestBody
                });
                if (socket) response = makeResponse({
                    status,
                    statusText,
                    headersList,
                    socket
                });
                else {
                    const iterator = body[Symbol.asyncIterator]();
                    fetchParams.controller.next = ()=>iterator.next();
                    response = makeResponse({
                        status,
                        statusText,
                        headersList
                    });
                }
            } catch (err) {
                if ('AbortError' === err.name) {
                    fetchParams.controller.connection.destroy();
                    return makeAppropriateNetworkError(fetchParams, err);
                }
                return makeNetworkError(err);
            }
            const pullAlgorithm = async ()=>{
                await fetchParams.controller.resume();
            };
            const cancelAlgorithm = (reason)=>{
                if (!isCancelled(fetchParams)) fetchParams.controller.abort(reason);
            };
            const stream = new ReadableStream({
                async start (controller) {
                    fetchParams.controller.controller = controller;
                },
                async pull (controller) {
                    await pullAlgorithm(controller);
                },
                async cancel (reason) {
                    await cancelAlgorithm(reason);
                },
                type: 'bytes'
            });
            response.body = {
                stream,
                source: null,
                length: null
            };
            fetchParams.controller.onAborted = onAborted;
            fetchParams.controller.on('terminated', onAborted);
            fetchParams.controller.resume = async ()=>{
                while(true){
                    let bytes;
                    let isFailure;
                    try {
                        const { done, value } = await fetchParams.controller.next();
                        if (isAborted(fetchParams)) break;
                        bytes = done ? void 0 : value;
                    } catch (err) {
                        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) bytes = void 0;
                        else {
                            bytes = err;
                            isFailure = true;
                        }
                    }
                    if (void 0 === bytes) {
                        readableStreamClose(fetchParams.controller.controller);
                        finalizeResponse(fetchParams, response);
                        return;
                    }
                    timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
                    if (isFailure) return void fetchParams.controller.terminate(bytes);
                    const buffer = new Uint8Array(bytes);
                    if (buffer.byteLength) fetchParams.controller.controller.enqueue(buffer);
                    if (isErrored(stream)) return void fetchParams.controller.terminate();
                    if (fetchParams.controller.controller.desiredSize <= 0) return;
                }
            };
            function onAborted(reason) {
                if (isAborted(fetchParams)) {
                    response.aborted = true;
                    if (isReadable(stream)) fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);
                } else if (isReadable(stream)) fetchParams.controller.controller.error(new TypeError('terminated', {
                    cause: isErrorLike(reason) ? reason : void 0
                }));
                fetchParams.controller.connection.destroy();
            }
            return response;
            function dispatch({ body }) {
                const url = requestCurrentURL(request);
                const agent = fetchParams.controller.dispatcher;
                return new Promise((resolve, reject)=>agent.dispatch({
                        path: url.pathname + url.search,
                        origin: url.origin,
                        method: request.method,
                        body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
                        headers: request.headersList.entries,
                        maxRedirections: 0,
                        upgrade: 'websocket' === request.mode ? 'websocket' : void 0
                    }, {
                        body: null,
                        abort: null,
                        onConnect (abort) {
                            const { connection } = fetchParams.controller;
                            timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(void 0, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability);
                            if (connection.destroyed) abort(new DOMException('The operation was aborted.', 'AbortError'));
                            else {
                                fetchParams.controller.on('terminated', abort);
                                this.abort = connection.abort = abort;
                            }
                            timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
                        },
                        onResponseStarted () {
                            timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
                        },
                        onHeaders (status, rawHeaders, resume, statusText) {
                            if (status < 200) return;
                            let location = '';
                            const headersList = new HeadersList();
                            for(let i = 0; i < rawHeaders.length; i += 2)headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true);
                            location = headersList.get('location', true);
                            this.body = new Readable({
                                read: resume
                            });
                            const decoders = [];
                            const willFollow = location && 'follow' === request.redirect && redirectStatusSet.has(status);
                            if ('HEAD' !== request.method && 'CONNECT' !== request.method && !nullBodyStatus.includes(status) && !willFollow) {
                                const contentEncoding = headersList.get('content-encoding', true);
                                const codings = contentEncoding ? contentEncoding.toLowerCase().split(',') : [];
                                const maxContentEncodings = 5;
                                if (codings.length > maxContentEncodings) {
                                    reject(new Error(`too many content-encodings in response: ${codings.length}, maximum allowed is ${maxContentEncodings}`));
                                    return true;
                                }
                                for(let i = codings.length - 1; i >= 0; --i){
                                    const coding = codings[i].trim();
                                    if ('x-gzip' === coding || 'gzip' === coding) decoders.push(zlib.createGunzip({
                                        flush: zlib.constants.Z_SYNC_FLUSH,
                                        finishFlush: zlib.constants.Z_SYNC_FLUSH
                                    }));
                                    else if ('deflate' === coding) decoders.push(createInflate({
                                        flush: zlib.constants.Z_SYNC_FLUSH,
                                        finishFlush: zlib.constants.Z_SYNC_FLUSH
                                    }));
                                    else if ('br' === coding) decoders.push(zlib.createBrotliDecompress({
                                        flush: zlib.constants.BROTLI_OPERATION_FLUSH,
                                        finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
                                    }));
                                    else {
                                        decoders.length = 0;
                                        break;
                                    }
                                }
                            }
                            const onError = this.onError.bind(this);
                            resolve({
                                status,
                                statusText,
                                headersList,
                                body: decoders.length ? pipeline(this.body, ...decoders, (err)=>{
                                    if (err) this.onError(err);
                                }).on('error', onError) : this.body.on('error', onError)
                            });
                            return true;
                        },
                        onData (chunk) {
                            if (fetchParams.controller.dump) return;
                            const bytes = chunk;
                            timingInfo.encodedBodySize += bytes.byteLength;
                            return this.body.push(bytes);
                        },
                        onComplete () {
                            if (this.abort) fetchParams.controller.off('terminated', this.abort);
                            if (fetchParams.controller.onAborted) fetchParams.controller.off('terminated', fetchParams.controller.onAborted);
                            fetchParams.controller.ended = true;
                            this.body.push(null);
                        },
                        onError (error) {
                            if (this.abort) fetchParams.controller.off('terminated', this.abort);
                            this.body?.destroy(error);
                            fetchParams.controller.terminate(error);
                            reject(error);
                        },
                        onUpgrade (status, rawHeaders, socket) {
                            if (101 !== status) return;
                            const headersList = new HeadersList();
                            for(let i = 0; i < rawHeaders.length; i += 2)headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true);
                            resolve({
                                status,
                                statusText: STATUS_CODES[status],
                                headersList,
                                socket
                            });
                            return true;
                        }
                    }));
            }
        }
        module.exports = {
            fetch,
            Fetch,
            fetching,
            finalizeAndReportTiming
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/request.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { extractBody, mixinBody, cloneBody, bodyUnusable } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/body.js");
        const { Headers, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/headers.js");
        const { FinalizationRegistry: FinalizationRegistry1 } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/dispatcher-weakref.js")();
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const nodeUtil = __webpack_require__("node:util");
        const { isValidHTTPToken, sameOrigin, environmentSettingsObject } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/util.js");
        const { forbiddenMethodsSet, corsSafeListedMethodsSet, referrerPolicy, requestRedirect, requestMode, requestCredentials, requestCache, requestDuplex } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/constants.js");
        const { kEnumerableProperty, normalizedMethodRecordsBase, normalizedMethodRecords } = util;
        const { kHeaders, kSignal, kState, kDispatcher } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/symbols.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/webidl.js");
        const { URLSerializer } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/data-url.js");
        const { kConstruct } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const assert = __webpack_require__("node:assert");
        const { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __webpack_require__("node:events");
        const kAbortController = Symbol('abortController');
        const requestFinalizer = new FinalizationRegistry1(({ signal, abort })=>{
            signal.removeEventListener('abort', abort);
        });
        const dependentControllerMap = new WeakMap();
        function buildAbort(acRef) {
            return abort;
            function abort() {
                const ac = acRef.deref();
                if (void 0 !== ac) {
                    requestFinalizer.unregister(abort);
                    this.removeEventListener('abort', abort);
                    ac.abort(this.reason);
                    const controllerList = dependentControllerMap.get(ac.signal);
                    if (void 0 !== controllerList) {
                        if (0 !== controllerList.size) {
                            for (const ref of controllerList){
                                const ctrl = ref.deref();
                                if (void 0 !== ctrl) ctrl.abort(this.reason);
                            }
                            controllerList.clear();
                        }
                        dependentControllerMap.delete(ac.signal);
                    }
                }
            }
        }
        let patchMethodWarning = false;
        class Request {
            constructor(input, init = {}){
                webidl.util.markAsUncloneable(this);
                if (input === kConstruct) return;
                const prefix = 'Request constructor';
                webidl.argumentLengthCheck(arguments, 1, prefix);
                input = webidl.converters.RequestInfo(input, prefix, 'input');
                init = webidl.converters.RequestInit(init, prefix, 'init');
                let request = null;
                let fallbackMode = null;
                const baseUrl = environmentSettingsObject.settingsObject.baseUrl;
                let signal = null;
                if ('string' == typeof input) {
                    this[kDispatcher] = init.dispatcher;
                    let parsedURL;
                    try {
                        parsedURL = new URL(input, baseUrl);
                    } catch (err) {
                        throw new TypeError('Failed to parse URL from ' + input, {
                            cause: err
                        });
                    }
                    if (parsedURL.username || parsedURL.password) throw new TypeError('Request cannot be constructed from a URL that includes credentials: ' + input);
                    request = makeRequest({
                        urlList: [
                            parsedURL
                        ]
                    });
                    fallbackMode = 'cors';
                } else {
                    this[kDispatcher] = init.dispatcher || input[kDispatcher];
                    assert(input instanceof Request);
                    request = input[kState];
                    signal = input[kSignal];
                }
                const origin = environmentSettingsObject.settingsObject.origin;
                let window = 'client';
                if (request.window?.constructor?.name === 'EnvironmentSettingsObject' && sameOrigin(request.window, origin)) window = request.window;
                if (null != init.window) throw new TypeError(`'window' option '${window}' must be null`);
                if ('window' in init) window = 'no-window';
                request = makeRequest({
                    method: request.method,
                    headersList: request.headersList,
                    unsafeRequest: request.unsafeRequest,
                    client: environmentSettingsObject.settingsObject,
                    window,
                    priority: request.priority,
                    origin: request.origin,
                    referrer: request.referrer,
                    referrerPolicy: request.referrerPolicy,
                    mode: request.mode,
                    credentials: request.credentials,
                    cache: request.cache,
                    redirect: request.redirect,
                    integrity: request.integrity,
                    keepalive: request.keepalive,
                    reloadNavigation: request.reloadNavigation,
                    historyNavigation: request.historyNavigation,
                    urlList: [
                        ...request.urlList
                    ]
                });
                const initHasKey = 0 !== Object.keys(init).length;
                if (initHasKey) {
                    if ('navigate' === request.mode) request.mode = 'same-origin';
                    request.reloadNavigation = false;
                    request.historyNavigation = false;
                    request.origin = 'client';
                    request.referrer = 'client';
                    request.referrerPolicy = '';
                    request.url = request.urlList[request.urlList.length - 1];
                    request.urlList = [
                        request.url
                    ];
                }
                if (void 0 !== init.referrer) {
                    const referrer = init.referrer;
                    if ('' === referrer) request.referrer = 'no-referrer';
                    else {
                        let parsedReferrer;
                        try {
                            parsedReferrer = new URL(referrer, baseUrl);
                        } catch (err) {
                            throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, {
                                cause: err
                            });
                        }
                        if ('about:' === parsedReferrer.protocol && 'client' === parsedReferrer.hostname || origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl)) request.referrer = 'client';
                        else request.referrer = parsedReferrer;
                    }
                }
                if (void 0 !== init.referrerPolicy) request.referrerPolicy = init.referrerPolicy;
                let mode;
                mode = void 0 !== init.mode ? init.mode : fallbackMode;
                if ('navigate' === mode) throw webidl.errors.exception({
                    header: 'Request constructor',
                    message: 'invalid request mode navigate.'
                });
                if (null != mode) request.mode = mode;
                if (void 0 !== init.credentials) request.credentials = init.credentials;
                if (void 0 !== init.cache) request.cache = init.cache;
                if ('only-if-cached' === request.cache && 'same-origin' !== request.mode) throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
                if (void 0 !== init.redirect) request.redirect = init.redirect;
                if (null != init.integrity) request.integrity = String(init.integrity);
                if (void 0 !== init.keepalive) request.keepalive = Boolean(init.keepalive);
                if (void 0 !== init.method) {
                    let method = init.method;
                    const mayBeNormalized = normalizedMethodRecords[method];
                    if (void 0 !== mayBeNormalized) request.method = mayBeNormalized;
                    else {
                        if (!isValidHTTPToken(method)) throw new TypeError(`'${method}' is not a valid HTTP method.`);
                        const upperCase = method.toUpperCase();
                        if (forbiddenMethodsSet.has(upperCase)) throw new TypeError(`'${method}' HTTP method is unsupported.`);
                        method = normalizedMethodRecordsBase[upperCase] ?? method;
                        request.method = method;
                    }
                    if (!patchMethodWarning && 'patch' === request.method) {
                        process.emitWarning('Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.', {
                            code: 'UNDICI-FETCH-patch'
                        });
                        patchMethodWarning = true;
                    }
                }
                if (void 0 !== init.signal) signal = init.signal;
                this[kState] = request;
                const ac = new AbortController();
                this[kSignal] = ac.signal;
                if (null != signal) {
                    if (!signal || 'boolean' != typeof signal.aborted || 'function' != typeof signal.addEventListener) throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
                    if (signal.aborted) ac.abort(signal.reason);
                    else {
                        this[kAbortController] = ac;
                        const acRef = new WeakRef(ac);
                        const abort = buildAbort(acRef);
                        try {
                            if ('function' == typeof getMaxListeners && getMaxListeners(signal) === defaultMaxListeners) setMaxListeners(1500, signal);
                            else if (getEventListeners(signal, 'abort').length >= defaultMaxListeners) setMaxListeners(1500, signal);
                        } catch  {}
                        util.addAbortListener(signal, abort);
                        requestFinalizer.register(ac, {
                            signal,
                            abort
                        }, abort);
                    }
                }
                this[kHeaders] = new Headers(kConstruct);
                setHeadersList(this[kHeaders], request.headersList);
                setHeadersGuard(this[kHeaders], 'request');
                if ('no-cors' === mode) {
                    if (!corsSafeListedMethodsSet.has(request.method)) throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);
                    setHeadersGuard(this[kHeaders], 'request-no-cors');
                }
                if (initHasKey) {
                    const headersList = getHeadersList(this[kHeaders]);
                    const headers = void 0 !== init.headers ? init.headers : new HeadersList(headersList);
                    headersList.clear();
                    if (headers instanceof HeadersList) {
                        for (const { name, value } of headers.rawValues())headersList.append(name, value, false);
                        headersList.cookies = headers.cookies;
                    } else fillHeaders(this[kHeaders], headers);
                }
                const inputBody = input instanceof Request ? input[kState].body : null;
                if ((null != init.body || null != inputBody) && ('GET' === request.method || 'HEAD' === request.method)) throw new TypeError('Request with GET/HEAD method cannot have body.');
                let initBody = null;
                if (null != init.body) {
                    const [extractedBody, contentType] = extractBody(init.body, request.keepalive);
                    initBody = extractedBody;
                    if (contentType && !getHeadersList(this[kHeaders]).contains('content-type', true)) this[kHeaders].append('content-type', contentType);
                }
                const inputOrInitBody = initBody ?? inputBody;
                if (null != inputOrInitBody && null == inputOrInitBody.source) {
                    if (null != initBody && null == init.duplex) throw new TypeError('RequestInit: duplex option is required when sending a body.');
                    if ('same-origin' !== request.mode && 'cors' !== request.mode) throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
                    request.useCORSPreflightFlag = true;
                }
                let finalBody = inputOrInitBody;
                if (null == initBody && null != inputBody) {
                    if (bodyUnusable(input)) throw new TypeError('Cannot construct a Request with a Request object that has already been used.');
                    const identityTransform = new TransformStream();
                    inputBody.stream.pipeThrough(identityTransform);
                    finalBody = {
                        source: inputBody.source,
                        length: inputBody.length,
                        stream: identityTransform.readable
                    };
                }
                this[kState].body = finalBody;
            }
            get method() {
                webidl.brandCheck(this, Request);
                return this[kState].method;
            }
            get url() {
                webidl.brandCheck(this, Request);
                return URLSerializer(this[kState].url);
            }
            get headers() {
                webidl.brandCheck(this, Request);
                return this[kHeaders];
            }
            get destination() {
                webidl.brandCheck(this, Request);
                return this[kState].destination;
            }
            get referrer() {
                webidl.brandCheck(this, Request);
                if ('no-referrer' === this[kState].referrer) return '';
                if ('client' === this[kState].referrer) return 'about:client';
                return this[kState].referrer.toString();
            }
            get referrerPolicy() {
                webidl.brandCheck(this, Request);
                return this[kState].referrerPolicy;
            }
            get mode() {
                webidl.brandCheck(this, Request);
                return this[kState].mode;
            }
            get credentials() {
                return this[kState].credentials;
            }
            get cache() {
                webidl.brandCheck(this, Request);
                return this[kState].cache;
            }
            get redirect() {
                webidl.brandCheck(this, Request);
                return this[kState].redirect;
            }
            get integrity() {
                webidl.brandCheck(this, Request);
                return this[kState].integrity;
            }
            get keepalive() {
                webidl.brandCheck(this, Request);
                return this[kState].keepalive;
            }
            get isReloadNavigation() {
                webidl.brandCheck(this, Request);
                return this[kState].reloadNavigation;
            }
            get isHistoryNavigation() {
                webidl.brandCheck(this, Request);
                return this[kState].historyNavigation;
            }
            get signal() {
                webidl.brandCheck(this, Request);
                return this[kSignal];
            }
            get body() {
                webidl.brandCheck(this, Request);
                return this[kState].body ? this[kState].body.stream : null;
            }
            get bodyUsed() {
                webidl.brandCheck(this, Request);
                return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
            }
            get duplex() {
                webidl.brandCheck(this, Request);
                return 'half';
            }
            clone() {
                webidl.brandCheck(this, Request);
                if (bodyUnusable(this)) throw new TypeError('unusable');
                const clonedRequest = cloneRequest(this[kState]);
                const ac = new AbortController();
                if (this.signal.aborted) ac.abort(this.signal.reason);
                else {
                    let list = dependentControllerMap.get(this.signal);
                    if (void 0 === list) {
                        list = new Set();
                        dependentControllerMap.set(this.signal, list);
                    }
                    const acRef = new WeakRef(ac);
                    list.add(acRef);
                    util.addAbortListener(ac.signal, buildAbort(acRef));
                }
                return fromInnerRequest(clonedRequest, ac.signal, getHeadersGuard(this[kHeaders]));
            }
            [nodeUtil.inspect.custom](depth, options) {
                if (null === options.depth) options.depth = 2;
                options.colors ??= true;
                const properties = {
                    method: this.method,
                    url: this.url,
                    headers: this.headers,
                    destination: this.destination,
                    referrer: this.referrer,
                    referrerPolicy: this.referrerPolicy,
                    mode: this.mode,
                    credentials: this.credentials,
                    cache: this.cache,
                    redirect: this.redirect,
                    integrity: this.integrity,
                    keepalive: this.keepalive,
                    isReloadNavigation: this.isReloadNavigation,
                    isHistoryNavigation: this.isHistoryNavigation,
                    signal: this.signal
                };
                return `Request ${nodeUtil.formatWithOptions(options, properties)}`;
            }
        }
        mixinBody(Request);
        function makeRequest(init) {
            return {
                method: init.method ?? 'GET',
                localURLsOnly: init.localURLsOnly ?? false,
                unsafeRequest: init.unsafeRequest ?? false,
                body: init.body ?? null,
                client: init.client ?? null,
                reservedClient: init.reservedClient ?? null,
                replacesClientId: init.replacesClientId ?? '',
                window: init.window ?? 'client',
                keepalive: init.keepalive ?? false,
                serviceWorkers: init.serviceWorkers ?? 'all',
                initiator: init.initiator ?? '',
                destination: init.destination ?? '',
                priority: init.priority ?? null,
                origin: init.origin ?? 'client',
                policyContainer: init.policyContainer ?? 'client',
                referrer: init.referrer ?? 'client',
                referrerPolicy: init.referrerPolicy ?? '',
                mode: init.mode ?? 'no-cors',
                useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,
                credentials: init.credentials ?? 'same-origin',
                useCredentials: init.useCredentials ?? false,
                cache: init.cache ?? 'default',
                redirect: init.redirect ?? 'follow',
                integrity: init.integrity ?? '',
                cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? '',
                parserMetadata: init.parserMetadata ?? '',
                reloadNavigation: init.reloadNavigation ?? false,
                historyNavigation: init.historyNavigation ?? false,
                userActivation: init.userActivation ?? false,
                taintedOrigin: init.taintedOrigin ?? false,
                redirectCount: init.redirectCount ?? 0,
                responseTainting: init.responseTainting ?? 'basic',
                preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,
                done: init.done ?? false,
                timingAllowFailed: init.timingAllowFailed ?? false,
                urlList: init.urlList,
                url: init.urlList[0],
                headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
            };
        }
        function cloneRequest(request) {
            const newRequest = makeRequest({
                ...request,
                body: null
            });
            if (null != request.body) newRequest.body = cloneBody(newRequest, request.body);
            return newRequest;
        }
        function fromInnerRequest(innerRequest, signal, guard) {
            const request = new Request(kConstruct);
            request[kState] = innerRequest;
            request[kSignal] = signal;
            request[kHeaders] = new Headers(kConstruct);
            setHeadersList(request[kHeaders], innerRequest.headersList);
            setHeadersGuard(request[kHeaders], guard);
            return request;
        }
        Object.defineProperties(Request.prototype, {
            method: kEnumerableProperty,
            url: kEnumerableProperty,
            headers: kEnumerableProperty,
            redirect: kEnumerableProperty,
            clone: kEnumerableProperty,
            signal: kEnumerableProperty,
            duplex: kEnumerableProperty,
            destination: kEnumerableProperty,
            body: kEnumerableProperty,
            bodyUsed: kEnumerableProperty,
            isHistoryNavigation: kEnumerableProperty,
            isReloadNavigation: kEnumerableProperty,
            keepalive: kEnumerableProperty,
            integrity: kEnumerableProperty,
            cache: kEnumerableProperty,
            credentials: kEnumerableProperty,
            attribute: kEnumerableProperty,
            referrerPolicy: kEnumerableProperty,
            referrer: kEnumerableProperty,
            mode: kEnumerableProperty,
            [Symbol.toStringTag]: {
                value: 'Request',
                configurable: true
            }
        });
        webidl.converters.Request = webidl.interfaceConverter(Request);
        webidl.converters.RequestInfo = function(V, prefix, argument) {
            if ('string' == typeof V) return webidl.converters.USVString(V, prefix, argument);
            if (V instanceof Request) return webidl.converters.Request(V, prefix, argument);
            return webidl.converters.USVString(V, prefix, argument);
        };
        webidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);
        webidl.converters.RequestInit = webidl.dictionaryConverter([
            {
                key: 'method',
                converter: webidl.converters.ByteString
            },
            {
                key: 'headers',
                converter: webidl.converters.HeadersInit
            },
            {
                key: 'body',
                converter: webidl.nullableConverter(webidl.converters.BodyInit)
            },
            {
                key: 'referrer',
                converter: webidl.converters.USVString
            },
            {
                key: 'referrerPolicy',
                converter: webidl.converters.DOMString,
                allowedValues: referrerPolicy
            },
            {
                key: 'mode',
                converter: webidl.converters.DOMString,
                allowedValues: requestMode
            },
            {
                key: 'credentials',
                converter: webidl.converters.DOMString,
                allowedValues: requestCredentials
            },
            {
                key: 'cache',
                converter: webidl.converters.DOMString,
                allowedValues: requestCache
            },
            {
                key: 'redirect',
                converter: webidl.converters.DOMString,
                allowedValues: requestRedirect
            },
            {
                key: 'integrity',
                converter: webidl.converters.DOMString
            },
            {
                key: 'keepalive',
                converter: webidl.converters.boolean
            },
            {
                key: 'signal',
                converter: webidl.nullableConverter((signal)=>webidl.converters.AbortSignal(signal, 'RequestInit', 'signal', {
                        strict: false
                    }))
            },
            {
                key: 'window',
                converter: webidl.converters.any
            },
            {
                key: 'duplex',
                converter: webidl.converters.DOMString,
                allowedValues: requestDuplex
            },
            {
                key: 'dispatcher',
                converter: webidl.converters.any
            }
        ]);
        module.exports = {
            Request,
            makeRequest,
            fromInnerRequest,
            cloneRequest
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/response.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { Headers, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/headers.js");
        const { extractBody, cloneBody, mixinBody, hasFinalizationRegistry, streamRegistry, bodyUnusable } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/body.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const nodeUtil = __webpack_require__("node:util");
        const { kEnumerableProperty } = util;
        const { isValidReasonPhrase, isCancelled, isAborted, isBlobLike, serializeJavascriptValueToJSONString, isErrorLike, isomorphicEncode, environmentSettingsObject: relevantRealm } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/util.js");
        const { redirectStatusSet, nullBodyStatus } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/constants.js");
        const { kState, kHeaders } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/symbols.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/webidl.js");
        const { FormData } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/formdata.js");
        const { URLSerializer } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/data-url.js");
        const { kConstruct } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const assert = __webpack_require__("node:assert");
        const { types } = __webpack_require__("node:util");
        const textEncoder = new TextEncoder('utf-8');
        class Response {
            static error() {
                const responseObject = fromInnerResponse(makeNetworkError(), 'immutable');
                return responseObject;
            }
            static json(data, init = {}) {
                webidl.argumentLengthCheck(arguments, 1, 'Response.json');
                if (null !== init) init = webidl.converters.ResponseInit(init);
                const bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data));
                const body = extractBody(bytes);
                const responseObject = fromInnerResponse(makeResponse({}), 'response');
                initializeResponse(responseObject, init, {
                    body: body[0],
                    type: 'application/json'
                });
                return responseObject;
            }
            static redirect(url, status = 302) {
                webidl.argumentLengthCheck(arguments, 1, 'Response.redirect');
                url = webidl.converters.USVString(url);
                status = webidl.converters['unsigned short'](status);
                let parsedURL;
                try {
                    parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl);
                } catch (err) {
                    throw new TypeError(`Failed to parse URL from ${url}`, {
                        cause: err
                    });
                }
                if (!redirectStatusSet.has(status)) throw new RangeError(`Invalid status code ${status}`);
                const responseObject = fromInnerResponse(makeResponse({}), 'immutable');
                responseObject[kState].status = status;
                const value = isomorphicEncode(URLSerializer(parsedURL));
                responseObject[kState].headersList.append('location', value, true);
                return responseObject;
            }
            constructor(body = null, init = {}){
                webidl.util.markAsUncloneable(this);
                if (body === kConstruct) return;
                if (null !== body) body = webidl.converters.BodyInit(body);
                init = webidl.converters.ResponseInit(init);
                this[kState] = makeResponse({});
                this[kHeaders] = new Headers(kConstruct);
                setHeadersGuard(this[kHeaders], 'response');
                setHeadersList(this[kHeaders], this[kState].headersList);
                let bodyWithType = null;
                if (null != body) {
                    const [extractedBody, type] = extractBody(body);
                    bodyWithType = {
                        body: extractedBody,
                        type
                    };
                }
                initializeResponse(this, init, bodyWithType);
            }
            get type() {
                webidl.brandCheck(this, Response);
                return this[kState].type;
            }
            get url() {
                webidl.brandCheck(this, Response);
                const urlList = this[kState].urlList;
                const url = urlList[urlList.length - 1] ?? null;
                if (null === url) return '';
                return URLSerializer(url, true);
            }
            get redirected() {
                webidl.brandCheck(this, Response);
                return this[kState].urlList.length > 1;
            }
            get status() {
                webidl.brandCheck(this, Response);
                return this[kState].status;
            }
            get ok() {
                webidl.brandCheck(this, Response);
                return this[kState].status >= 200 && this[kState].status <= 299;
            }
            get statusText() {
                webidl.brandCheck(this, Response);
                return this[kState].statusText;
            }
            get headers() {
                webidl.brandCheck(this, Response);
                return this[kHeaders];
            }
            get body() {
                webidl.brandCheck(this, Response);
                return this[kState].body ? this[kState].body.stream : null;
            }
            get bodyUsed() {
                webidl.brandCheck(this, Response);
                return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
            }
            clone() {
                webidl.brandCheck(this, Response);
                if (bodyUnusable(this)) throw webidl.errors.exception({
                    header: 'Response.clone',
                    message: 'Body has already been consumed.'
                });
                const clonedResponse = cloneResponse(this[kState]);
                if (hasFinalizationRegistry && this[kState].body?.stream) streamRegistry.register(this, new WeakRef(this[kState].body.stream));
                return fromInnerResponse(clonedResponse, getHeadersGuard(this[kHeaders]));
            }
            [nodeUtil.inspect.custom](depth, options) {
                if (null === options.depth) options.depth = 2;
                options.colors ??= true;
                const properties = {
                    status: this.status,
                    statusText: this.statusText,
                    headers: this.headers,
                    body: this.body,
                    bodyUsed: this.bodyUsed,
                    ok: this.ok,
                    redirected: this.redirected,
                    type: this.type,
                    url: this.url
                };
                return `Response ${nodeUtil.formatWithOptions(options, properties)}`;
            }
        }
        mixinBody(Response);
        Object.defineProperties(Response.prototype, {
            type: kEnumerableProperty,
            url: kEnumerableProperty,
            status: kEnumerableProperty,
            ok: kEnumerableProperty,
            redirected: kEnumerableProperty,
            statusText: kEnumerableProperty,
            headers: kEnumerableProperty,
            clone: kEnumerableProperty,
            body: kEnumerableProperty,
            bodyUsed: kEnumerableProperty,
            [Symbol.toStringTag]: {
                value: 'Response',
                configurable: true
            }
        });
        Object.defineProperties(Response, {
            json: kEnumerableProperty,
            redirect: kEnumerableProperty,
            error: kEnumerableProperty
        });
        function cloneResponse(response) {
            if (response.internalResponse) return filterResponse(cloneResponse(response.internalResponse), response.type);
            const newResponse = makeResponse({
                ...response,
                body: null
            });
            if (null != response.body) newResponse.body = cloneBody(newResponse, response.body);
            return newResponse;
        }
        function makeResponse(init) {
            return {
                aborted: false,
                rangeRequested: false,
                timingAllowPassed: false,
                requestIncludesCredentials: false,
                type: 'default',
                status: 200,
                timingInfo: null,
                cacheState: '',
                statusText: '',
                ...init,
                headersList: init?.headersList ? new HeadersList(init?.headersList) : new HeadersList(),
                urlList: init?.urlList ? [
                    ...init.urlList
                ] : []
            };
        }
        function makeNetworkError(reason) {
            const isError = isErrorLike(reason);
            return makeResponse({
                type: 'error',
                status: 0,
                error: isError ? reason : new Error(reason ? String(reason) : reason),
                aborted: reason && 'AbortError' === reason.name
            });
        }
        function isNetworkError(response) {
            return 'error' === response.type && 0 === response.status;
        }
        function makeFilteredResponse(response, state) {
            state = {
                internalResponse: response,
                ...state
            };
            return new Proxy(response, {
                get (target, p) {
                    return p in state ? state[p] : target[p];
                },
                set (target, p, value) {
                    assert(!(p in state));
                    target[p] = value;
                    return true;
                }
            });
        }
        function filterResponse(response, type) {
            if ('basic' === type) return makeFilteredResponse(response, {
                type: 'basic',
                headersList: response.headersList
            });
            if ('cors' === type) return makeFilteredResponse(response, {
                type: 'cors',
                headersList: response.headersList
            });
            if ('opaque' === type) return makeFilteredResponse(response, {
                type: 'opaque',
                urlList: Object.freeze([]),
                status: 0,
                statusText: '',
                body: null
            });
            if ('opaqueredirect' === type) return makeFilteredResponse(response, {
                type: 'opaqueredirect',
                status: 0,
                statusText: '',
                headersList: [],
                body: null
            });
            assert(false);
        }
        function makeAppropriateNetworkError(fetchParams, err = null) {
            assert(isCancelled(fetchParams));
            return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException('The operation was aborted.', 'AbortError'), {
                cause: err
            })) : makeNetworkError(Object.assign(new DOMException('Request was cancelled.'), {
                cause: err
            }));
        }
        function initializeResponse(response, init, body) {
            if (null !== init.status && (init.status < 200 || init.status > 599)) throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
            if ('statusText' in init && null != init.statusText) {
                if (!isValidReasonPhrase(String(init.statusText))) throw new TypeError('Invalid statusText');
            }
            if ('status' in init && null != init.status) response[kState].status = init.status;
            if ('statusText' in init && null != init.statusText) response[kState].statusText = init.statusText;
            if ('headers' in init && null != init.headers) fill(response[kHeaders], init.headers);
            if (body) {
                if (nullBodyStatus.includes(response.status)) throw webidl.errors.exception({
                    header: 'Response constructor',
                    message: `Invalid response status code ${response.status}`
                });
                response[kState].body = body.body;
                if (null != body.type && !response[kState].headersList.contains('content-type', true)) response[kState].headersList.append('content-type', body.type, true);
            }
        }
        function fromInnerResponse(innerResponse, guard) {
            const response = new Response(kConstruct);
            response[kState] = innerResponse;
            response[kHeaders] = new Headers(kConstruct);
            setHeadersList(response[kHeaders], innerResponse.headersList);
            setHeadersGuard(response[kHeaders], guard);
            if (hasFinalizationRegistry && innerResponse.body?.stream) streamRegistry.register(response, new WeakRef(innerResponse.body.stream));
            return response;
        }
        webidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);
        webidl.converters.FormData = webidl.interfaceConverter(FormData);
        webidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);
        webidl.converters.XMLHttpRequestBodyInit = function(V, prefix, name) {
            if ('string' == typeof V) return webidl.converters.USVString(V, prefix, name);
            if (isBlobLike(V)) return webidl.converters.Blob(V, prefix, name, {
                strict: false
            });
            if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) return webidl.converters.BufferSource(V, prefix, name);
            if (util.isFormDataLike(V)) return webidl.converters.FormData(V, prefix, name, {
                strict: false
            });
            if (V instanceof URLSearchParams) return webidl.converters.URLSearchParams(V, prefix, name);
            return webidl.converters.DOMString(V, prefix, name);
        };
        webidl.converters.BodyInit = function(V, prefix, argument) {
            if (V instanceof ReadableStream) return webidl.converters.ReadableStream(V, prefix, argument);
            if (V?.[Symbol.asyncIterator]) return V;
            return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument);
        };
        webidl.converters.ResponseInit = webidl.dictionaryConverter([
            {
                key: 'status',
                converter: webidl.converters['unsigned short'],
                defaultValue: ()=>200
            },
            {
                key: 'statusText',
                converter: webidl.converters.ByteString,
                defaultValue: ()=>''
            },
            {
                key: 'headers',
                converter: webidl.converters.HeadersInit
            }
        ]);
        module.exports = {
            isNetworkError,
            makeNetworkError,
            makeResponse,
            makeAppropriateNetworkError,
            filterResponse,
            Response,
            cloneResponse,
            fromInnerResponse
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/symbols.js" (module) {
        "use strict";
        module.exports = {
            kUrl: Symbol('url'),
            kHeaders: Symbol('headers'),
            kSignal: Symbol('signal'),
            kState: Symbol('state'),
            kDispatcher: Symbol('dispatcher')
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/util.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { Transform } = __webpack_require__("node:stream");
        const zlib = __webpack_require__("node:zlib");
        const { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/constants.js");
        const { getGlobalOrigin } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/global.js");
        const { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/data-url.js");
        const { performance: performance1 } = __webpack_require__("node:perf_hooks");
        const { isBlobLike, ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const assert = __webpack_require__("node:assert");
        const { isUint8Array } = __webpack_require__("node:util/types");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/webidl.js");
        let supportedHashes = [];
        let crypto;
        try {
            crypto = __webpack_require__("node:crypto");
            const possibleRelevantHashes = [
                'sha256',
                'sha384',
                'sha512'
            ];
            supportedHashes = crypto.getHashes().filter((hash)=>possibleRelevantHashes.includes(hash));
        } catch  {}
        function responseURL(response) {
            const urlList = response.urlList;
            const length = urlList.length;
            return 0 === length ? null : urlList[length - 1].toString();
        }
        function responseLocationURL(response, requestFragment) {
            if (!redirectStatusSet.has(response.status)) return null;
            let location = response.headersList.get('location', true);
            if (null !== location && isValidHeaderValue(location)) {
                if (!isValidEncodedURL(location)) location = normalizeBinaryStringToUtf8(location);
                location = new URL(location, responseURL(response));
            }
            if (location && !location.hash) location.hash = requestFragment;
            return location;
        }
        function isValidEncodedURL(url) {
            for(let i = 0; i < url.length; ++i){
                const code = url.charCodeAt(i);
                if (code > 0x7E || code < 0x20) return false;
            }
            return true;
        }
        function normalizeBinaryStringToUtf8(value) {
            return Buffer.from(value, 'binary').toString('utf8');
        }
        function requestCurrentURL(request) {
            return request.urlList[request.urlList.length - 1];
        }
        function requestBadPort(request) {
            const url = requestCurrentURL(request);
            if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) return 'blocked';
            return 'allowed';
        }
        function isErrorLike(object) {
            return object instanceof Error || object?.constructor?.name === 'Error' || object?.constructor?.name === 'DOMException';
        }
        function isValidReasonPhrase(statusText) {
            for(let i = 0; i < statusText.length; ++i){
                const c = statusText.charCodeAt(i);
                if (!(0x09 === c || c >= 0x20 && c <= 0x7e || c >= 0x80 && c <= 0xff)) return false;
            }
            return true;
        }
        const isValidHeaderName = isValidHTTPToken;
        function isValidHeaderValue(potentialValue) {
            return false === ('\t' === potentialValue[0] || ' ' === potentialValue[0] || '\t' === potentialValue[potentialValue.length - 1] || ' ' === potentialValue[potentialValue.length - 1] || potentialValue.includes('\n') || potentialValue.includes('\r') || potentialValue.includes('\0'));
        }
        function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
            const { headersList } = actualResponse;
            const policyHeader = (headersList.get('referrer-policy', true) ?? '').split(',');
            let policy = '';
            if (policyHeader.length > 0) for(let i = policyHeader.length; 0 !== i; i--){
                const token = policyHeader[i - 1].trim();
                if (referrerPolicyTokens.has(token)) {
                    policy = token;
                    break;
                }
            }
            if ('' !== policy) request.referrerPolicy = policy;
        }
        function crossOriginResourcePolicyCheck() {
            return 'allowed';
        }
        function corsCheck() {
            return 'success';
        }
        function TAOCheck() {
            return 'success';
        }
        function appendFetchMetadata(httpRequest) {
            let header = null;
            header = httpRequest.mode;
            httpRequest.headersList.set('sec-fetch-mode', header, true);
        }
        function appendRequestOriginHeader(request) {
            let serializedOrigin = request.origin;
            if ('client' === serializedOrigin || void 0 === serializedOrigin) return;
            if ('cors' === request.responseTainting || 'websocket' === request.mode) request.headersList.append('origin', serializedOrigin, true);
            else if ('GET' !== request.method && 'HEAD' !== request.method) {
                switch(request.referrerPolicy){
                    case 'no-referrer':
                        serializedOrigin = null;
                        break;
                    case 'no-referrer-when-downgrade':
                    case 'strict-origin':
                    case 'strict-origin-when-cross-origin':
                        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) serializedOrigin = null;
                        break;
                    case 'same-origin':
                        if (!sameOrigin(request, requestCurrentURL(request))) serializedOrigin = null;
                        break;
                    default:
                }
                request.headersList.append('origin', serializedOrigin, true);
            }
        }
        function coarsenTime(timestamp, crossOriginIsolatedCapability) {
            return timestamp;
        }
        function clampAndCoarsenConnectionTimingInfo(connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {
            if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) return {
                domainLookupStartTime: defaultStartTime,
                domainLookupEndTime: defaultStartTime,
                connectionStartTime: defaultStartTime,
                connectionEndTime: defaultStartTime,
                secureConnectionStartTime: defaultStartTime,
                ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol
            };
            return {
                domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),
                domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),
                connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),
                connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),
                secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),
                ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol
            };
        }
        function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
            return coarsenTime(performance1.now(), crossOriginIsolatedCapability);
        }
        function createOpaqueTimingInfo(timingInfo) {
            return {
                startTime: timingInfo.startTime ?? 0,
                redirectStartTime: 0,
                redirectEndTime: 0,
                postRedirectStartTime: timingInfo.startTime ?? 0,
                finalServiceWorkerStartTime: 0,
                finalNetworkResponseStartTime: 0,
                finalNetworkRequestStartTime: 0,
                endTime: 0,
                encodedBodySize: 0,
                decodedBodySize: 0,
                finalConnectionTimingInfo: null
            };
        }
        function makePolicyContainer() {
            return {
                referrerPolicy: 'strict-origin-when-cross-origin'
            };
        }
        function clonePolicyContainer(policyContainer) {
            return {
                referrerPolicy: policyContainer.referrerPolicy
            };
        }
        function determineRequestsReferrer(request) {
            const policy = request.referrerPolicy;
            assert(policy);
            let referrerSource = null;
            if ('client' === request.referrer) {
                const globalOrigin = getGlobalOrigin();
                if (!globalOrigin || 'null' === globalOrigin.origin) return 'no-referrer';
                referrerSource = new URL(globalOrigin);
            } else if (request.referrer instanceof URL) referrerSource = request.referrer;
            let referrerURL = stripURLForReferrer(referrerSource);
            const referrerOrigin = stripURLForReferrer(referrerSource, true);
            if (referrerURL.toString().length > 4096) referrerURL = referrerOrigin;
            const areSameOrigin = sameOrigin(request, referrerURL);
            const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
            switch(policy){
                case 'origin':
                    return null != referrerOrigin ? referrerOrigin : stripURLForReferrer(referrerSource, true);
                case 'unsafe-url':
                    return referrerURL;
                case 'same-origin':
                    return areSameOrigin ? referrerOrigin : 'no-referrer';
                case 'origin-when-cross-origin':
                    return areSameOrigin ? referrerURL : referrerOrigin;
                case 'strict-origin-when-cross-origin':
                    {
                        const currentURL = requestCurrentURL(request);
                        if (sameOrigin(referrerURL, currentURL)) return referrerURL;
                        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) return 'no-referrer';
                        return referrerOrigin;
                    }
                case 'strict-origin':
                case 'no-referrer-when-downgrade':
                default:
                    return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin;
            }
        }
        function stripURLForReferrer(url, originOnly) {
            assert(url instanceof URL);
            url = new URL(url);
            if ('file:' === url.protocol || 'about:' === url.protocol || 'blank:' === url.protocol) return 'no-referrer';
            url.username = '';
            url.password = '';
            url.hash = '';
            if (originOnly) {
                url.pathname = '';
                url.search = '';
            }
            return url;
        }
        function isURLPotentiallyTrustworthy(url) {
            if (!(url instanceof URL)) return false;
            if ('about:blank' === url.href || 'about:srcdoc' === url.href) return true;
            if ('data:' === url.protocol) return true;
            if ('file:' === url.protocol) return true;
            return isOriginPotentiallyTrustworthy(url.origin);
            function isOriginPotentiallyTrustworthy(origin) {
                if (null == origin || 'null' === origin) return false;
                const originAsURL = new URL(origin);
                if ('https:' === originAsURL.protocol || 'wss:' === originAsURL.protocol) return true;
                if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || 'localhost' === originAsURL.hostname || originAsURL.hostname.includes('localhost.') || originAsURL.hostname.endsWith('.localhost')) return true;
                return false;
            }
        }
        function bytesMatch(bytes, metadataList) {
            if (void 0 === crypto) return true;
            const parsedMetadata = parseMetadata(metadataList);
            if ('no metadata' === parsedMetadata) return true;
            if (0 === parsedMetadata.length) return true;
            const strongest = getStrongestMetadata(parsedMetadata);
            const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
            for (const item of metadata){
                const algorithm = item.algo;
                const expectedValue = item.hash;
                let actualValue = crypto.createHash(algorithm).update(bytes).digest('base64');
                if ('=' === actualValue[actualValue.length - 1]) actualValue = '=' === actualValue[actualValue.length - 2] ? actualValue.slice(0, -2) : actualValue.slice(0, -1);
                if (compareBase64Mixed(actualValue, expectedValue)) return true;
            }
            return false;
        }
        const parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
        function parseMetadata(metadata) {
            const result = [];
            let empty = true;
            for (const token of metadata.split(' ')){
                empty = false;
                const parsedToken = parseHashWithOptions.exec(token);
                if (null === parsedToken || void 0 === parsedToken.groups || void 0 === parsedToken.groups.algo) continue;
                const algorithm = parsedToken.groups.algo.toLowerCase();
                if (supportedHashes.includes(algorithm)) result.push(parsedToken.groups);
            }
            if (true === empty) return 'no metadata';
            return result;
        }
        function getStrongestMetadata(metadataList) {
            let algorithm = metadataList[0].algo;
            if ('5' === algorithm[3]) return algorithm;
            for(let i = 1; i < metadataList.length; ++i){
                const metadata = metadataList[i];
                if ('5' === metadata.algo[3]) {
                    algorithm = 'sha512';
                    break;
                }
                if ('3' !== algorithm[3]) {
                    if ('3' === metadata.algo[3]) algorithm = 'sha384';
                }
            }
            return algorithm;
        }
        function filterMetadataListByAlgorithm(metadataList, algorithm) {
            if (1 === metadataList.length) return metadataList;
            let pos = 0;
            for(let i = 0; i < metadataList.length; ++i)if (metadataList[i].algo === algorithm) metadataList[pos++] = metadataList[i];
            metadataList.length = pos;
            return metadataList;
        }
        function compareBase64Mixed(actualValue, expectedValue) {
            if (actualValue.length !== expectedValue.length) return false;
            for(let i = 0; i < actualValue.length; ++i)if (actualValue[i] !== expectedValue[i]) {
                if ('+' === actualValue[i] && '-' === expectedValue[i] || '/' === actualValue[i] && '_' === expectedValue[i]) continue;
                return false;
            }
            return true;
        }
        function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {}
        function sameOrigin(A, B) {
            if (A.origin === B.origin && 'null' === A.origin) return true;
            if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) return true;
            return false;
        }
        function createDeferredPromise() {
            let res;
            let rej;
            const promise = new Promise((resolve, reject)=>{
                res = resolve;
                rej = reject;
            });
            return {
                promise,
                resolve: res,
                reject: rej
            };
        }
        function isAborted(fetchParams) {
            return 'aborted' === fetchParams.controller.state;
        }
        function isCancelled(fetchParams) {
            return 'aborted' === fetchParams.controller.state || 'terminated' === fetchParams.controller.state;
        }
        function normalizeMethod(method) {
            return normalizedMethodRecordsBase[method.toLowerCase()] ?? method;
        }
        function serializeJavascriptValueToJSONString(value) {
            const result = JSON.stringify(value);
            if (void 0 === result) throw new TypeError('Value is not JSON serializable');
            assert('string' == typeof result);
            return result;
        }
        const esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
        function createIterator(name, kInternalIterator, keyIndex = 0, valueIndex = 1) {
            class FastIterableIterator {
                #target;
                #kind;
                #index;
                constructor(target, kind){
                    this.#target = target;
                    this.#kind = kind;
                    this.#index = 0;
                }
                next() {
                    if ('object' != typeof this || this === null || !(#target in this)) throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
                    const index = this.#index;
                    const values = this.#target[kInternalIterator];
                    const len = values.length;
                    if (index >= len) return {
                        value: void 0,
                        done: true
                    };
                    const { [keyIndex]: key, [valueIndex]: value } = values[index];
                    this.#index = index + 1;
                    let result;
                    switch(this.#kind){
                        case 'key':
                            result = key;
                            break;
                        case 'value':
                            result = value;
                            break;
                        case 'key+value':
                            result = [
                                key,
                                value
                            ];
                            break;
                    }
                    return {
                        value: result,
                        done: false
                    };
                }
            }
            delete FastIterableIterator.prototype.constructor;
            Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype);
            Object.defineProperties(FastIterableIterator.prototype, {
                [Symbol.toStringTag]: {
                    writable: false,
                    enumerable: false,
                    configurable: true,
                    value: `${name} Iterator`
                },
                next: {
                    writable: true,
                    enumerable: true,
                    configurable: true
                }
            });
            return function(target, kind) {
                return new FastIterableIterator(target, kind);
            };
        }
        function iteratorMixin(name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {
            const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex);
            const properties = {
                keys: {
                    writable: true,
                    enumerable: true,
                    configurable: true,
                    value: function() {
                        webidl.brandCheck(this, object);
                        return makeIterator(this, 'key');
                    }
                },
                values: {
                    writable: true,
                    enumerable: true,
                    configurable: true,
                    value: function() {
                        webidl.brandCheck(this, object);
                        return makeIterator(this, 'value');
                    }
                },
                entries: {
                    writable: true,
                    enumerable: true,
                    configurable: true,
                    value: function() {
                        webidl.brandCheck(this, object);
                        return makeIterator(this, 'key+value');
                    }
                },
                forEach: {
                    writable: true,
                    enumerable: true,
                    configurable: true,
                    value: function(callbackfn, thisArg = globalThis) {
                        webidl.brandCheck(this, object);
                        webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`);
                        if ('function' != typeof callbackfn) throw new TypeError(`Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`);
                        for (const { 0: key, 1: value } of makeIterator(this, 'key+value'))callbackfn.call(thisArg, value, key, this);
                    }
                }
            };
            return Object.defineProperties(object.prototype, {
                ...properties,
                [Symbol.iterator]: {
                    writable: true,
                    enumerable: false,
                    configurable: true,
                    value: properties.entries.value
                }
            });
        }
        async function fullyReadBody(body, processBody, processBodyError) {
            const successSteps = processBody;
            const errorSteps = processBodyError;
            let reader;
            try {
                reader = body.stream.getReader();
            } catch (e) {
                errorSteps(e);
                return;
            }
            try {
                successSteps(await readAllBytes(reader));
            } catch (e) {
                errorSteps(e);
            }
        }
        function isReadableStreamLike(stream) {
            return stream instanceof ReadableStream || 'ReadableStream' === stream[Symbol.toStringTag] && 'function' == typeof stream.tee;
        }
        function readableStreamClose(controller) {
            try {
                controller.close();
                controller.byobRequest?.respond(0);
            } catch (err) {
                if (!err.message.includes('Controller is already closed') && !err.message.includes('ReadableStream is already closed')) throw err;
            }
        }
        const invalidIsomorphicEncodeValueRegex = /[^\x00-\xFF]/;
        function isomorphicEncode(input) {
            assert(!invalidIsomorphicEncodeValueRegex.test(input));
            return input;
        }
        async function readAllBytes(reader) {
            const bytes = [];
            let byteLength = 0;
            while(true){
                const { done, value: chunk } = await reader.read();
                if (done) return Buffer.concat(bytes, byteLength);
                if (!isUint8Array(chunk)) throw new TypeError('Received non-Uint8Array chunk');
                bytes.push(chunk);
                byteLength += chunk.length;
            }
        }
        function urlIsLocal(url) {
            assert('protocol' in url);
            const protocol = url.protocol;
            return 'about:' === protocol || 'blob:' === protocol || 'data:' === protocol;
        }
        function urlHasHttpsScheme(url) {
            return 'string' == typeof url && ':' === url[5] && 'h' === url[0] && 't' === url[1] && 't' === url[2] && 'p' === url[3] && 's' === url[4] || 'https:' === url.protocol;
        }
        function urlIsHttpHttpsScheme(url) {
            assert('protocol' in url);
            const protocol = url.protocol;
            return 'http:' === protocol || 'https:' === protocol;
        }
        function simpleRangeHeaderValue(value, allowWhitespace) {
            const data = value;
            if (!data.startsWith('bytes')) return 'failure';
            const position = {
                position: 5
            };
            if (allowWhitespace) collectASequenceOfCodePoints((char)=>'\t' === char || ' ' === char, data, position);
            if (0x3D !== data.charCodeAt(position.position)) return 'failure';
            position.position++;
            if (allowWhitespace) collectASequenceOfCodePoints((char)=>'\t' === char || ' ' === char, data, position);
            const rangeStart = collectASequenceOfCodePoints((char)=>{
                const code = char.charCodeAt(0);
                return code >= 0x30 && code <= 0x39;
            }, data, position);
            const rangeStartValue = rangeStart.length ? Number(rangeStart) : null;
            if (allowWhitespace) collectASequenceOfCodePoints((char)=>'\t' === char || ' ' === char, data, position);
            if (0x2D !== data.charCodeAt(position.position)) return 'failure';
            position.position++;
            if (allowWhitespace) collectASequenceOfCodePoints((char)=>'\t' === char || ' ' === char, data, position);
            const rangeEnd = collectASequenceOfCodePoints((char)=>{
                const code = char.charCodeAt(0);
                return code >= 0x30 && code <= 0x39;
            }, data, position);
            const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null;
            if (position.position < data.length) return 'failure';
            if (null === rangeEndValue && null === rangeStartValue) return 'failure';
            if (rangeStartValue > rangeEndValue) return 'failure';
            return {
                rangeStartValue,
                rangeEndValue
            };
        }
        function buildContentRange(rangeStart, rangeEnd, fullLength) {
            let contentRange = 'bytes ';
            contentRange += isomorphicEncode(`${rangeStart}`);
            contentRange += '-';
            contentRange += isomorphicEncode(`${rangeEnd}`);
            contentRange += '/';
            contentRange += isomorphicEncode(`${fullLength}`);
            return contentRange;
        }
        class InflateStream extends Transform {
            #zlibOptions;
            constructor(zlibOptions){
                super();
                this.#zlibOptions = zlibOptions;
            }
            _transform(chunk, encoding, callback) {
                if (!this._inflateStream) {
                    if (0 === chunk.length) return void callback();
                    this._inflateStream = (0x0F & chunk[0]) === 0x08 ? zlib.createInflate(this.#zlibOptions) : zlib.createInflateRaw(this.#zlibOptions);
                    this._inflateStream.on('data', this.push.bind(this));
                    this._inflateStream.on('end', ()=>this.push(null));
                    this._inflateStream.on('error', (err)=>this.destroy(err));
                }
                this._inflateStream.write(chunk, encoding, callback);
            }
            _final(callback) {
                if (this._inflateStream) {
                    this._inflateStream.end();
                    this._inflateStream = null;
                }
                callback();
            }
        }
        function createInflate(zlibOptions) {
            return new InflateStream(zlibOptions);
        }
        function extractMimeType(headers) {
            let charset = null;
            let essence = null;
            let mimeType = null;
            const values = getDecodeSplit('content-type', headers);
            if (null === values) return 'failure';
            for (const value of values){
                const temporaryMimeType = parseMIMEType(value);
                if ('failure' !== temporaryMimeType && '*/*' !== temporaryMimeType.essence) {
                    mimeType = temporaryMimeType;
                    if (mimeType.essence !== essence) {
                        charset = null;
                        if (mimeType.parameters.has('charset')) charset = mimeType.parameters.get('charset');
                        essence = mimeType.essence;
                    } else if (!mimeType.parameters.has('charset') && null !== charset) mimeType.parameters.set('charset', charset);
                }
            }
            if (null == mimeType) return 'failure';
            return mimeType;
        }
        function gettingDecodingSplitting(value) {
            const input = value;
            const position = {
                position: 0
            };
            const values = [];
            let temporaryValue = '';
            while(position.position < input.length){
                temporaryValue += collectASequenceOfCodePoints((char)=>'"' !== char && ',' !== char, input, position);
                if (position.position < input.length) if (0x22 === input.charCodeAt(position.position)) {
                    temporaryValue += collectAnHTTPQuotedString(input, position);
                    if (position.position < input.length) continue;
                } else {
                    assert(0x2C === input.charCodeAt(position.position));
                    position.position++;
                }
                temporaryValue = removeChars(temporaryValue, true, true, (char)=>0x9 === char || 0x20 === char);
                values.push(temporaryValue);
                temporaryValue = '';
            }
            return values;
        }
        function getDecodeSplit(name, list) {
            const value = list.get(name, true);
            if (null === value) return null;
            return gettingDecodingSplitting(value);
        }
        const textDecoder = new TextDecoder();
        function utf8DecodeBytes(buffer) {
            if (0 === buffer.length) return '';
            if (0xEF === buffer[0] && 0xBB === buffer[1] && 0xBF === buffer[2]) buffer = buffer.subarray(3);
            const output = textDecoder.decode(buffer);
            return output;
        }
        class EnvironmentSettingsObjectBase {
            get baseUrl() {
                return getGlobalOrigin();
            }
            get origin() {
                return this.baseUrl?.origin;
            }
            policyContainer = makePolicyContainer();
        }
        class EnvironmentSettingsObject {
            settingsObject = new EnvironmentSettingsObjectBase();
        }
        const environmentSettingsObject = new EnvironmentSettingsObject();
        module.exports = {
            isAborted,
            isCancelled,
            isValidEncodedURL,
            createDeferredPromise,
            ReadableStreamFrom,
            tryUpgradeRequestToAPotentiallyTrustworthyURL,
            clampAndCoarsenConnectionTimingInfo,
            coarsenedSharedCurrentTime,
            determineRequestsReferrer,
            makePolicyContainer,
            clonePolicyContainer,
            appendFetchMetadata,
            appendRequestOriginHeader,
            TAOCheck,
            corsCheck,
            crossOriginResourcePolicyCheck,
            createOpaqueTimingInfo,
            setRequestReferrerPolicyOnRedirect,
            isValidHTTPToken,
            requestBadPort,
            requestCurrentURL,
            responseURL,
            responseLocationURL,
            isBlobLike,
            isURLPotentiallyTrustworthy,
            isValidReasonPhrase,
            sameOrigin,
            normalizeMethod,
            serializeJavascriptValueToJSONString,
            iteratorMixin,
            createIterator,
            isValidHeaderName,
            isValidHeaderValue,
            isErrorLike,
            fullyReadBody,
            bytesMatch,
            isReadableStreamLike,
            readableStreamClose,
            isomorphicEncode,
            urlIsLocal,
            urlHasHttpsScheme,
            urlIsHttpHttpsScheme,
            readAllBytes,
            simpleRangeHeaderValue,
            buildContentRange,
            parseMetadata,
            createInflate,
            extractMimeType,
            getDecodeSplit,
            utf8DecodeBytes,
            environmentSettingsObject
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/webidl.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { types, inspect } = __webpack_require__("node:util");
        const { markAsUncloneable } = __webpack_require__("node:worker_threads");
        const { toUSVString } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const webidl = {};
        webidl.converters = {};
        webidl.util = {};
        webidl.errors = {};
        webidl.errors.exception = function(message) {
            return new TypeError(`${message.header}: ${message.message}`);
        };
        webidl.errors.conversionFailed = function(context) {
            const plural = 1 === context.types.length ? '' : ' one of';
            const message = `${context.argument} could not be converted to${plural}: ${context.types.join(', ')}.`;
            return webidl.errors.exception({
                header: context.prefix,
                message
            });
        };
        webidl.errors.invalidArgument = function(context) {
            return webidl.errors.exception({
                header: context.prefix,
                message: `"${context.value}" is an invalid ${context.type}.`
            });
        };
        webidl.brandCheck = function(V, I, opts) {
            if (opts?.strict !== false) {
                if (!(V instanceof I)) {
                    const err = new TypeError('Illegal invocation');
                    err.code = 'ERR_INVALID_THIS';
                    throw err;
                }
            } else if (V?.[Symbol.toStringTag] !== I.prototype[Symbol.toStringTag]) {
                const err = new TypeError('Illegal invocation');
                err.code = 'ERR_INVALID_THIS';
                throw err;
            }
        };
        webidl.argumentLengthCheck = function({ length }, min, ctx) {
            if (length < min) throw webidl.errors.exception({
                message: `${min} argument${1 !== min ? 's' : ''} required, but${length ? ' only' : ''} ${length} found.`,
                header: ctx
            });
        };
        webidl.illegalConstructor = function() {
            throw webidl.errors.exception({
                header: 'TypeError',
                message: 'Illegal constructor'
            });
        };
        webidl.util.Type = function(V) {
            switch(typeof V){
                case 'undefined':
                    return 'Undefined';
                case 'boolean':
                    return 'Boolean';
                case 'string':
                    return 'String';
                case 'symbol':
                    return 'Symbol';
                case 'number':
                    return 'Number';
                case 'bigint':
                    return 'BigInt';
                case 'function':
                case 'object':
                    if (null === V) return 'Null';
                    return 'Object';
            }
        };
        webidl.util.markAsUncloneable = markAsUncloneable || (()=>{});
        webidl.util.ConvertToInt = function(V, bitLength, signedness, opts) {
            let upperBound;
            let lowerBound;
            if (64 === bitLength) {
                upperBound = Math.pow(2, 53) - 1;
                lowerBound = 'unsigned' === signedness ? 0 : Math.pow(-2, 53) + 1;
            } else if ('unsigned' === signedness) {
                lowerBound = 0;
                upperBound = Math.pow(2, bitLength) - 1;
            } else {
                lowerBound = Math.pow(-2, bitLength) - 1;
                upperBound = Math.pow(2, bitLength - 1) - 1;
            }
            let x = Number(V);
            if (0 === x) x = 0;
            if (opts?.enforceRange === true) {
                if (Number.isNaN(x) || x === 1 / 0 || x === -1 / 0) throw webidl.errors.exception({
                    header: 'Integer conversion',
                    message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`
                });
                x = webidl.util.IntegerPart(x);
                if (x < lowerBound || x > upperBound) throw webidl.errors.exception({
                    header: 'Integer conversion',
                    message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
                });
                return x;
            }
            if (!Number.isNaN(x) && opts?.clamp === true) {
                x = Math.min(Math.max(x, lowerBound), upperBound);
                x = Math.floor(x) % 2 === 0 ? Math.floor(x) : Math.ceil(x);
                return x;
            }
            if (Number.isNaN(x) || 0 === x && Object.is(0, x) || x === 1 / 0 || x === -1 / 0) return 0;
            x = webidl.util.IntegerPart(x);
            x %= Math.pow(2, bitLength);
            if ('signed' === signedness && x >= Math.pow(2, bitLength) - 1) return x - Math.pow(2, bitLength);
            return x;
        };
        webidl.util.IntegerPart = function(n) {
            const r = Math.floor(Math.abs(n));
            if (n < 0) return -1 * r;
            return r;
        };
        webidl.util.Stringify = function(V) {
            const type = webidl.util.Type(V);
            switch(type){
                case 'Symbol':
                    return `Symbol(${V.description})`;
                case 'Object':
                    return inspect(V);
                case 'String':
                    return `"${V}"`;
                default:
                    return `${V}`;
            }
        };
        webidl.sequenceConverter = function(converter) {
            return (V, prefix, argument, Iterable)=>{
                if ('Object' !== webidl.util.Type(V)) throw webidl.errors.exception({
                    header: prefix,
                    message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`
                });
                const method = 'function' == typeof Iterable ? Iterable() : V?.[Symbol.iterator]?.();
                const seq = [];
                let index = 0;
                if (void 0 === method || 'function' != typeof method.next) throw webidl.errors.exception({
                    header: prefix,
                    message: `${argument} is not iterable.`
                });
                while(true){
                    const { done, value } = method.next();
                    if (done) break;
                    seq.push(converter(value, prefix, `${argument}[${index++}]`));
                }
                return seq;
            };
        };
        webidl.recordConverter = function(keyConverter, valueConverter) {
            return (O, prefix, argument)=>{
                if ('Object' !== webidl.util.Type(O)) throw webidl.errors.exception({
                    header: prefix,
                    message: `${argument} ("${webidl.util.Type(O)}") is not an Object.`
                });
                const result = {};
                if (!types.isProxy(O)) {
                    const keys = [
                        ...Object.getOwnPropertyNames(O),
                        ...Object.getOwnPropertySymbols(O)
                    ];
                    for (const key of keys){
                        const typedKey = keyConverter(key, prefix, argument);
                        const typedValue = valueConverter(O[key], prefix, argument);
                        result[typedKey] = typedValue;
                    }
                    return result;
                }
                const keys = Reflect.ownKeys(O);
                for (const key of keys){
                    const desc = Reflect.getOwnPropertyDescriptor(O, key);
                    if (desc?.enumerable) {
                        const typedKey = keyConverter(key, prefix, argument);
                        const typedValue = valueConverter(O[key], prefix, argument);
                        result[typedKey] = typedValue;
                    }
                }
                return result;
            };
        };
        webidl.interfaceConverter = function(i) {
            return (V, prefix, argument, opts)=>{
                if (opts?.strict !== false && !(V instanceof i)) throw webidl.errors.exception({
                    header: prefix,
                    message: `Expected ${argument} ("${webidl.util.Stringify(V)}") to be an instance of ${i.name}.`
                });
                return V;
            };
        };
        webidl.dictionaryConverter = function(converters) {
            return (dictionary, prefix, argument)=>{
                const type = webidl.util.Type(dictionary);
                const dict = {};
                if ('Null' === type || 'Undefined' === type) return dict;
                if ('Object' !== type) throw webidl.errors.exception({
                    header: prefix,
                    message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
                });
                for (const options of converters){
                    const { key, defaultValue, required, converter } = options;
                    if (true === required) {
                        if (!Object.hasOwn(dictionary, key)) throw webidl.errors.exception({
                            header: prefix,
                            message: `Missing required key "${key}".`
                        });
                    }
                    let value = dictionary[key];
                    const hasDefault = Object.hasOwn(options, 'defaultValue');
                    if (hasDefault && null !== value) value ??= defaultValue();
                    if (required || hasDefault || void 0 !== value) {
                        value = converter(value, prefix, `${argument}.${key}`);
                        if (options.allowedValues && !options.allowedValues.includes(value)) throw webidl.errors.exception({
                            header: prefix,
                            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`
                        });
                        dict[key] = value;
                    }
                }
                return dict;
            };
        };
        webidl.nullableConverter = function(converter) {
            return (V, prefix, argument)=>{
                if (null === V) return V;
                return converter(V, prefix, argument);
            };
        };
        webidl.converters.DOMString = function(V, prefix, argument, opts) {
            if (null === V && opts?.legacyNullToEmptyString) return '';
            if ('symbol' == typeof V) throw webidl.errors.exception({
                header: prefix,
                message: `${argument} is a symbol, which cannot be converted to a DOMString.`
            });
            return String(V);
        };
        webidl.converters.ByteString = function(V, prefix, argument) {
            const x = webidl.converters.DOMString(V, prefix, argument);
            for(let index = 0; index < x.length; index++)if (x.charCodeAt(index) > 255) throw new TypeError(`Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);
            return x;
        };
        webidl.converters.USVString = toUSVString;
        webidl.converters.boolean = function(V) {
            const x = Boolean(V);
            return x;
        };
        webidl.converters.any = function(V) {
            return V;
        };
        webidl.converters['long long'] = function(V, prefix, argument) {
            const x = webidl.util.ConvertToInt(V, 64, 'signed', void 0, prefix, argument);
            return x;
        };
        webidl.converters['unsigned long long'] = function(V, prefix, argument) {
            const x = webidl.util.ConvertToInt(V, 64, 'unsigned', void 0, prefix, argument);
            return x;
        };
        webidl.converters['unsigned long'] = function(V, prefix, argument) {
            const x = webidl.util.ConvertToInt(V, 32, 'unsigned', void 0, prefix, argument);
            return x;
        };
        webidl.converters['unsigned short'] = function(V, prefix, argument, opts) {
            const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts, prefix, argument);
            return x;
        };
        webidl.converters.ArrayBuffer = function(V, prefix, argument, opts) {
            if ('Object' !== webidl.util.Type(V) || !types.isAnyArrayBuffer(V)) throw webidl.errors.conversionFailed({
                prefix,
                argument: `${argument} ("${webidl.util.Stringify(V)}")`,
                types: [
                    'ArrayBuffer'
                ]
            });
            if (opts?.allowShared === false && types.isSharedArrayBuffer(V)) throw webidl.errors.exception({
                header: 'ArrayBuffer',
                message: 'SharedArrayBuffer is not allowed.'
            });
            if (V.resizable || V.growable) throw webidl.errors.exception({
                header: 'ArrayBuffer',
                message: 'Received a resizable ArrayBuffer.'
            });
            return V;
        };
        webidl.converters.TypedArray = function(V, T, prefix, name, opts) {
            if ('Object' !== webidl.util.Type(V) || !types.isTypedArray(V) || V.constructor.name !== T.name) throw webidl.errors.conversionFailed({
                prefix,
                argument: `${name} ("${webidl.util.Stringify(V)}")`,
                types: [
                    T.name
                ]
            });
            if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) throw webidl.errors.exception({
                header: 'ArrayBuffer',
                message: 'SharedArrayBuffer is not allowed.'
            });
            if (V.buffer.resizable || V.buffer.growable) throw webidl.errors.exception({
                header: 'ArrayBuffer',
                message: 'Received a resizable ArrayBuffer.'
            });
            return V;
        };
        webidl.converters.DataView = function(V, prefix, name, opts) {
            if ('Object' !== webidl.util.Type(V) || !types.isDataView(V)) throw webidl.errors.exception({
                header: prefix,
                message: `${name} is not a DataView.`
            });
            if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) throw webidl.errors.exception({
                header: 'ArrayBuffer',
                message: 'SharedArrayBuffer is not allowed.'
            });
            if (V.buffer.resizable || V.buffer.growable) throw webidl.errors.exception({
                header: 'ArrayBuffer',
                message: 'Received a resizable ArrayBuffer.'
            });
            return V;
        };
        webidl.converters.BufferSource = function(V, prefix, name, opts) {
            if (types.isAnyArrayBuffer(V)) return webidl.converters.ArrayBuffer(V, prefix, name, {
                ...opts,
                allowShared: false
            });
            if (types.isTypedArray(V)) return webidl.converters.TypedArray(V, V.constructor, prefix, name, {
                ...opts,
                allowShared: false
            });
            if (types.isDataView(V)) return webidl.converters.DataView(V, prefix, name, {
                ...opts,
                allowShared: false
            });
            throw webidl.errors.conversionFailed({
                prefix,
                argument: `${name} ("${webidl.util.Stringify(V)}")`,
                types: [
                    'BufferSource'
                ]
            });
        };
        webidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(webidl.converters.ByteString);
        webidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(webidl.converters['sequence<ByteString>']);
        webidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);
        module.exports = {
            webidl
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fileapi/encoding.js" (module) {
        "use strict";
        function getEncoding(label) {
            if (!label) return 'failure';
            switch(label.trim().toLowerCase()){
                case 'unicode-1-1-utf-8':
                case 'unicode11utf8':
                case 'unicode20utf8':
                case 'utf-8':
                case 'utf8':
                case 'x-unicode20utf8':
                    return 'UTF-8';
                case '866':
                case 'cp866':
                case 'csibm866':
                case 'ibm866':
                    return 'IBM866';
                case 'csisolatin2':
                case 'iso-8859-2':
                case 'iso-ir-101':
                case 'iso8859-2':
                case 'iso88592':
                case 'iso_8859-2':
                case 'iso_8859-2:1987':
                case 'l2':
                case 'latin2':
                    return 'ISO-8859-2';
                case 'csisolatin3':
                case 'iso-8859-3':
                case 'iso-ir-109':
                case 'iso8859-3':
                case 'iso88593':
                case 'iso_8859-3':
                case 'iso_8859-3:1988':
                case 'l3':
                case 'latin3':
                    return 'ISO-8859-3';
                case 'csisolatin4':
                case 'iso-8859-4':
                case 'iso-ir-110':
                case 'iso8859-4':
                case 'iso88594':
                case 'iso_8859-4':
                case 'iso_8859-4:1988':
                case 'l4':
                case 'latin4':
                    return 'ISO-8859-4';
                case 'csisolatincyrillic':
                case 'cyrillic':
                case 'iso-8859-5':
                case 'iso-ir-144':
                case 'iso8859-5':
                case 'iso88595':
                case 'iso_8859-5':
                case 'iso_8859-5:1988':
                    return 'ISO-8859-5';
                case 'arabic':
                case 'asmo-708':
                case 'csiso88596e':
                case 'csiso88596i':
                case 'csisolatinarabic':
                case 'ecma-114':
                case 'iso-8859-6':
                case 'iso-8859-6-e':
                case 'iso-8859-6-i':
                case 'iso-ir-127':
                case 'iso8859-6':
                case 'iso88596':
                case 'iso_8859-6':
                case 'iso_8859-6:1987':
                    return 'ISO-8859-6';
                case 'csisolatingreek':
                case 'ecma-118':
                case 'elot_928':
                case 'greek':
                case 'greek8':
                case 'iso-8859-7':
                case 'iso-ir-126':
                case 'iso8859-7':
                case 'iso88597':
                case 'iso_8859-7':
                case 'iso_8859-7:1987':
                case 'sun_eu_greek':
                    return 'ISO-8859-7';
                case 'csiso88598e':
                case 'csisolatinhebrew':
                case 'hebrew':
                case 'iso-8859-8':
                case 'iso-8859-8-e':
                case 'iso-ir-138':
                case 'iso8859-8':
                case 'iso88598':
                case 'iso_8859-8':
                case 'iso_8859-8:1988':
                case 'visual':
                    return 'ISO-8859-8';
                case 'csiso88598i':
                case 'iso-8859-8-i':
                case 'logical':
                    return 'ISO-8859-8-I';
                case 'csisolatin6':
                case 'iso-8859-10':
                case 'iso-ir-157':
                case 'iso8859-10':
                case 'iso885910':
                case 'l6':
                case 'latin6':
                    return 'ISO-8859-10';
                case 'iso-8859-13':
                case 'iso8859-13':
                case 'iso885913':
                    return 'ISO-8859-13';
                case 'iso-8859-14':
                case 'iso8859-14':
                case 'iso885914':
                    return 'ISO-8859-14';
                case 'csisolatin9':
                case 'iso-8859-15':
                case 'iso8859-15':
                case 'iso885915':
                case 'iso_8859-15':
                case 'l9':
                    return 'ISO-8859-15';
                case 'iso-8859-16':
                    return 'ISO-8859-16';
                case 'cskoi8r':
                case 'koi':
                case 'koi8':
                case 'koi8-r':
                case 'koi8_r':
                    return 'KOI8-R';
                case 'koi8-ru':
                case 'koi8-u':
                    return 'KOI8-U';
                case 'csmacintosh':
                case 'mac':
                case 'macintosh':
                case 'x-mac-roman':
                    return 'macintosh';
                case 'iso-8859-11':
                case 'iso8859-11':
                case 'iso885911':
                case 'tis-620':
                case 'windows-874':
                    return 'windows-874';
                case 'cp1250':
                case 'windows-1250':
                case 'x-cp1250':
                    return 'windows-1250';
                case 'cp1251':
                case 'windows-1251':
                case 'x-cp1251':
                    return 'windows-1251';
                case 'ansi_x3.4-1968':
                case 'ascii':
                case 'cp1252':
                case 'cp819':
                case 'csisolatin1':
                case 'ibm819':
                case 'iso-8859-1':
                case 'iso-ir-100':
                case 'iso8859-1':
                case 'iso88591':
                case 'iso_8859-1':
                case 'iso_8859-1:1987':
                case 'l1':
                case 'latin1':
                case 'us-ascii':
                case 'windows-1252':
                case 'x-cp1252':
                    return 'windows-1252';
                case 'cp1253':
                case 'windows-1253':
                case 'x-cp1253':
                    return 'windows-1253';
                case 'cp1254':
                case 'csisolatin5':
                case 'iso-8859-9':
                case 'iso-ir-148':
                case 'iso8859-9':
                case 'iso88599':
                case 'iso_8859-9':
                case 'iso_8859-9:1989':
                case 'l5':
                case 'latin5':
                case 'windows-1254':
                case 'x-cp1254':
                    return 'windows-1254';
                case 'cp1255':
                case 'windows-1255':
                case 'x-cp1255':
                    return 'windows-1255';
                case 'cp1256':
                case 'windows-1256':
                case 'x-cp1256':
                    return 'windows-1256';
                case 'cp1257':
                case 'windows-1257':
                case 'x-cp1257':
                    return 'windows-1257';
                case 'cp1258':
                case 'windows-1258':
                case 'x-cp1258':
                    return 'windows-1258';
                case 'x-mac-cyrillic':
                case 'x-mac-ukrainian':
                    return 'x-mac-cyrillic';
                case 'chinese':
                case 'csgb2312':
                case 'csiso58gb231280':
                case 'gb2312':
                case 'gb_2312':
                case 'gb_2312-80':
                case 'gbk':
                case 'iso-ir-58':
                case 'x-gbk':
                    return 'GBK';
                case 'gb18030':
                    return 'gb18030';
                case 'big5':
                case 'big5-hkscs':
                case 'cn-big5':
                case 'csbig5':
                case 'x-x-big5':
                    return 'Big5';
                case 'cseucpkdfmtjapanese':
                case 'euc-jp':
                case 'x-euc-jp':
                    return 'EUC-JP';
                case 'csiso2022jp':
                case 'iso-2022-jp':
                    return 'ISO-2022-JP';
                case 'csshiftjis':
                case 'ms932':
                case 'ms_kanji':
                case 'shift-jis':
                case 'shift_jis':
                case 'sjis':
                case 'windows-31j':
                case 'x-sjis':
                    return 'Shift_JIS';
                case 'cseuckr':
                case 'csksc56011987':
                case 'euc-kr':
                case 'iso-ir-149':
                case 'korean':
                case 'ks_c_5601-1987':
                case 'ks_c_5601-1989':
                case 'ksc5601':
                case 'ksc_5601':
                case 'windows-949':
                    return 'EUC-KR';
                case 'csiso2022kr':
                case 'hz-gb-2312':
                case 'iso-2022-cn':
                case 'iso-2022-cn-ext':
                case 'iso-2022-kr':
                case 'replacement':
                    return 'replacement';
                case 'unicodefffe':
                case 'utf-16be':
                    return 'UTF-16BE';
                case 'csunicode':
                case 'iso-10646-ucs-2':
                case 'ucs-2':
                case 'unicode':
                case 'unicodefeff':
                case 'utf-16':
                case 'utf-16le':
                    return 'UTF-16LE';
                case 'x-user-defined':
                    return 'x-user-defined';
                default:
                    return 'failure';
            }
        }
        module.exports = {
            getEncoding
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fileapi/filereader.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { staticPropertyDescriptors, readOperation, fireAProgressEvent } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fileapi/util.js");
        const { kState, kError, kResult, kEvents, kAborted } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fileapi/symbols.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/webidl.js");
        const { kEnumerableProperty } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        class FileReader extends EventTarget {
            constructor(){
                super();
                this[kState] = 'empty';
                this[kResult] = null;
                this[kError] = null;
                this[kEvents] = {
                    loadend: null,
                    error: null,
                    abort: null,
                    load: null,
                    progress: null,
                    loadstart: null
                };
            }
            readAsArrayBuffer(blob) {
                webidl.brandCheck(this, FileReader);
                webidl.argumentLengthCheck(arguments, 1, 'FileReader.readAsArrayBuffer');
                blob = webidl.converters.Blob(blob, {
                    strict: false
                });
                readOperation(this, blob, 'ArrayBuffer');
            }
            readAsBinaryString(blob) {
                webidl.brandCheck(this, FileReader);
                webidl.argumentLengthCheck(arguments, 1, 'FileReader.readAsBinaryString');
                blob = webidl.converters.Blob(blob, {
                    strict: false
                });
                readOperation(this, blob, 'BinaryString');
            }
            readAsText(blob, encoding) {
                webidl.brandCheck(this, FileReader);
                webidl.argumentLengthCheck(arguments, 1, 'FileReader.readAsText');
                blob = webidl.converters.Blob(blob, {
                    strict: false
                });
                if (void 0 !== encoding) encoding = webidl.converters.DOMString(encoding, 'FileReader.readAsText', 'encoding');
                readOperation(this, blob, 'Text', encoding);
            }
            readAsDataURL(blob) {
                webidl.brandCheck(this, FileReader);
                webidl.argumentLengthCheck(arguments, 1, 'FileReader.readAsDataURL');
                blob = webidl.converters.Blob(blob, {
                    strict: false
                });
                readOperation(this, blob, 'DataURL');
            }
            abort() {
                if ('empty' === this[kState] || 'done' === this[kState]) {
                    this[kResult] = null;
                    return;
                }
                if ('loading' === this[kState]) {
                    this[kState] = 'done';
                    this[kResult] = null;
                }
                this[kAborted] = true;
                fireAProgressEvent('abort', this);
                if ('loading' !== this[kState]) fireAProgressEvent('loadend', this);
            }
            get readyState() {
                webidl.brandCheck(this, FileReader);
                switch(this[kState]){
                    case 'empty':
                        return this.EMPTY;
                    case 'loading':
                        return this.LOADING;
                    case 'done':
                        return this.DONE;
                }
            }
            get result() {
                webidl.brandCheck(this, FileReader);
                return this[kResult];
            }
            get error() {
                webidl.brandCheck(this, FileReader);
                return this[kError];
            }
            get onloadend() {
                webidl.brandCheck(this, FileReader);
                return this[kEvents].loadend;
            }
            set onloadend(fn) {
                webidl.brandCheck(this, FileReader);
                if (this[kEvents].loadend) this.removeEventListener('loadend', this[kEvents].loadend);
                if ('function' == typeof fn) {
                    this[kEvents].loadend = fn;
                    this.addEventListener('loadend', fn);
                } else this[kEvents].loadend = null;
            }
            get onerror() {
                webidl.brandCheck(this, FileReader);
                return this[kEvents].error;
            }
            set onerror(fn) {
                webidl.brandCheck(this, FileReader);
                if (this[kEvents].error) this.removeEventListener('error', this[kEvents].error);
                if ('function' == typeof fn) {
                    this[kEvents].error = fn;
                    this.addEventListener('error', fn);
                } else this[kEvents].error = null;
            }
            get onloadstart() {
                webidl.brandCheck(this, FileReader);
                return this[kEvents].loadstart;
            }
            set onloadstart(fn) {
                webidl.brandCheck(this, FileReader);
                if (this[kEvents].loadstart) this.removeEventListener('loadstart', this[kEvents].loadstart);
                if ('function' == typeof fn) {
                    this[kEvents].loadstart = fn;
                    this.addEventListener('loadstart', fn);
                } else this[kEvents].loadstart = null;
            }
            get onprogress() {
                webidl.brandCheck(this, FileReader);
                return this[kEvents].progress;
            }
            set onprogress(fn) {
                webidl.brandCheck(this, FileReader);
                if (this[kEvents].progress) this.removeEventListener('progress', this[kEvents].progress);
                if ('function' == typeof fn) {
                    this[kEvents].progress = fn;
                    this.addEventListener('progress', fn);
                } else this[kEvents].progress = null;
            }
            get onload() {
                webidl.brandCheck(this, FileReader);
                return this[kEvents].load;
            }
            set onload(fn) {
                webidl.brandCheck(this, FileReader);
                if (this[kEvents].load) this.removeEventListener('load', this[kEvents].load);
                if ('function' == typeof fn) {
                    this[kEvents].load = fn;
                    this.addEventListener('load', fn);
                } else this[kEvents].load = null;
            }
            get onabort() {
                webidl.brandCheck(this, FileReader);
                return this[kEvents].abort;
            }
            set onabort(fn) {
                webidl.brandCheck(this, FileReader);
                if (this[kEvents].abort) this.removeEventListener('abort', this[kEvents].abort);
                if ('function' == typeof fn) {
                    this[kEvents].abort = fn;
                    this.addEventListener('abort', fn);
                } else this[kEvents].abort = null;
            }
        }
        FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
        FileReader.LOADING = FileReader.prototype.LOADING = 1;
        FileReader.DONE = FileReader.prototype.DONE = 2;
        Object.defineProperties(FileReader.prototype, {
            EMPTY: staticPropertyDescriptors,
            LOADING: staticPropertyDescriptors,
            DONE: staticPropertyDescriptors,
            readAsArrayBuffer: kEnumerableProperty,
            readAsBinaryString: kEnumerableProperty,
            readAsText: kEnumerableProperty,
            readAsDataURL: kEnumerableProperty,
            abort: kEnumerableProperty,
            readyState: kEnumerableProperty,
            result: kEnumerableProperty,
            error: kEnumerableProperty,
            onloadstart: kEnumerableProperty,
            onprogress: kEnumerableProperty,
            onload: kEnumerableProperty,
            onabort: kEnumerableProperty,
            onerror: kEnumerableProperty,
            onloadend: kEnumerableProperty,
            [Symbol.toStringTag]: {
                value: 'FileReader',
                writable: false,
                enumerable: false,
                configurable: true
            }
        });
        Object.defineProperties(FileReader, {
            EMPTY: staticPropertyDescriptors,
            LOADING: staticPropertyDescriptors,
            DONE: staticPropertyDescriptors
        });
        module.exports = {
            FileReader
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fileapi/progressevent.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/webidl.js");
        const kState = Symbol('ProgressEvent state');
        class ProgressEvent extends Event {
            constructor(type, eventInitDict = {}){
                type = webidl.converters.DOMString(type, 'ProgressEvent constructor', 'type');
                eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
                super(type, eventInitDict);
                this[kState] = {
                    lengthComputable: eventInitDict.lengthComputable,
                    loaded: eventInitDict.loaded,
                    total: eventInitDict.total
                };
            }
            get lengthComputable() {
                webidl.brandCheck(this, ProgressEvent);
                return this[kState].lengthComputable;
            }
            get loaded() {
                webidl.brandCheck(this, ProgressEvent);
                return this[kState].loaded;
            }
            get total() {
                webidl.brandCheck(this, ProgressEvent);
                return this[kState].total;
            }
        }
        webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
            {
                key: 'lengthComputable',
                converter: webidl.converters.boolean,
                defaultValue: ()=>false
            },
            {
                key: 'loaded',
                converter: webidl.converters['unsigned long long'],
                defaultValue: ()=>0
            },
            {
                key: 'total',
                converter: webidl.converters['unsigned long long'],
                defaultValue: ()=>0
            },
            {
                key: 'bubbles',
                converter: webidl.converters.boolean,
                defaultValue: ()=>false
            },
            {
                key: 'cancelable',
                converter: webidl.converters.boolean,
                defaultValue: ()=>false
            },
            {
                key: 'composed',
                converter: webidl.converters.boolean,
                defaultValue: ()=>false
            }
        ]);
        module.exports = {
            ProgressEvent
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fileapi/symbols.js" (module) {
        "use strict";
        module.exports = {
            kState: Symbol('FileReader state'),
            kResult: Symbol('FileReader result'),
            kError: Symbol('FileReader error'),
            kLastProgressEventFired: Symbol('FileReader last progress event fired timestamp'),
            kEvents: Symbol('FileReader events'),
            kAborted: Symbol('FileReader aborted')
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fileapi/util.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { kState, kError, kResult, kAborted, kLastProgressEventFired } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fileapi/symbols.js");
        const { ProgressEvent } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fileapi/progressevent.js");
        const { getEncoding } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fileapi/encoding.js");
        const { serializeAMimeType, parseMIMEType } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/data-url.js");
        const { types } = __webpack_require__("node:util");
        const { StringDecoder } = __webpack_require__("string_decoder");
        const { btoa } = __webpack_require__("node:buffer");
        const staticPropertyDescriptors = {
            enumerable: true,
            writable: false,
            configurable: false
        };
        function readOperation(fr, blob, type, encodingName) {
            if ('loading' === fr[kState]) throw new DOMException('Invalid state', 'InvalidStateError');
            fr[kState] = 'loading';
            fr[kResult] = null;
            fr[kError] = null;
            const stream = blob.stream();
            const reader = stream.getReader();
            const bytes = [];
            let chunkPromise = reader.read();
            let isFirstChunk = true;
            (async ()=>{
                while(!fr[kAborted])try {
                    const { done, value } = await chunkPromise;
                    if (isFirstChunk && !fr[kAborted]) queueMicrotask(()=>{
                        fireAProgressEvent('loadstart', fr);
                    });
                    isFirstChunk = false;
                    if (!done && types.isUint8Array(value)) {
                        bytes.push(value);
                        if ((void 0 === fr[kLastProgressEventFired] || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
                            fr[kLastProgressEventFired] = Date.now();
                            queueMicrotask(()=>{
                                fireAProgressEvent('progress', fr);
                            });
                        }
                        chunkPromise = reader.read();
                    } else if (done) {
                        queueMicrotask(()=>{
                            fr[kState] = 'done';
                            try {
                                const result = packageData(bytes, type, blob.type, encodingName);
                                if (fr[kAborted]) return;
                                fr[kResult] = result;
                                fireAProgressEvent('load', fr);
                            } catch (error) {
                                fr[kError] = error;
                                fireAProgressEvent('error', fr);
                            }
                            if ('loading' !== fr[kState]) fireAProgressEvent('loadend', fr);
                        });
                        break;
                    }
                } catch (error) {
                    if (fr[kAborted]) return;
                    queueMicrotask(()=>{
                        fr[kState] = 'done';
                        fr[kError] = error;
                        fireAProgressEvent('error', fr);
                        if ('loading' !== fr[kState]) fireAProgressEvent('loadend', fr);
                    });
                    break;
                }
            })();
        }
        function fireAProgressEvent(e, reader) {
            const event = new ProgressEvent(e, {
                bubbles: false,
                cancelable: false
            });
            reader.dispatchEvent(event);
        }
        function packageData(bytes, type, mimeType, encodingName) {
            switch(type){
                case 'DataURL':
                    {
                        let dataURL = 'data:';
                        const parsed = parseMIMEType(mimeType || 'application/octet-stream');
                        if ('failure' !== parsed) dataURL += serializeAMimeType(parsed);
                        dataURL += ';base64,';
                        const decoder = new StringDecoder('latin1');
                        for (const chunk of bytes)dataURL += btoa(decoder.write(chunk));
                        dataURL += btoa(decoder.end());
                        return dataURL;
                    }
                case 'Text':
                    {
                        let encoding = 'failure';
                        if (encodingName) encoding = getEncoding(encodingName);
                        if ('failure' === encoding && mimeType) {
                            const type = parseMIMEType(mimeType);
                            if ('failure' !== type) encoding = getEncoding(type.parameters.get('charset'));
                        }
                        if ('failure' === encoding) encoding = 'UTF-8';
                        return decode(bytes, encoding);
                    }
                case 'ArrayBuffer':
                    {
                        const sequence = combineByteSequences(bytes);
                        return sequence.buffer;
                    }
                case 'BinaryString':
                    {
                        let binaryString = '';
                        const decoder = new StringDecoder('latin1');
                        for (const chunk of bytes)binaryString += decoder.write(chunk);
                        binaryString += decoder.end();
                        return binaryString;
                    }
            }
        }
        function decode(ioQueue, encoding) {
            const bytes = combineByteSequences(ioQueue);
            const BOMEncoding = BOMSniffing(bytes);
            let slice = 0;
            if (null !== BOMEncoding) {
                encoding = BOMEncoding;
                slice = 'UTF-8' === BOMEncoding ? 3 : 2;
            }
            const sliced = bytes.slice(slice);
            return new TextDecoder(encoding).decode(sliced);
        }
        function BOMSniffing(ioQueue) {
            const [a, b, c] = ioQueue;
            if (0xEF === a && 0xBB === b && 0xBF === c) return 'UTF-8';
            if (0xFE === a && 0xFF === b) return 'UTF-16BE';
            if (0xFF === a && 0xFE === b) return 'UTF-16LE';
            return null;
        }
        function combineByteSequences(sequences) {
            const size = sequences.reduce((a, b)=>a + b.byteLength, 0);
            let offset = 0;
            return sequences.reduce((a, b)=>{
                a.set(b, offset);
                offset += b.byteLength;
                return a;
            }, new Uint8Array(size));
        }
        module.exports = {
            staticPropertyDescriptors,
            readOperation,
            fireAProgressEvent
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/connection.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/constants.js");
        const { kReadyState, kSentClose, kByteParser, kReceivedClose, kResponse } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/symbols.js");
        const { fireEvent, failWebsocketConnection, isClosing, isClosed, isEstablished, parseExtensions } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/util.js");
        const { channels } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/diagnostics.js");
        const { CloseEvent } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/events.js");
        const { makeRequest } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/request.js");
        const { fetching } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/index.js");
        const { Headers, getHeadersList } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/headers.js");
        const { getDecodeSplit } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/util.js");
        const { WebsocketFrameSend } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/frame.js");
        let crypto;
        try {
            crypto = __webpack_require__("node:crypto");
        } catch  {}
        function establishWebSocketConnection(url, protocols, client, ws, onEstablish, options) {
            const requestURL = url;
            requestURL.protocol = 'ws:' === url.protocol ? 'http:' : 'https:';
            const request = makeRequest({
                urlList: [
                    requestURL
                ],
                client,
                serviceWorkers: 'none',
                referrer: 'no-referrer',
                mode: 'websocket',
                credentials: 'include',
                cache: 'no-store',
                redirect: 'error'
            });
            if (options.headers) {
                const headersList = getHeadersList(new Headers(options.headers));
                request.headersList = headersList;
            }
            const keyValue = crypto.randomBytes(16).toString('base64');
            request.headersList.append('sec-websocket-key', keyValue);
            request.headersList.append('sec-websocket-version', '13');
            for (const protocol of protocols)request.headersList.append('sec-websocket-protocol', protocol);
            const permessageDeflate = 'permessage-deflate; client_max_window_bits';
            request.headersList.append('sec-websocket-extensions', permessageDeflate);
            const controller = fetching({
                request,
                useParallelQueue: true,
                dispatcher: options.dispatcher,
                processResponse (response) {
                    if ('error' === response.type || 101 !== response.status) return void failWebsocketConnection(ws, 'Received network error or non-101 status code.');
                    if (0 !== protocols.length && !response.headersList.get('Sec-WebSocket-Protocol')) return void failWebsocketConnection(ws, 'Server did not respond with sent protocols.');
                    if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') return void failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
                    if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') return void failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
                    const secWSAccept = response.headersList.get('Sec-WebSocket-Accept');
                    const digest = crypto.createHash('sha1').update(keyValue + uid).digest('base64');
                    if (secWSAccept !== digest) return void failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.');
                    const secExtension = response.headersList.get('Sec-WebSocket-Extensions');
                    let extensions;
                    if (null !== secExtension) {
                        extensions = parseExtensions(secExtension);
                        if (!extensions.has('permessage-deflate')) return void failWebsocketConnection(ws, 'Sec-WebSocket-Extensions header does not match.');
                    }
                    const secProtocol = response.headersList.get('Sec-WebSocket-Protocol');
                    if (null !== secProtocol) {
                        const requestProtocols = getDecodeSplit('sec-websocket-protocol', request.headersList);
                        if (!requestProtocols.includes(secProtocol)) return void failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.');
                    }
                    response.socket.on('data', onSocketData);
                    response.socket.on('close', onSocketClose);
                    response.socket.on('error', onSocketError);
                    if (channels.open.hasSubscribers) channels.open.publish({
                        address: response.socket.address(),
                        protocol: secProtocol,
                        extensions: secExtension
                    });
                    onEstablish(response, extensions);
                }
            });
            return controller;
        }
        function closeWebSocketConnection(ws, code, reason, reasonByteLength) {
            if (isClosing(ws) || isClosed(ws)) ;
            else if (isEstablished(ws)) if (ws[kSentClose] === sentCloseFrameState.NOT_SENT) {
                ws[kSentClose] = sentCloseFrameState.PROCESSING;
                const frame = new WebsocketFrameSend();
                if (void 0 !== code && void 0 === reason) {
                    frame.frameData = Buffer.allocUnsafe(2);
                    frame.frameData.writeUInt16BE(code, 0);
                } else if (void 0 !== code && void 0 !== reason) {
                    frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
                    frame.frameData.writeUInt16BE(code, 0);
                    frame.frameData.write(reason, 2, 'utf-8');
                } else frame.frameData = emptyBuffer;
                const socket = ws[kResponse].socket;
                socket.write(frame.createFrame(opcodes.CLOSE));
                ws[kSentClose] = sentCloseFrameState.SENT;
                ws[kReadyState] = states.CLOSING;
            } else ws[kReadyState] = states.CLOSING;
            else {
                failWebsocketConnection(ws, 'Connection was closed before it was established.');
                ws[kReadyState] = states.CLOSING;
            }
        }
        function onSocketData(chunk) {
            if (!this.ws[kByteParser].write(chunk)) this.pause();
        }
        function onSocketClose() {
            const { ws } = this;
            const { [kResponse]: response } = ws;
            response.socket.off('data', onSocketData);
            response.socket.off('close', onSocketClose);
            response.socket.off('error', onSocketError);
            const wasClean = ws[kSentClose] === sentCloseFrameState.SENT && ws[kReceivedClose];
            let code = 1005;
            let reason = '';
            const result = ws[kByteParser].closingInfo;
            if (result && !result.error) {
                code = result.code ?? 1005;
                reason = result.reason;
            } else if (!ws[kReceivedClose]) code = 1006;
            ws[kReadyState] = states.CLOSED;
            fireEvent('close', ws, (type, init)=>new CloseEvent(type, init), {
                wasClean,
                code,
                reason
            });
            if (channels.close.hasSubscribers) channels.close.publish({
                websocket: ws,
                code,
                reason
            });
        }
        function onSocketError(error) {
            const { ws } = this;
            ws[kReadyState] = states.CLOSING;
            if (channels.socketError.hasSubscribers) channels.socketError.publish(error);
            this.destroy();
        }
        module.exports = {
            establishWebSocketConnection,
            closeWebSocketConnection
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/constants.js" (module) {
        "use strict";
        const uid = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
        const staticPropertyDescriptors = {
            enumerable: true,
            writable: false,
            configurable: false
        };
        const states = {
            CONNECTING: 0,
            OPEN: 1,
            CLOSING: 2,
            CLOSED: 3
        };
        const sentCloseFrameState = {
            NOT_SENT: 0,
            PROCESSING: 1,
            SENT: 2
        };
        const opcodes = {
            CONTINUATION: 0x0,
            TEXT: 0x1,
            BINARY: 0x2,
            CLOSE: 0x8,
            PING: 0x9,
            PONG: 0xA
        };
        const maxUnsigned16Bit = 2 ** 16 - 1;
        const parserStates = {
            INFO: 0,
            PAYLOADLENGTH_16: 2,
            PAYLOADLENGTH_64: 3,
            READ_DATA: 4
        };
        const emptyBuffer = Buffer.allocUnsafe(0);
        const sendHints = {
            string: 1,
            typedArray: 2,
            arrayBuffer: 3,
            blob: 4
        };
        module.exports = {
            uid,
            sentCloseFrameState,
            staticPropertyDescriptors,
            states,
            opcodes,
            maxUnsigned16Bit,
            parserStates,
            emptyBuffer,
            sendHints
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/events.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/webidl.js");
        const { kEnumerableProperty } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { kConstruct } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/symbols.js");
        const { MessagePort } = __webpack_require__("node:worker_threads");
        class MessageEvent extends Event {
            #eventInit;
            constructor(type, eventInitDict = {}){
                if (type === kConstruct) {
                    super(arguments[1], arguments[2]);
                    webidl.util.markAsUncloneable(this);
                    return;
                }
                const prefix = 'MessageEvent constructor';
                webidl.argumentLengthCheck(arguments, 1, prefix);
                type = webidl.converters.DOMString(type, prefix, 'type');
                eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, 'eventInitDict');
                super(type, eventInitDict);
                this.#eventInit = eventInitDict;
                webidl.util.markAsUncloneable(this);
            }
            get data() {
                webidl.brandCheck(this, MessageEvent);
                return this.#eventInit.data;
            }
            get origin() {
                webidl.brandCheck(this, MessageEvent);
                return this.#eventInit.origin;
            }
            get lastEventId() {
                webidl.brandCheck(this, MessageEvent);
                return this.#eventInit.lastEventId;
            }
            get source() {
                webidl.brandCheck(this, MessageEvent);
                return this.#eventInit.source;
            }
            get ports() {
                webidl.brandCheck(this, MessageEvent);
                if (!Object.isFrozen(this.#eventInit.ports)) Object.freeze(this.#eventInit.ports);
                return this.#eventInit.ports;
            }
            initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = '', lastEventId = '', source = null, ports = []) {
                webidl.brandCheck(this, MessageEvent);
                webidl.argumentLengthCheck(arguments, 1, 'MessageEvent.initMessageEvent');
                return new MessageEvent(type, {
                    bubbles,
                    cancelable,
                    data,
                    origin,
                    lastEventId,
                    source,
                    ports
                });
            }
            static createFastMessageEvent(type, init) {
                const messageEvent = new MessageEvent(kConstruct, type, init);
                messageEvent.#eventInit = init;
                messageEvent.#eventInit.data ??= null;
                messageEvent.#eventInit.origin ??= '';
                messageEvent.#eventInit.lastEventId ??= '';
                messageEvent.#eventInit.source ??= null;
                messageEvent.#eventInit.ports ??= [];
                return messageEvent;
            }
        }
        const { createFastMessageEvent } = MessageEvent;
        delete MessageEvent.createFastMessageEvent;
        class CloseEvent extends Event {
            #eventInit;
            constructor(type, eventInitDict = {}){
                const prefix = 'CloseEvent constructor';
                webidl.argumentLengthCheck(arguments, 1, prefix);
                type = webidl.converters.DOMString(type, prefix, 'type');
                eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
                super(type, eventInitDict);
                this.#eventInit = eventInitDict;
                webidl.util.markAsUncloneable(this);
            }
            get wasClean() {
                webidl.brandCheck(this, CloseEvent);
                return this.#eventInit.wasClean;
            }
            get code() {
                webidl.brandCheck(this, CloseEvent);
                return this.#eventInit.code;
            }
            get reason() {
                webidl.brandCheck(this, CloseEvent);
                return this.#eventInit.reason;
            }
        }
        class ErrorEvent extends Event {
            #eventInit;
            constructor(type, eventInitDict){
                const prefix = 'ErrorEvent constructor';
                webidl.argumentLengthCheck(arguments, 1, prefix);
                super(type, eventInitDict);
                webidl.util.markAsUncloneable(this);
                type = webidl.converters.DOMString(type, prefix, 'type');
                eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
                this.#eventInit = eventInitDict;
            }
            get message() {
                webidl.brandCheck(this, ErrorEvent);
                return this.#eventInit.message;
            }
            get filename() {
                webidl.brandCheck(this, ErrorEvent);
                return this.#eventInit.filename;
            }
            get lineno() {
                webidl.brandCheck(this, ErrorEvent);
                return this.#eventInit.lineno;
            }
            get colno() {
                webidl.brandCheck(this, ErrorEvent);
                return this.#eventInit.colno;
            }
            get error() {
                webidl.brandCheck(this, ErrorEvent);
                return this.#eventInit.error;
            }
        }
        Object.defineProperties(MessageEvent.prototype, {
            [Symbol.toStringTag]: {
                value: 'MessageEvent',
                configurable: true
            },
            data: kEnumerableProperty,
            origin: kEnumerableProperty,
            lastEventId: kEnumerableProperty,
            source: kEnumerableProperty,
            ports: kEnumerableProperty,
            initMessageEvent: kEnumerableProperty
        });
        Object.defineProperties(CloseEvent.prototype, {
            [Symbol.toStringTag]: {
                value: 'CloseEvent',
                configurable: true
            },
            reason: kEnumerableProperty,
            code: kEnumerableProperty,
            wasClean: kEnumerableProperty
        });
        Object.defineProperties(ErrorEvent.prototype, {
            [Symbol.toStringTag]: {
                value: 'ErrorEvent',
                configurable: true
            },
            message: kEnumerableProperty,
            filename: kEnumerableProperty,
            lineno: kEnumerableProperty,
            colno: kEnumerableProperty,
            error: kEnumerableProperty
        });
        webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
        webidl.converters['sequence<MessagePort>'] = webidl.sequenceConverter(webidl.converters.MessagePort);
        const eventInit = [
            {
                key: 'bubbles',
                converter: webidl.converters.boolean,
                defaultValue: ()=>false
            },
            {
                key: 'cancelable',
                converter: webidl.converters.boolean,
                defaultValue: ()=>false
            },
            {
                key: 'composed',
                converter: webidl.converters.boolean,
                defaultValue: ()=>false
            }
        ];
        webidl.converters.MessageEventInit = webidl.dictionaryConverter([
            ...eventInit,
            {
                key: 'data',
                converter: webidl.converters.any,
                defaultValue: ()=>null
            },
            {
                key: 'origin',
                converter: webidl.converters.USVString,
                defaultValue: ()=>''
            },
            {
                key: 'lastEventId',
                converter: webidl.converters.DOMString,
                defaultValue: ()=>''
            },
            {
                key: 'source',
                converter: webidl.nullableConverter(webidl.converters.MessagePort),
                defaultValue: ()=>null
            },
            {
                key: 'ports',
                converter: webidl.converters['sequence<MessagePort>'],
                defaultValue: ()=>new Array(0)
            }
        ]);
        webidl.converters.CloseEventInit = webidl.dictionaryConverter([
            ...eventInit,
            {
                key: 'wasClean',
                converter: webidl.converters.boolean,
                defaultValue: ()=>false
            },
            {
                key: 'code',
                converter: webidl.converters['unsigned short'],
                defaultValue: ()=>0
            },
            {
                key: 'reason',
                converter: webidl.converters.USVString,
                defaultValue: ()=>''
            }
        ]);
        webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
            ...eventInit,
            {
                key: 'message',
                converter: webidl.converters.DOMString,
                defaultValue: ()=>''
            },
            {
                key: 'filename',
                converter: webidl.converters.USVString,
                defaultValue: ()=>''
            },
            {
                key: 'lineno',
                converter: webidl.converters['unsigned long'],
                defaultValue: ()=>0
            },
            {
                key: 'colno',
                converter: webidl.converters['unsigned long'],
                defaultValue: ()=>0
            },
            {
                key: 'error',
                converter: webidl.converters.any
            }
        ]);
        module.exports = {
            MessageEvent,
            CloseEvent,
            ErrorEvent,
            createFastMessageEvent
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/frame.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { maxUnsigned16Bit } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/constants.js");
        const BUFFER_SIZE = 16386;
        let crypto;
        let buffer = null;
        let bufIdx = BUFFER_SIZE;
        try {
            crypto = __webpack_require__("node:crypto");
        } catch  {
            crypto = {
                randomFillSync: function(buffer, _offset, _size) {
                    for(let i = 0; i < buffer.length; ++i)buffer[i] = 255 * Math.random() | 0;
                    return buffer;
                }
            };
        }
        function generateMask() {
            if (bufIdx === BUFFER_SIZE) {
                bufIdx = 0;
                crypto.randomFillSync(buffer ??= Buffer.allocUnsafe(BUFFER_SIZE), 0, BUFFER_SIZE);
            }
            return [
                buffer[bufIdx++],
                buffer[bufIdx++],
                buffer[bufIdx++],
                buffer[bufIdx++]
            ];
        }
        class WebsocketFrameSend {
            constructor(data){
                this.frameData = data;
            }
            createFrame(opcode) {
                const frameData = this.frameData;
                const maskKey = generateMask();
                const bodyLength = frameData?.byteLength ?? 0;
                let payloadLength = bodyLength;
                let offset = 6;
                if (bodyLength > maxUnsigned16Bit) {
                    offset += 8;
                    payloadLength = 127;
                } else if (bodyLength > 125) {
                    offset += 2;
                    payloadLength = 126;
                }
                const buffer = Buffer.allocUnsafe(bodyLength + offset);
                buffer[0] = buffer[1] = 0;
                buffer[0] |= 0x80;
                buffer[0] = (0xF0 & buffer[0]) + opcode;
                /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */ buffer[offset - 4] = maskKey[0];
                buffer[offset - 3] = maskKey[1];
                buffer[offset - 2] = maskKey[2];
                buffer[offset - 1] = maskKey[3];
                buffer[1] = payloadLength;
                if (126 === payloadLength) buffer.writeUInt16BE(bodyLength, 2);
                else if (127 === payloadLength) {
                    buffer[2] = buffer[3] = 0;
                    buffer.writeUIntBE(bodyLength, 4, 6);
                }
                buffer[1] |= 0x80;
                for(let i = 0; i < bodyLength; ++i)buffer[offset + i] = frameData[i] ^ maskKey[3 & i];
                return buffer;
            }
        }
        module.exports = {
            WebsocketFrameSend
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/permessage-deflate.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { createInflateRaw, Z_DEFAULT_WINDOWBITS } = __webpack_require__("node:zlib");
        const { isValidClientWindowBits } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/util.js");
        const tail = Buffer.from([
            0x00,
            0x00,
            0xff,
            0xff
        ]);
        const kBuffer = Symbol('kBuffer');
        const kLength = Symbol('kLength');
        class PerMessageDeflate {
            #inflate;
            #options = {};
            constructor(extensions){
                this.#options.serverNoContextTakeover = extensions.has('server_no_context_takeover');
                this.#options.serverMaxWindowBits = extensions.get('server_max_window_bits');
            }
            decompress(chunk, fin, callback) {
                if (!this.#inflate) {
                    let windowBits = Z_DEFAULT_WINDOWBITS;
                    if (this.#options.serverMaxWindowBits) {
                        if (!isValidClientWindowBits(this.#options.serverMaxWindowBits)) return void callback(new Error('Invalid server_max_window_bits'));
                        windowBits = Number.parseInt(this.#options.serverMaxWindowBits);
                    }
                    this.#inflate = createInflateRaw({
                        windowBits
                    });
                    this.#inflate[kBuffer] = [];
                    this.#inflate[kLength] = 0;
                    this.#inflate.on('data', (data)=>{
                        this.#inflate[kBuffer].push(data);
                        this.#inflate[kLength] += data.length;
                    });
                    this.#inflate.on('error', (err)=>{
                        this.#inflate = null;
                        callback(err);
                    });
                }
                this.#inflate.write(chunk);
                if (fin) this.#inflate.write(tail);
                this.#inflate.flush(()=>{
                    const full = Buffer.concat(this.#inflate[kBuffer], this.#inflate[kLength]);
                    this.#inflate[kBuffer].length = 0;
                    this.#inflate[kLength] = 0;
                    callback(null, full);
                });
            }
        }
        module.exports = {
            PerMessageDeflate
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/receiver.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { Writable } = __webpack_require__("node:stream");
        const assert = __webpack_require__("node:assert");
        const { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/constants.js");
        const { kReadyState, kSentClose, kResponse, kReceivedClose } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/symbols.js");
        const { channels } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/diagnostics.js");
        const { isValidStatusCode, isValidOpcode, failWebsocketConnection, websocketMessageReceived, utf8Decode, isControlFrame, isTextBinaryFrame, isContinuationFrame } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/util.js");
        const { WebsocketFrameSend } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/frame.js");
        const { closeWebSocketConnection } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/connection.js");
        const { PerMessageDeflate } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/permessage-deflate.js");
        class ByteParser extends Writable {
            #buffers = [];
            #byteOffset = 0;
            #loop = false;
            #state = parserStates.INFO;
            #info = {};
            #fragments = [];
            #extensions;
            constructor(ws, extensions){
                super();
                this.ws = ws;
                this.#extensions = null == extensions ? new Map() : extensions;
                if (this.#extensions.has('permessage-deflate')) this.#extensions.set('permessage-deflate', new PerMessageDeflate(extensions));
            }
            _write(chunk, _, callback) {
                this.#buffers.push(chunk);
                this.#byteOffset += chunk.length;
                this.#loop = true;
                this.run(callback);
            }
            run(callback) {
                while(this.#loop)if (this.#state === parserStates.INFO) {
                    if (this.#byteOffset < 2) return callback();
                    const buffer = this.consume(2);
                    const fin = (0x80 & buffer[0]) !== 0;
                    const opcode = 0x0F & buffer[0];
                    const masked = (0x80 & buffer[1]) === 0x80;
                    const fragmented = !fin && opcode !== opcodes.CONTINUATION;
                    const payloadLength = 0x7F & buffer[1];
                    const rsv1 = 0x40 & buffer[0];
                    const rsv2 = 0x20 & buffer[0];
                    const rsv3 = 0x10 & buffer[0];
                    if (!isValidOpcode(opcode)) {
                        failWebsocketConnection(this.ws, 'Invalid opcode received');
                        return callback();
                    }
                    if (masked) {
                        failWebsocketConnection(this.ws, 'Frame cannot be masked');
                        return callback();
                    }
                    if (0 !== rsv1 && !this.#extensions.has('permessage-deflate')) return void failWebsocketConnection(this.ws, 'Expected RSV1 to be clear.');
                    if (0 !== rsv2 || 0 !== rsv3) return void failWebsocketConnection(this.ws, 'RSV1, RSV2, RSV3 must be clear');
                    if (fragmented && !isTextBinaryFrame(opcode)) return void failWebsocketConnection(this.ws, 'Invalid frame type was fragmented.');
                    if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) return void failWebsocketConnection(this.ws, 'Expected continuation frame');
                    if (this.#info.fragmented && fragmented) return void failWebsocketConnection(this.ws, 'Fragmented frame exceeded 125 bytes.');
                    if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) return void failWebsocketConnection(this.ws, 'Control frame either too large or fragmented');
                    if (isContinuationFrame(opcode) && 0 === this.#fragments.length && !this.#info.compressed) return void failWebsocketConnection(this.ws, 'Unexpected continuation frame');
                    if (payloadLength <= 125) {
                        this.#info.payloadLength = payloadLength;
                        this.#state = parserStates.READ_DATA;
                    } else if (126 === payloadLength) this.#state = parserStates.PAYLOADLENGTH_16;
                    else if (127 === payloadLength) this.#state = parserStates.PAYLOADLENGTH_64;
                    if (isTextBinaryFrame(opcode)) {
                        this.#info.binaryType = opcode;
                        this.#info.compressed = 0 !== rsv1;
                    }
                    this.#info.opcode = opcode;
                    this.#info.masked = masked;
                    this.#info.fin = fin;
                    this.#info.fragmented = fragmented;
                } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
                    if (this.#byteOffset < 2) return callback();
                    const buffer = this.consume(2);
                    this.#info.payloadLength = buffer.readUInt16BE(0);
                    this.#state = parserStates.READ_DATA;
                } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
                    if (this.#byteOffset < 8) return callback();
                    const buffer = this.consume(8);
                    const upper = buffer.readUInt32BE(0);
                    if (upper > 2 ** 31 - 1) return void failWebsocketConnection(this.ws, 'Received payload length > 2^31 bytes.');
                    const lower = buffer.readUInt32BE(4);
                    this.#info.payloadLength = (upper << 8) + lower;
                    this.#state = parserStates.READ_DATA;
                } else if (this.#state === parserStates.READ_DATA) {
                    if (this.#byteOffset < this.#info.payloadLength) return callback();
                    const body = this.consume(this.#info.payloadLength);
                    if (isControlFrame(this.#info.opcode)) {
                        this.#loop = this.parseControlFrame(body);
                        this.#state = parserStates.INFO;
                    } else if (this.#info.compressed) {
                        this.#extensions.get('permessage-deflate').decompress(body, this.#info.fin, (error, data)=>{
                            if (error) return void closeWebSocketConnection(this.ws, 1007, error.message, error.message.length);
                            this.#fragments.push(data);
                            if (!this.#info.fin) {
                                this.#state = parserStates.INFO;
                                this.#loop = true;
                                this.run(callback);
                                return;
                            }
                            websocketMessageReceived(this.ws, this.#info.binaryType, Buffer.concat(this.#fragments));
                            this.#loop = true;
                            this.#state = parserStates.INFO;
                            this.#fragments.length = 0;
                            this.run(callback);
                        });
                        this.#loop = false;
                        break;
                    } else {
                        this.#fragments.push(body);
                        if (!this.#info.fragmented && this.#info.fin) {
                            const fullMessage = Buffer.concat(this.#fragments);
                            websocketMessageReceived(this.ws, this.#info.binaryType, fullMessage);
                            this.#fragments.length = 0;
                        }
                        this.#state = parserStates.INFO;
                    }
                }
            }
            consume(n) {
                if (n > this.#byteOffset) throw new Error('Called consume() before buffers satiated.');
                if (0 === n) return emptyBuffer;
                if (this.#buffers[0].length === n) {
                    this.#byteOffset -= this.#buffers[0].length;
                    return this.#buffers.shift();
                }
                const buffer = Buffer.allocUnsafe(n);
                let offset = 0;
                while(offset !== n){
                    const next = this.#buffers[0];
                    const { length } = next;
                    if (length + offset === n) {
                        buffer.set(this.#buffers.shift(), offset);
                        break;
                    }
                    if (length + offset > n) {
                        buffer.set(next.subarray(0, n - offset), offset);
                        this.#buffers[0] = next.subarray(n - offset);
                        break;
                    }
                    buffer.set(this.#buffers.shift(), offset);
                    offset += next.length;
                }
                this.#byteOffset -= n;
                return buffer;
            }
            parseCloseBody(data) {
                assert(1 !== data.length);
                let code;
                if (data.length >= 2) code = data.readUInt16BE(0);
                if (void 0 !== code && !isValidStatusCode(code)) return {
                    code: 1002,
                    reason: 'Invalid status code',
                    error: true
                };
                let reason = data.subarray(2);
                if (0xEF === reason[0] && 0xBB === reason[1] && 0xBF === reason[2]) reason = reason.subarray(3);
                try {
                    reason = utf8Decode(reason);
                } catch  {
                    return {
                        code: 1007,
                        reason: 'Invalid UTF-8',
                        error: true
                    };
                }
                return {
                    code,
                    reason,
                    error: false
                };
            }
            parseControlFrame(body) {
                const { opcode, payloadLength } = this.#info;
                if (opcode === opcodes.CLOSE) {
                    if (1 === payloadLength) {
                        failWebsocketConnection(this.ws, 'Received close frame with a 1-byte body.');
                        return false;
                    }
                    this.#info.closeInfo = this.parseCloseBody(body);
                    if (this.#info.closeInfo.error) {
                        const { code, reason } = this.#info.closeInfo;
                        closeWebSocketConnection(this.ws, code, reason, reason.length);
                        failWebsocketConnection(this.ws, reason);
                        return false;
                    }
                    if (this.ws[kSentClose] !== sentCloseFrameState.SENT) {
                        let body = emptyBuffer;
                        if (this.#info.closeInfo.code) {
                            body = Buffer.allocUnsafe(2);
                            body.writeUInt16BE(this.#info.closeInfo.code, 0);
                        }
                        const closeFrame = new WebsocketFrameSend(body);
                        this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), (err)=>{
                            if (!err) this.ws[kSentClose] = sentCloseFrameState.SENT;
                        });
                    }
                    this.ws[kReadyState] = states.CLOSING;
                    this.ws[kReceivedClose] = true;
                    return false;
                }
                if (opcode === opcodes.PING) {
                    if (!this.ws[kReceivedClose]) {
                        const frame = new WebsocketFrameSend(body);
                        this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
                        if (channels.ping.hasSubscribers) channels.ping.publish({
                            payload: body
                        });
                    }
                } else if (opcode === opcodes.PONG) {
                    if (channels.pong.hasSubscribers) channels.pong.publish({
                        payload: body
                    });
                }
                return true;
            }
            get closingInfo() {
                return this.#info.closeInfo;
            }
        }
        module.exports = {
            ByteParser
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/sender.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { WebsocketFrameSend } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/frame.js");
        const { opcodes, sendHints } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/constants.js");
        const FixedQueue = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/dispatcher/fixed-queue.js");
        const FastBuffer = Buffer[Symbol.species];
        class SendQueue {
            #queue = new FixedQueue();
            #running = false;
            #socket;
            constructor(socket){
                this.#socket = socket;
            }
            add(item, cb, hint) {
                if (hint !== sendHints.blob) {
                    const frame = createFrame(item, hint);
                    if (this.#running) {
                        const node = {
                            promise: null,
                            callback: cb,
                            frame
                        };
                        this.#queue.push(node);
                    } else this.#socket.write(frame, cb);
                    return;
                }
                const node = {
                    promise: item.arrayBuffer().then((ab)=>{
                        node.promise = null;
                        node.frame = createFrame(ab, hint);
                    }),
                    callback: cb,
                    frame: null
                };
                this.#queue.push(node);
                if (!this.#running) this.#run();
            }
            async #run() {
                this.#running = true;
                const queue = this.#queue;
                while(!queue.isEmpty()){
                    const node = queue.shift();
                    if (null !== node.promise) await node.promise;
                    this.#socket.write(node.frame, node.callback);
                    node.callback = node.frame = null;
                }
                this.#running = false;
            }
        }
        function createFrame(data, hint) {
            return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.string ? opcodes.TEXT : opcodes.BINARY);
        }
        function toBuffer(data, hint) {
            switch(hint){
                case sendHints.string:
                    return Buffer.from(data);
                case sendHints.arrayBuffer:
                case sendHints.blob:
                    return new FastBuffer(data);
                case sendHints.typedArray:
                    return new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
            }
        }
        module.exports = {
            SendQueue
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/symbols.js" (module) {
        "use strict";
        module.exports = {
            kWebSocketURL: Symbol('url'),
            kReadyState: Symbol('ready state'),
            kController: Symbol('controller'),
            kResponse: Symbol('response'),
            kBinaryType: Symbol('binary type'),
            kSentClose: Symbol('sent close'),
            kReceivedClose: Symbol('received close'),
            kByteParser: Symbol('byte parser')
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/util.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/symbols.js");
        const { states, opcodes } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/constants.js");
        const { ErrorEvent, createFastMessageEvent } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/events.js");
        const { isUtf8 } = __webpack_require__("node:buffer");
        const { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/data-url.js");
        function isConnecting(ws) {
            return ws[kReadyState] === states.CONNECTING;
        }
        function isEstablished(ws) {
            return ws[kReadyState] === states.OPEN;
        }
        function isClosing(ws) {
            return ws[kReadyState] === states.CLOSING;
        }
        function isClosed(ws) {
            return ws[kReadyState] === states.CLOSED;
        }
        function fireEvent(e, target, eventFactory = (type, init)=>new Event(type, init), eventInitDict = {}) {
            const event = eventFactory(e, eventInitDict);
            target.dispatchEvent(event);
        }
        function websocketMessageReceived(ws, type, data) {
            if (ws[kReadyState] !== states.OPEN) return;
            let dataForEvent;
            if (type === opcodes.TEXT) try {
                dataForEvent = utf8Decode(data);
            } catch  {
                failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.');
                return;
            }
            else if (type === opcodes.BINARY) dataForEvent = 'blob' === ws[kBinaryType] ? new Blob([
                data
            ]) : toArrayBuffer(data);
            fireEvent('message', ws, createFastMessageEvent, {
                origin: ws[kWebSocketURL].origin,
                data: dataForEvent
            });
        }
        function toArrayBuffer(buffer) {
            if (buffer.byteLength === buffer.buffer.byteLength) return buffer.buffer;
            return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
        }
        function isValidSubprotocol(protocol) {
            if (0 === protocol.length) return false;
            for(let i = 0; i < protocol.length; ++i){
                const code = protocol.charCodeAt(i);
                if (code < 0x21 || code > 0x7E || 0x22 === code || 0x28 === code || 0x29 === code || 0x2C === code || 0x2F === code || 0x3A === code || 0x3B === code || 0x3C === code || 0x3D === code || 0x3E === code || 0x3F === code || 0x40 === code || 0x5B === code || 0x5C === code || 0x5D === code || 0x7B === code || 0x7D === code) return false;
            }
            return true;
        }
        function isValidStatusCode(code) {
            if (code >= 1000 && code < 1015) return 1004 !== code && 1005 !== code && 1006 !== code;
            return code >= 3000 && code <= 4999;
        }
        function failWebsocketConnection(ws, reason) {
            const { [kController]: controller, [kResponse]: response } = ws;
            controller.abort();
            if (response?.socket && !response.socket.destroyed) response.socket.destroy();
            if (reason) fireEvent('error', ws, (type, init)=>new ErrorEvent(type, init), {
                error: new Error(reason),
                message: reason
            });
        }
        function isControlFrame(opcode) {
            return opcode === opcodes.CLOSE || opcode === opcodes.PING || opcode === opcodes.PONG;
        }
        function isContinuationFrame(opcode) {
            return opcode === opcodes.CONTINUATION;
        }
        function isTextBinaryFrame(opcode) {
            return opcode === opcodes.TEXT || opcode === opcodes.BINARY;
        }
        function isValidOpcode(opcode) {
            return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode);
        }
        function parseExtensions(extensions) {
            const position = {
                position: 0
            };
            const extensionList = new Map();
            while(position.position < extensions.length){
                const pair = collectASequenceOfCodePointsFast(';', extensions, position);
                const [name, value = ''] = pair.split('=');
                extensionList.set(removeHTTPWhitespace(name, true, false), removeHTTPWhitespace(value, false, true));
                position.position++;
            }
            return extensionList;
        }
        function isValidClientWindowBits(value) {
            for(let i = 0; i < value.length; i++){
                const byte = value.charCodeAt(i);
                if (byte < 0x30 || byte > 0x39) return false;
            }
            return true;
        }
        const hasIntl = 'string' == typeof process.versions.icu;
        const fatalDecoder = hasIntl ? new TextDecoder('utf-8', {
            fatal: true
        }) : void 0;
        const utf8Decode = hasIntl ? fatalDecoder.decode.bind(fatalDecoder) : function(buffer) {
            if (isUtf8(buffer)) return buffer.toString('utf-8');
            throw new TypeError('Invalid utf-8 received.');
        };
        module.exports = {
            isConnecting,
            isEstablished,
            isClosing,
            isClosed,
            fireEvent,
            isValidSubprotocol,
            isValidStatusCode,
            failWebsocketConnection,
            websocketMessageReceived,
            utf8Decode,
            isControlFrame,
            isContinuationFrame,
            isTextBinaryFrame,
            isValidOpcode,
            parseExtensions,
            isValidClientWindowBits
        };
    },
    "../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/websocket.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/webidl.js");
        const { URLSerializer } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/data-url.js");
        const { environmentSettingsObject } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/fetch/util.js");
        const { staticPropertyDescriptors, states, sentCloseFrameState, sendHints } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/constants.js");
        const { kWebSocketURL, kReadyState, kController, kBinaryType, kResponse, kSentClose, kByteParser } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/symbols.js");
        const { isConnecting, isEstablished, isClosing, isValidSubprotocol, fireEvent } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/util.js");
        const { establishWebSocketConnection, closeWebSocketConnection } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/connection.js");
        const { ByteParser } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/receiver.js");
        const { kEnumerableProperty, isBlobLike } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/core/util.js");
        const { getGlobalDispatcher } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/global.js");
        const { types } = __webpack_require__("node:util");
        const { ErrorEvent, CloseEvent } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/events.js");
        const { SendQueue } = __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/lib/web/websocket/sender.js");
        class WebSocket extends EventTarget {
            #events = {
                open: null,
                error: null,
                close: null,
                message: null
            };
            #bufferedAmount = 0;
            #protocol = '';
            #extensions = '';
            #sendQueue;
            constructor(url, protocols = []){
                super();
                webidl.util.markAsUncloneable(this);
                const prefix = 'WebSocket constructor';
                webidl.argumentLengthCheck(arguments, 1, prefix);
                const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols, prefix, 'options');
                url = webidl.converters.USVString(url, prefix, 'url');
                protocols = options.protocols;
                const baseURL = environmentSettingsObject.settingsObject.baseUrl;
                let urlRecord;
                try {
                    urlRecord = new URL(url, baseURL);
                } catch (e) {
                    throw new DOMException(e, 'SyntaxError');
                }
                if ('http:' === urlRecord.protocol) urlRecord.protocol = 'ws:';
                else if ('https:' === urlRecord.protocol) urlRecord.protocol = 'wss:';
                if ('ws:' !== urlRecord.protocol && 'wss:' !== urlRecord.protocol) throw new DOMException(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, 'SyntaxError');
                if (urlRecord.hash || urlRecord.href.endsWith('#')) throw new DOMException('Got fragment', 'SyntaxError');
                if ('string' == typeof protocols) protocols = [
                    protocols
                ];
                if (protocols.length !== new Set(protocols.map((p)=>p.toLowerCase())).size) throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError');
                if (protocols.length > 0 && !protocols.every((p)=>isValidSubprotocol(p))) throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError');
                this[kWebSocketURL] = new URL(urlRecord.href);
                const client = environmentSettingsObject.settingsObject;
                this[kController] = establishWebSocketConnection(urlRecord, protocols, client, this, (response, extensions)=>this.#onConnectionEstablished(response, extensions), options);
                this[kReadyState] = WebSocket.CONNECTING;
                this[kSentClose] = sentCloseFrameState.NOT_SENT;
                this[kBinaryType] = 'blob';
            }
            close(code, reason) {
                webidl.brandCheck(this, WebSocket);
                const prefix = 'WebSocket.close';
                if (void 0 !== code) code = webidl.converters['unsigned short'](code, prefix, 'code', {
                    clamp: true
                });
                if (void 0 !== reason) reason = webidl.converters.USVString(reason, prefix, 'reason');
                if (void 0 !== code) {
                    if (1000 !== code && (code < 3000 || code > 4999)) throw new DOMException('invalid code', 'InvalidAccessError');
                }
                let reasonByteLength = 0;
                if (void 0 !== reason) {
                    reasonByteLength = Buffer.byteLength(reason);
                    if (reasonByteLength > 123) throw new DOMException(`Reason must be less than 123 bytes; received ${reasonByteLength}`, 'SyntaxError');
                }
                closeWebSocketConnection(this, code, reason, reasonByteLength);
            }
            send(data) {
                webidl.brandCheck(this, WebSocket);
                const prefix = 'WebSocket.send';
                webidl.argumentLengthCheck(arguments, 1, prefix);
                data = webidl.converters.WebSocketSendData(data, prefix, 'data');
                if (isConnecting(this)) throw new DOMException('Sent before connected.', 'InvalidStateError');
                if (!isEstablished(this) || isClosing(this)) return;
                if ('string' == typeof data) {
                    const length = Buffer.byteLength(data);
                    this.#bufferedAmount += length;
                    this.#sendQueue.add(data, ()=>{
                        this.#bufferedAmount -= length;
                    }, sendHints.string);
                } else if (types.isArrayBuffer(data)) {
                    this.#bufferedAmount += data.byteLength;
                    this.#sendQueue.add(data, ()=>{
                        this.#bufferedAmount -= data.byteLength;
                    }, sendHints.arrayBuffer);
                } else if (ArrayBuffer.isView(data)) {
                    this.#bufferedAmount += data.byteLength;
                    this.#sendQueue.add(data, ()=>{
                        this.#bufferedAmount -= data.byteLength;
                    }, sendHints.typedArray);
                } else if (isBlobLike(data)) {
                    this.#bufferedAmount += data.size;
                    this.#sendQueue.add(data, ()=>{
                        this.#bufferedAmount -= data.size;
                    }, sendHints.blob);
                }
            }
            get readyState() {
                webidl.brandCheck(this, WebSocket);
                return this[kReadyState];
            }
            get bufferedAmount() {
                webidl.brandCheck(this, WebSocket);
                return this.#bufferedAmount;
            }
            get url() {
                webidl.brandCheck(this, WebSocket);
                return URLSerializer(this[kWebSocketURL]);
            }
            get extensions() {
                webidl.brandCheck(this, WebSocket);
                return this.#extensions;
            }
            get protocol() {
                webidl.brandCheck(this, WebSocket);
                return this.#protocol;
            }
            get onopen() {
                webidl.brandCheck(this, WebSocket);
                return this.#events.open;
            }
            set onopen(fn) {
                webidl.brandCheck(this, WebSocket);
                if (this.#events.open) this.removeEventListener('open', this.#events.open);
                if ('function' == typeof fn) {
                    this.#events.open = fn;
                    this.addEventListener('open', fn);
                } else this.#events.open = null;
            }
            get onerror() {
                webidl.brandCheck(this, WebSocket);
                return this.#events.error;
            }
            set onerror(fn) {
                webidl.brandCheck(this, WebSocket);
                if (this.#events.error) this.removeEventListener('error', this.#events.error);
                if ('function' == typeof fn) {
                    this.#events.error = fn;
                    this.addEventListener('error', fn);
                } else this.#events.error = null;
            }
            get onclose() {
                webidl.brandCheck(this, WebSocket);
                return this.#events.close;
            }
            set onclose(fn) {
                webidl.brandCheck(this, WebSocket);
                if (this.#events.close) this.removeEventListener('close', this.#events.close);
                if ('function' == typeof fn) {
                    this.#events.close = fn;
                    this.addEventListener('close', fn);
                } else this.#events.close = null;
            }
            get onmessage() {
                webidl.brandCheck(this, WebSocket);
                return this.#events.message;
            }
            set onmessage(fn) {
                webidl.brandCheck(this, WebSocket);
                if (this.#events.message) this.removeEventListener('message', this.#events.message);
                if ('function' == typeof fn) {
                    this.#events.message = fn;
                    this.addEventListener('message', fn);
                } else this.#events.message = null;
            }
            get binaryType() {
                webidl.brandCheck(this, WebSocket);
                return this[kBinaryType];
            }
            set binaryType(type) {
                webidl.brandCheck(this, WebSocket);
                if ('blob' !== type && 'arraybuffer' !== type) this[kBinaryType] = 'blob';
                else this[kBinaryType] = type;
            }
            #onConnectionEstablished(response, parsedExtensions) {
                this[kResponse] = response;
                const parser = new ByteParser(this, parsedExtensions);
                parser.on('drain', onParserDrain);
                parser.on('error', onParserError.bind(this));
                response.socket.ws = this;
                this[kByteParser] = parser;
                this.#sendQueue = new SendQueue(response.socket);
                this[kReadyState] = states.OPEN;
                const extensions = response.headersList.get('sec-websocket-extensions');
                if (null !== extensions) this.#extensions = extensions;
                const protocol = response.headersList.get('sec-websocket-protocol');
                if (null !== protocol) this.#protocol = protocol;
                fireEvent('open', this);
            }
        }
        WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
        WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
        WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
        WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
        Object.defineProperties(WebSocket.prototype, {
            CONNECTING: staticPropertyDescriptors,
            OPEN: staticPropertyDescriptors,
            CLOSING: staticPropertyDescriptors,
            CLOSED: staticPropertyDescriptors,
            url: kEnumerableProperty,
            readyState: kEnumerableProperty,
            bufferedAmount: kEnumerableProperty,
            onopen: kEnumerableProperty,
            onerror: kEnumerableProperty,
            onclose: kEnumerableProperty,
            close: kEnumerableProperty,
            onmessage: kEnumerableProperty,
            binaryType: kEnumerableProperty,
            send: kEnumerableProperty,
            extensions: kEnumerableProperty,
            protocol: kEnumerableProperty,
            [Symbol.toStringTag]: {
                value: 'WebSocket',
                writable: false,
                enumerable: false,
                configurable: true
            }
        });
        Object.defineProperties(WebSocket, {
            CONNECTING: staticPropertyDescriptors,
            OPEN: staticPropertyDescriptors,
            CLOSING: staticPropertyDescriptors,
            CLOSED: staticPropertyDescriptors
        });
        webidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(webidl.converters.DOMString);
        webidl.converters['DOMString or sequence<DOMString>'] = function(V, prefix, argument) {
            if ('Object' === webidl.util.Type(V) && Symbol.iterator in V) return webidl.converters['sequence<DOMString>'](V);
            return webidl.converters.DOMString(V, prefix, argument);
        };
        webidl.converters.WebSocketInit = webidl.dictionaryConverter([
            {
                key: 'protocols',
                converter: webidl.converters['DOMString or sequence<DOMString>'],
                defaultValue: ()=>new Array(0)
            },
            {
                key: 'dispatcher',
                converter: webidl.converters.any,
                defaultValue: ()=>getGlobalDispatcher()
            },
            {
                key: 'headers',
                converter: webidl.nullableConverter(webidl.converters.HeadersInit)
            }
        ]);
        webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function(V) {
            if ('Object' === webidl.util.Type(V) && !(Symbol.iterator in V)) return webidl.converters.WebSocketInit(V);
            return {
                protocols: webidl.converters['DOMString or sequence<DOMString>'](V)
            };
        };
        webidl.converters.WebSocketSendData = function(V) {
            if ('Object' === webidl.util.Type(V)) {
                if (isBlobLike(V)) return webidl.converters.Blob(V, {
                    strict: false
                });
                if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) return webidl.converters.BufferSource(V);
            }
            return webidl.converters.USVString(V);
        };
        function onParserDrain() {
            this.ws[kResponse].socket.resume();
        }
        function onParserError(err) {
            let message;
            let code;
            if (err instanceof CloseEvent) {
                message = err.reason;
                code = err.code;
            } else message = err.message;
            fireEvent('error', this, ()=>new ErrorEvent('error', {
                    error: err,
                    message
                }));
            closeWebSocketConnection(this, code);
        }
        module.exports = {
            WebSocket
        };
    },
    "../../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js" (module, __unused_rspack_exports, __webpack_require__) {
        const isWindows = 'win32' === process.platform || 'cygwin' === process.env.OSTYPE || 'msys' === process.env.OSTYPE;
        const path = __webpack_require__("path");
        const COLON = isWindows ? ';' : ':';
        const isexe = __webpack_require__("../../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js");
        const getNotFoundError = (cmd)=>Object.assign(new Error(`not found: ${cmd}`), {
                code: 'ENOENT'
            });
        const getPathInfo = (cmd, opt)=>{
            const colon = opt.colon || COLON;
            const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [
                ''
            ] : [
                ...isWindows ? [
                    process.cwd()
                ] : [],
                ...(opt.path || process.env.PATH || '').split(colon)
            ];
            const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM' : '';
            const pathExt = isWindows ? pathExtExe.split(colon) : [
                ''
            ];
            if (isWindows) {
                if (-1 !== cmd.indexOf('.') && '' !== pathExt[0]) pathExt.unshift('');
            }
            return {
                pathEnv,
                pathExt,
                pathExtExe
            };
        };
        const which = (cmd, opt, cb)=>{
            if ('function' == typeof opt) {
                cb = opt;
                opt = {};
            }
            if (!opt) opt = {};
            const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
            const found = [];
            const step = (i)=>new Promise((resolve, reject)=>{
                    if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
                    const ppRaw = pathEnv[i];
                    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
                    const pCmd = path.join(pathPart, cmd);
                    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
                    resolve(subStep(p, i, 0));
                });
            const subStep = (p, i, ii)=>new Promise((resolve, reject)=>{
                    if (ii === pathExt.length) return resolve(step(i + 1));
                    const ext = pathExt[ii];
                    isexe(p + ext, {
                        pathExt: pathExtExe
                    }, (er, is)=>{
                        if (!er && is) if (!opt.all) return resolve(p + ext);
                        else found.push(p + ext);
                        return resolve(subStep(p, i, ii + 1));
                    });
                });
            return cb ? step(0).then((res)=>cb(null, res), cb) : step(0);
        };
        const whichSync = (cmd, opt)=>{
            opt = opt || {};
            const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
            const found = [];
            for(let i = 0; i < pathEnv.length; i++){
                const ppRaw = pathEnv[i];
                const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
                const pCmd = path.join(pathPart, cmd);
                const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
                for(let j = 0; j < pathExt.length; j++){
                    const cur = p + pathExt[j];
                    try {
                        const is = isexe.sync(cur, {
                            pathExt: pathExtExe
                        });
                        if (is) if (!opt.all) return cur;
                        else found.push(cur);
                    } catch (ex) {}
                }
            }
            if (opt.all && found.length) return found;
            if (opt.nothrow) return null;
            throw getNotFoundError(cmd);
        };
        module.exports = which;
        which.sync = whichSync;
    },
    assert (module) {
        "use strict";
        module.exports = require("assert");
    },
    child_process (module) {
        "use strict";
        module.exports = require("child_process");
    },
    events (module) {
        "use strict";
        module.exports = require("events");
    },
    fs (module) {
        "use strict";
        module.exports = require("fs");
    },
    http (module) {
        "use strict";
        module.exports = require("http");
    },
    https (module) {
        "use strict";
        module.exports = require("https");
    },
    net (module) {
        "use strict";
        module.exports = require("net");
    },
    "node:assert" (module) {
        "use strict";
        module.exports = require("node:assert");
    },
    "node:async_hooks" (module) {
        "use strict";
        module.exports = require("node:async_hooks");
    },
    "node:buffer" (module) {
        "use strict";
        module.exports = require("node:buffer");
    },
    "node:console" (module) {
        "use strict";
        module.exports = require("node:console");
    },
    "node:crypto" (module) {
        "use strict";
        module.exports = require("node:crypto");
    },
    "node:diagnostics_channel" (module) {
        "use strict";
        module.exports = require("node:diagnostics_channel");
    },
    "node:dns" (module) {
        "use strict";
        module.exports = require("node:dns");
    },
    "node:events" (module) {
        "use strict";
        module.exports = require("node:events");
    },
    "node:http" (module) {
        "use strict";
        module.exports = require("node:http");
    },
    "node:http2" (module) {
        "use strict";
        module.exports = require("node:http2");
    },
    "node:net" (module) {
        "use strict";
        module.exports = require("node:net");
    },
    "node:perf_hooks" (module) {
        "use strict";
        module.exports = require("node:perf_hooks");
    },
    "node:querystring" (module) {
        "use strict";
        module.exports = require("node:querystring");
    },
    "node:stream" (module) {
        "use strict";
        module.exports = require("node:stream");
    },
    "node:tls" (module) {
        "use strict";
        module.exports = require("node:tls");
    },
    "node:url" (module) {
        "use strict";
        module.exports = require("node:url");
    },
    "node:util" (module) {
        "use strict";
        module.exports = require("node:util");
    },
    "node:util/types" (module) {
        "use strict";
        module.exports = require("node:util/types");
    },
    "node:worker_threads" (module) {
        "use strict";
        module.exports = require("node:worker_threads");
    },
    "node:zlib" (module) {
        "use strict";
        module.exports = require("node:zlib");
    },
    path (module) {
        "use strict";
        module.exports = require("path");
    },
    string_decoder (module) {
        "use strict";
        module.exports = require("string_decoder");
    },
    tls (module) {
        "use strict";
        module.exports = require("tls");
    },
    util (module) {
        "use strict";
        module.exports = require("util");
    }
};
var __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
        exports: {}
    };
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    return module.exports;
}
var __webpack_exports__ = {};
(()=>{
    "use strict";
    const promises_namespaceObject = require("node:fs/promises");
    const external_os_namespaceObject = require("os");
    function utils_toCommandValue(input) {
        if (null == input) return '';
        if ('string' == typeof input || input instanceof String) return input;
        return JSON.stringify(input);
    }
    function utils_toCommandProperties(annotationProperties) {
        if (!Object.keys(annotationProperties).length) return {};
        return {
            title: annotationProperties.title,
            file: annotationProperties.file,
            line: annotationProperties.startLine,
            endLine: annotationProperties.endLine,
            col: annotationProperties.startColumn,
            endColumn: annotationProperties.endColumn
        };
    }
    function command_issueCommand(command, properties, message) {
        const cmd = new Command(command, properties, message);
        process.stdout.write(cmd.toString() + external_os_namespaceObject.EOL);
    }
    const CMD_STRING = '::';
    class Command {
        constructor(command, properties, message){
            if (!command) command = 'missing.command';
            this.command = command;
            this.properties = properties;
            this.message = message;
        }
        toString() {
            let cmdStr = CMD_STRING + this.command;
            if (this.properties && Object.keys(this.properties).length > 0) {
                cmdStr += ' ';
                let first = true;
                for(const key in this.properties)if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) first = false;
                        else cmdStr += ',';
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
            cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
            return cmdStr;
        }
    }
    function escapeData(s) {
        return utils_toCommandValue(s).replace(/%/g, '%25').replace(/\r/g, '%0D').replace(/\n/g, '%0A');
    }
    function escapeProperty(s) {
        return utils_toCommandValue(s).replace(/%/g, '%25').replace(/\r/g, '%0D').replace(/\n/g, '%0A').replace(/:/g, '%3A').replace(/,/g, '%2C');
    }
    const external_crypto_namespaceObject = require("crypto");
    var external_fs_ = __webpack_require__("fs");
    function file_command_issueFileCommand(command, message) {
        const filePath = process.env[`GITHUB_${command}`];
        if (!filePath) throw new Error(`Unable to find environment variable for file command ${command}`);
        if (!external_fs_.existsSync(filePath)) throw new Error(`Missing file at path: ${filePath}`);
        external_fs_.appendFileSync(filePath, `${utils_toCommandValue(message)}${external_os_namespaceObject.EOL}`, {
            encoding: 'utf8'
        });
    }
    function file_command_prepareKeyValueMessage(key, value) {
        const delimiter = `ghadelimiter_${external_crypto_namespaceObject.randomUUID()}`;
        const convertedValue = utils_toCommandValue(value);
        if (key.includes(delimiter)) throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
        if (convertedValue.includes(delimiter)) throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
        return `${key}<<${delimiter}${external_os_namespaceObject.EOL}${convertedValue}${external_os_namespaceObject.EOL}${delimiter}`;
    }
    __webpack_require__("path");
    __webpack_require__("http");
    __webpack_require__("https");
    URL;
    __webpack_require__("../../../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js");
    __webpack_require__("../../../node_modules/.pnpm/undici@6.23.0/node_modules/undici/index.js");
    var lib_HttpCodes;
    (function(HttpCodes) {
        HttpCodes[HttpCodes["OK"] = 200] = "OK";
        HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
        HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
        HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
        HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
        HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
        HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
        HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
        HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
        HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
        HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
        HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
        HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
        HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
        HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
        HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
        HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
        HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
        HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
        HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
        HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
        HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
        HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
        HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
        HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
        HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
        HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
    })(lib_HttpCodes || (lib_HttpCodes = {}));
    var lib_Headers;
    (function(Headers) {
        Headers["Accept"] = "accept";
        Headers["ContentType"] = "content-type";
    })(lib_Headers || (lib_Headers = {}));
    var lib_MediaTypes;
    (function(MediaTypes) {
        MediaTypes["ApplicationJson"] = "application/json";
    })(lib_MediaTypes || (lib_MediaTypes = {}));
    lib_HttpCodes.MovedPermanently, lib_HttpCodes.ResourceMoved, lib_HttpCodes.SeeOther, lib_HttpCodes.TemporaryRedirect, lib_HttpCodes.PermanentRedirect;
    lib_HttpCodes.BadGateway, lib_HttpCodes.ServiceUnavailable, lib_HttpCodes.GatewayTimeout;
    var summary_awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
                resolve(value);
            });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    const { access, appendFile, writeFile } = external_fs_.promises;
    const SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
    class Summary {
        constructor(){
            this._buffer = '';
        }
        filePath() {
            return summary_awaiter(this, void 0, void 0, function*() {
                if (this._filePath) return this._filePath;
                const pathFromEnv = process.env[SUMMARY_ENV_VAR];
                if (!pathFromEnv) throw new Error(`Unable to find environment variable for $${SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
                try {
                    yield access(pathFromEnv, external_fs_.constants.R_OK | external_fs_.constants.W_OK);
                } catch (_a) {
                    throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
                }
                this._filePath = pathFromEnv;
                return this._filePath;
            });
        }
        wrap(tag, content, attrs = {}) {
            const htmlAttrs = Object.entries(attrs).map(([key, value])=>` ${key}="${value}"`).join('');
            if (!content) return `<${tag}${htmlAttrs}>`;
            return `<${tag}${htmlAttrs}>${content}</${tag}>`;
        }
        write(options) {
            return summary_awaiter(this, void 0, void 0, function*() {
                const overwrite = !!(null == options ? void 0 : options.overwrite);
                const filePath = yield this.filePath();
                const writeFunc = overwrite ? writeFile : appendFile;
                yield writeFunc(filePath, this._buffer, {
                    encoding: 'utf8'
                });
                return this.emptyBuffer();
            });
        }
        clear() {
            return summary_awaiter(this, void 0, void 0, function*() {
                return this.emptyBuffer().write({
                    overwrite: true
                });
            });
        }
        stringify() {
            return this._buffer;
        }
        isEmptyBuffer() {
            return 0 === this._buffer.length;
        }
        emptyBuffer() {
            this._buffer = '';
            return this;
        }
        addRaw(text, addEOL = false) {
            this._buffer += text;
            return addEOL ? this.addEOL() : this;
        }
        addEOL() {
            return this.addRaw(external_os_namespaceObject.EOL);
        }
        addCodeBlock(code, lang) {
            const attrs = Object.assign({}, lang && {
                lang
            });
            const element = this.wrap('pre', this.wrap('code', code), attrs);
            return this.addRaw(element).addEOL();
        }
        addList(items, ordered = false) {
            const tag = ordered ? 'ol' : 'ul';
            const listItems = items.map((item)=>this.wrap('li', item)).join('');
            const element = this.wrap(tag, listItems);
            return this.addRaw(element).addEOL();
        }
        addTable(rows) {
            const tableBody = rows.map((row)=>{
                const cells = row.map((cell)=>{
                    if ('string' == typeof cell) return this.wrap('td', cell);
                    const { header, data, colspan, rowspan } = cell;
                    const tag = header ? 'th' : 'td';
                    const attrs = Object.assign(Object.assign({}, colspan && {
                        colspan
                    }), rowspan && {
                        rowspan
                    });
                    return this.wrap(tag, data, attrs);
                }).join('');
                return this.wrap('tr', cells);
            }).join('');
            const element = this.wrap('table', tableBody);
            return this.addRaw(element).addEOL();
        }
        addDetails(label, content) {
            const element = this.wrap('details', this.wrap('summary', label) + content);
            return this.addRaw(element).addEOL();
        }
        addImage(src, alt, options) {
            const { width, height } = options || {};
            const attrs = Object.assign(Object.assign({}, width && {
                width
            }), height && {
                height
            });
            const element = this.wrap('img', null, Object.assign({
                src,
                alt
            }, attrs));
            return this.addRaw(element).addEOL();
        }
        addHeading(text, level) {
            const tag = `h${level}`;
            const allowedTag = [
                'h1',
                'h2',
                'h3',
                'h4',
                'h5',
                'h6'
            ].includes(tag) ? tag : 'h1';
            const element = this.wrap(allowedTag, text);
            return this.addRaw(element).addEOL();
        }
        addSeparator() {
            const element = this.wrap('hr', null);
            return this.addRaw(element).addEOL();
        }
        addBreak() {
            const element = this.wrap('br', null);
            return this.addRaw(element).addEOL();
        }
        addQuote(text, cite) {
            const attrs = Object.assign({}, cite && {
                cite
            });
            const element = this.wrap('blockquote', text, attrs);
            return this.addRaw(element).addEOL();
        }
        addLink(text, href) {
            const element = this.wrap('a', text, {
                href
            });
            return this.addRaw(element).addEOL();
        }
    }
    new Summary();
    __webpack_require__("string_decoder");
    var external_events_ = __webpack_require__("events");
    __webpack_require__("child_process");
    __webpack_require__("assert");
    const { chmod, copyFile, lstat, mkdir, open: io_util_open, readdir, rename, rm, rmdir, stat, symlink, unlink } = external_fs_.promises;
    process.platform;
    external_fs_.constants.O_RDONLY;
    const external_timers_namespaceObject = require("timers");
    process.platform;
    external_events_.EventEmitter;
    class ExecState extends external_events_.EventEmitter {
        constructor(options, toolPath){
            super();
            this.processClosed = false;
            this.processError = '';
            this.processExitCode = 0;
            this.processExited = false;
            this.processStderr = false;
            this.delay = 10000;
            this.done = false;
            this.timeout = null;
            if (!toolPath) throw new Error('toolPath must not be empty');
            this.options = options;
            this.toolPath = toolPath;
            if (options.delay) this.delay = options.delay;
        }
        CheckComplete() {
            if (this.done) return;
            if (this.processClosed) this._setResult();
            else if (this.processExited) this.timeout = (0, external_timers_namespaceObject.setTimeout)(ExecState.HandleTimeout, this.delay, this);
        }
        _debug(message) {
            this.emit('debug', message);
        }
        _setResult() {
            let error;
            if (this.processExited) if (this.processError) error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
            else if (0 === this.processExitCode || this.options.ignoreReturnCode) {
                if (this.processStderr && this.options.failOnStdErr) error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
            } else error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
            if (this.timeout) {
                clearTimeout(this.timeout);
                this.timeout = null;
            }
            this.done = true;
            this.emit('done', error, this.processExitCode);
        }
        static HandleTimeout(state) {
            if (state.done) return;
            if (!state.processClosed && state.processExited) {
                const message = `The STDIO streams did not close within ${state.delay / 1000} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
                state._debug(message);
            }
            state._setResult();
        }
    }
    external_os_namespaceObject.platform();
    external_os_namespaceObject.arch();
    var core_ExitCode;
    (function(ExitCode) {
        ExitCode[ExitCode["Success"] = 0] = "Success";
        ExitCode[ExitCode["Failure"] = 1] = "Failure";
    })(core_ExitCode || (core_ExitCode = {}));
    function getInput(name, options) {
        const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
        if (options && options.required && !val) throw new Error(`Input required and not supplied: ${name}`);
        if (options && false === options.trimWhitespace) return val;
        return val.trim();
    }
    function setOutput(name, value) {
        const filePath = process.env['GITHUB_OUTPUT'] || '';
        if (filePath) return file_command_issueFileCommand('OUTPUT', file_command_prepareKeyValueMessage(name, value));
        process.stdout.write(external_os_namespaceObject.EOL);
        command_issueCommand('set-output', {
            name
        }, utils_toCommandValue(value));
    }
    function setFailed(message) {
        process.exitCode = core_ExitCode.Failure;
        core_error(message);
    }
    function core_error(message, properties = {}) {
        command_issueCommand('error', utils_toCommandProperties(properties), message instanceof Error ? message.toString() : message);
    }
    function core_info(message) {
        process.stdout.write(message + external_os_namespaceObject.EOL);
    }
    function isPlainObject(value) {
        if ('object' != typeof value || null === value) return false;
        const prototype = Object.getPrototypeOf(value);
        return (null === prototype || prototype === Object.prototype || null === Object.getPrototypeOf(prototype)) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
    }
    var external_node_url_ = __webpack_require__("node:url");
    const safeNormalizeFileUrl = (file, name)=>{
        const fileString = normalizeFileUrl(normalizeDenoExecPath(file));
        if ('string' != typeof fileString) throw new TypeError(`${name} must be a string or a file URL: ${fileString}.`);
        return fileString;
    };
    const normalizeDenoExecPath = (file)=>isDenoExecPath(file) ? file.toString() : file;
    const isDenoExecPath = (file)=>'string' != typeof file && file && Object.getPrototypeOf(file) === String.prototype;
    const normalizeFileUrl = (file)=>file instanceof URL ? (0, external_node_url_.fileURLToPath)(file) : file;
    const normalizeParameters = (rawFile, rawArguments = [], rawOptions = {})=>{
        const filePath = safeNormalizeFileUrl(rawFile, 'First argument');
        const [commandArguments, options] = isPlainObject(rawArguments) ? [
            [],
            rawArguments
        ] : [
            rawArguments,
            rawOptions
        ];
        if (!Array.isArray(commandArguments)) throw new TypeError(`Second argument must be either an array of arguments or an options object: ${commandArguments}`);
        if (commandArguments.some((commandArgument)=>'object' == typeof commandArgument && null !== commandArgument)) throw new TypeError(`Second argument must be an array of strings: ${commandArguments}`);
        const normalizedArguments = commandArguments.map(String);
        const nullByteArgument = normalizedArguments.find((normalizedArgument)=>normalizedArgument.includes('\0'));
        if (void 0 !== nullByteArgument) throw new TypeError(`Arguments cannot contain null bytes ("\\0"): ${nullByteArgument}`);
        if (!isPlainObject(options)) throw new TypeError(`Last argument must be an options object: ${options}`);
        return [
            filePath,
            normalizedArguments,
            options
        ];
    };
    const external_node_child_process_namespaceObject = require("node:child_process");
    const external_node_string_decoder_namespaceObject = require("node:string_decoder");
    const { toString: objectToString } = Object.prototype;
    const isArrayBuffer = (value)=>'[object ArrayBuffer]' === objectToString.call(value);
    const isUint8Array = (value)=>'[object Uint8Array]' === objectToString.call(value);
    const bufferToUint8Array = (buffer)=>new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    const uint_array_textEncoder = new TextEncoder();
    const stringToUint8Array = (string)=>uint_array_textEncoder.encode(string);
    const uint_array_textDecoder = new TextDecoder();
    const uint8ArrayToString = (uint8Array)=>uint_array_textDecoder.decode(uint8Array);
    const joinToString = (uint8ArraysOrStrings, encoding)=>{
        const strings = uint8ArraysToStrings(uint8ArraysOrStrings, encoding);
        return strings.join('');
    };
    const uint8ArraysToStrings = (uint8ArraysOrStrings, encoding)=>{
        if ('utf8' === encoding && uint8ArraysOrStrings.every((uint8ArrayOrString)=>'string' == typeof uint8ArrayOrString)) return uint8ArraysOrStrings;
        const decoder = new external_node_string_decoder_namespaceObject.StringDecoder(encoding);
        const strings = uint8ArraysOrStrings.map((uint8ArrayOrString)=>'string' == typeof uint8ArrayOrString ? stringToUint8Array(uint8ArrayOrString) : uint8ArrayOrString).map((uint8Array)=>decoder.write(uint8Array));
        const finalString = decoder.end();
        return '' === finalString ? strings : [
            ...strings,
            finalString
        ];
    };
    const joinToUint8Array = (uint8ArraysOrStrings)=>{
        if (1 === uint8ArraysOrStrings.length && isUint8Array(uint8ArraysOrStrings[0])) return uint8ArraysOrStrings[0];
        return concatUint8Arrays(stringsToUint8Arrays(uint8ArraysOrStrings));
    };
    const stringsToUint8Arrays = (uint8ArraysOrStrings)=>uint8ArraysOrStrings.map((uint8ArrayOrString)=>'string' == typeof uint8ArrayOrString ? stringToUint8Array(uint8ArrayOrString) : uint8ArrayOrString);
    const concatUint8Arrays = (uint8Arrays)=>{
        const result = new Uint8Array(getJoinLength(uint8Arrays));
        let index = 0;
        for (const uint8Array of uint8Arrays){
            result.set(uint8Array, index);
            index += uint8Array.length;
        }
        return result;
    };
    const getJoinLength = (uint8Arrays)=>{
        let joinLength = 0;
        for (const uint8Array of uint8Arrays)joinLength += uint8Array.length;
        return joinLength;
    };
    const isTemplateString = (templates)=>Array.isArray(templates) && Array.isArray(templates.raw);
    const parseTemplates = (templates, expressions)=>{
        let tokens = [];
        for (const [index, template] of templates.entries())tokens = parseTemplate({
            templates,
            expressions,
            tokens,
            index,
            template
        });
        if (0 === tokens.length) throw new TypeError("Template script must not be empty");
        const [file, ...commandArguments] = tokens;
        return [
            file,
            commandArguments,
            {}
        ];
    };
    const parseTemplate = ({ templates, expressions, tokens, index, template })=>{
        if (void 0 === template) throw new TypeError(`Invalid backslash sequence: ${templates.raw[index]}`);
        const { nextTokens, leadingWhitespaces, trailingWhitespaces } = splitByWhitespaces(template, templates.raw[index]);
        const newTokens = concatTokens(tokens, nextTokens, leadingWhitespaces);
        if (index === expressions.length) return newTokens;
        const expression = expressions[index];
        const expressionTokens = Array.isArray(expression) ? expression.map((expression)=>parseExpression(expression)) : [
            parseExpression(expression)
        ];
        return concatTokens(newTokens, expressionTokens, trailingWhitespaces);
    };
    const splitByWhitespaces = (template, rawTemplate)=>{
        if (0 === rawTemplate.length) return {
            nextTokens: [],
            leadingWhitespaces: false,
            trailingWhitespaces: false
        };
        const nextTokens = [];
        let templateStart = 0;
        const leadingWhitespaces = DELIMITERS.has(rawTemplate[0]);
        for(let templateIndex = 0, rawIndex = 0; templateIndex < template.length; templateIndex += 1, rawIndex += 1){
            const rawCharacter = rawTemplate[rawIndex];
            if (DELIMITERS.has(rawCharacter)) {
                if (templateStart !== templateIndex) nextTokens.push(template.slice(templateStart, templateIndex));
                templateStart = templateIndex + 1;
            } else if ('\\' === rawCharacter) {
                const nextRawCharacter = rawTemplate[rawIndex + 1];
                if ('\n' === nextRawCharacter) {
                    templateIndex -= 1;
                    rawIndex += 1;
                } else if ('u' === nextRawCharacter && '{' === rawTemplate[rawIndex + 2]) rawIndex = rawTemplate.indexOf('}', rawIndex + 3);
                else rawIndex += ESCAPE_LENGTH[nextRawCharacter] ?? 1;
            }
        }
        const trailingWhitespaces = templateStart === template.length;
        if (!trailingWhitespaces) nextTokens.push(template.slice(templateStart));
        return {
            nextTokens,
            leadingWhitespaces,
            trailingWhitespaces
        };
    };
    const DELIMITERS = new Set([
        ' ',
        '\t',
        '\r',
        '\n'
    ]);
    const ESCAPE_LENGTH = {
        x: 3,
        u: 5
    };
    const concatTokens = (tokens, nextTokens, isSeparated)=>isSeparated || 0 === tokens.length || 0 === nextTokens.length ? [
            ...tokens,
            ...nextTokens
        ] : [
            ...tokens.slice(0, -1),
            `${tokens.at(-1)}${nextTokens[0]}`,
            ...nextTokens.slice(1)
        ];
    const parseExpression = (expression)=>{
        const typeOfExpression = typeof expression;
        if ('string' === typeOfExpression) return expression;
        if ('number' === typeOfExpression) return String(expression);
        if (isPlainObject(expression) && ('stdout' in expression || 'isMaxBuffer' in expression)) return getSubprocessResult(expression);
        if (expression instanceof external_node_child_process_namespaceObject.ChildProcess || '[object Promise]' === Object.prototype.toString.call(expression)) throw new TypeError('Unexpected subprocess in template expression. Please use ${await subprocess} instead of ${subprocess}.');
        throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
    };
    const getSubprocessResult = ({ stdout })=>{
        if ('string' == typeof stdout) return stdout;
        if (isUint8Array(stdout)) return uint8ArrayToString(stdout);
        if (void 0 === stdout) throw new TypeError('Missing result.stdout in template expression. This is probably due to the previous subprocess\' "stdout" option.');
        throw new TypeError(`Unexpected "${typeof stdout}" stdout in template expression`);
    };
    var external_node_util_ = __webpack_require__("node:util");
    const external_node_process_namespaceObject = require("node:process");
    const isStandardStream = (stream)=>STANDARD_STREAMS.includes(stream);
    const STANDARD_STREAMS = [
        external_node_process_namespaceObject.stdin,
        external_node_process_namespaceObject.stdout,
        external_node_process_namespaceObject.stderr
    ];
    const STANDARD_STREAMS_ALIASES = [
        'stdin',
        'stdout',
        'stderr'
    ];
    const getStreamName = (fdNumber)=>STANDARD_STREAMS_ALIASES[fdNumber] ?? `stdio[${fdNumber}]`;
    const normalizeFdSpecificOptions = (options)=>{
        const optionsCopy = {
            ...options
        };
        for (const optionName of FD_SPECIFIC_OPTIONS)optionsCopy[optionName] = normalizeFdSpecificOption(options, optionName);
        return optionsCopy;
    };
    const normalizeFdSpecificOption = (options, optionName)=>{
        const optionBaseArray = Array.from({
            length: getStdioLength(options) + 1
        });
        const optionArray = normalizeFdSpecificValue(options[optionName], optionBaseArray, optionName);
        return addDefaultValue(optionArray, optionName);
    };
    const getStdioLength = ({ stdio })=>Array.isArray(stdio) ? Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length) : STANDARD_STREAMS_ALIASES.length;
    const normalizeFdSpecificValue = (optionValue, optionArray, optionName)=>isPlainObject(optionValue) ? normalizeOptionObject(optionValue, optionArray, optionName) : optionArray.fill(optionValue);
    const normalizeOptionObject = (optionValue, optionArray, optionName)=>{
        for (const fdName of Object.keys(optionValue).sort(compareFdName))for (const fdNumber of parseFdName(fdName, optionName, optionArray))optionArray[fdNumber] = optionValue[fdName];
        return optionArray;
    };
    const compareFdName = (fdNameA, fdNameB)=>getFdNameOrder(fdNameA) < getFdNameOrder(fdNameB) ? 1 : -1;
    const getFdNameOrder = (fdName)=>{
        if ('stdout' === fdName || 'stderr' === fdName) return 0;
        return 'all' === fdName ? 2 : 1;
    };
    const parseFdName = (fdName, optionName, optionArray)=>{
        if ('ipc' === fdName) return [
            optionArray.length - 1
        ];
        const fdNumber = parseFd(fdName);
        if (void 0 === fdNumber || 0 === fdNumber) throw new TypeError(`"${optionName}.${fdName}" is invalid.
It must be "${optionName}.stdout", "${optionName}.stderr", "${optionName}.all", "${optionName}.ipc", or "${optionName}.fd3", "${optionName}.fd4" (and so on).`);
        if (fdNumber >= optionArray.length) throw new TypeError(`"${optionName}.${fdName}" is invalid: that file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);
        return 'all' === fdNumber ? [
            1,
            2
        ] : [
            fdNumber
        ];
    };
    const parseFd = (fdName)=>{
        if ('all' === fdName) return fdName;
        if (STANDARD_STREAMS_ALIASES.includes(fdName)) return STANDARD_STREAMS_ALIASES.indexOf(fdName);
        const regexpResult = FD_REGEXP.exec(fdName);
        if (null !== regexpResult) return Number(regexpResult[1]);
    };
    const FD_REGEXP = /^fd(\d+)$/;
    const addDefaultValue = (optionArray, optionName)=>optionArray.map((optionValue)=>void 0 === optionValue ? DEFAULT_OPTIONS[optionName] : optionValue);
    const verboseDefault = (0, external_node_util_.debuglog)('execa').enabled ? 'full' : 'none';
    const DEFAULT_OPTIONS = {
        lines: false,
        buffer: true,
        maxBuffer: 100000000,
        verbose: verboseDefault,
        stripFinalNewline: true
    };
    const FD_SPECIFIC_OPTIONS = [
        'lines',
        'buffer',
        'maxBuffer',
        'verbose',
        'stripFinalNewline'
    ];
    const getFdSpecificValue = (optionArray, fdNumber)=>'ipc' === fdNumber ? optionArray.at(-1) : optionArray[fdNumber];
    const values_isVerbose = ({ verbose }, fdNumber)=>'none' !== getFdVerbose(verbose, fdNumber);
    const isFullVerbose = ({ verbose }, fdNumber)=>![
            'none',
            'short'
        ].includes(getFdVerbose(verbose, fdNumber));
    const getVerboseFunction = ({ verbose }, fdNumber)=>{
        const fdVerbose = getFdVerbose(verbose, fdNumber);
        return isVerboseFunction(fdVerbose) ? fdVerbose : void 0;
    };
    const getFdVerbose = (verbose, fdNumber)=>void 0 === fdNumber ? getFdGenericVerbose(verbose) : getFdSpecificValue(verbose, fdNumber);
    const getFdGenericVerbose = (verbose)=>verbose.find((fdVerbose)=>isVerboseFunction(fdVerbose)) ?? VERBOSE_VALUES.findLast((fdVerbose)=>verbose.includes(fdVerbose));
    const isVerboseFunction = (fdVerbose)=>'function' == typeof fdVerbose;
    const VERBOSE_VALUES = [
        'none',
        'short',
        'full'
    ];
    const joinCommand = (filePath, rawArguments)=>{
        const fileAndArguments = [
            filePath,
            ...rawArguments
        ];
        const command = fileAndArguments.join(' ');
        const escapedCommand = fileAndArguments.map((fileAndArgument)=>quoteString(escapeControlCharacters(fileAndArgument))).join(' ');
        return {
            command,
            escapedCommand
        };
    };
    const escapeLines = (lines)=>(0, external_node_util_.stripVTControlCharacters)(lines).split('\n').map((line)=>escapeControlCharacters(line)).join('\n');
    const escapeControlCharacters = (line)=>line.replaceAll(SPECIAL_CHAR_REGEXP, (character)=>escapeControlCharacter(character));
    const escapeControlCharacter = (character)=>{
        const commonEscape = COMMON_ESCAPES[character];
        if (void 0 !== commonEscape) return commonEscape;
        const codepoint = character.codePointAt(0);
        const codepointHex = codepoint.toString(16);
        return codepoint <= ASTRAL_START ? `\\u${codepointHex.padStart(4, '0')}` : `\\U${codepointHex}`;
    };
    const getSpecialCharRegExp = ()=>{
        try {
            return new RegExp('\\p{Separator}|\\p{Other}', 'gu');
        } catch  {
            return /[\s\u0000-\u001F\u007F-\u009F\u00AD]/g;
        }
    };
    const SPECIAL_CHAR_REGEXP = getSpecialCharRegExp();
    const COMMON_ESCAPES = {
        ' ': ' ',
        '\b': '\\b',
        '\f': '\\f',
        '\n': '\\n',
        '\r': '\\r',
        '\t': '\\t'
    };
    const ASTRAL_START = 65535;
    const quoteString = (escapedArgument)=>{
        if (NO_ESCAPE_REGEXP.test(escapedArgument)) return escapedArgument;
        return 'win32' === external_node_process_namespaceObject.platform ? `"${escapedArgument.replaceAll('"', '""')}"` : `'${escapedArgument.replaceAll('\'', '\'\\\'\'')}'`;
    };
    const NO_ESCAPE_REGEXP = /^[\w./-]+$/;
    function isUnicodeSupported() {
        const { env } = external_node_process_namespaceObject;
        const { TERM, TERM_PROGRAM } = env;
        if ('win32' !== external_node_process_namespaceObject.platform) return 'linux' !== TERM;
        return Boolean(env.WT_SESSION) || Boolean(env.TERMINUS_SUBLIME) || '{cmd::Cmder}' === env.ConEmuTask || 'Terminus-Sublime' === TERM_PROGRAM || 'vscode' === TERM_PROGRAM || 'xterm-256color' === TERM || 'alacritty' === TERM || 'rxvt-unicode' === TERM || 'rxvt-unicode-256color' === TERM || 'JetBrains-JediTerm' === env.TERMINAL_EMULATOR;
    }
    const common = {
        circleQuestionMark: '(?)',
        questionMarkPrefix: '(?)',
        square: '',
        squareDarkShade: '',
        squareMediumShade: '',
        squareLightShade: '',
        squareTop: '',
        squareBottom: '',
        squareLeft: '',
        squareRight: '',
        squareCenter: '',
        bullet: '',
        dot: '',
        ellipsis: '',
        pointerSmall: '',
        triangleUp: '',
        triangleUpSmall: '',
        triangleDown: '',
        triangleDownSmall: '',
        triangleLeftSmall: '',
        triangleRightSmall: '',
        home: '',
        heart: '',
        musicNote: '',
        musicNoteBeamed: '',
        arrowUp: '',
        arrowDown: '',
        arrowLeft: '',
        arrowRight: '',
        arrowLeftRight: '',
        arrowUpDown: '',
        almostEqual: '',
        notEqual: '',
        lessOrEqual: '',
        greaterOrEqual: '',
        identical: '',
        infinity: '',
        subscriptZero: '',
        subscriptOne: '',
        subscriptTwo: '',
        subscriptThree: '',
        subscriptFour: '',
        subscriptFive: '',
        subscriptSix: '',
        subscriptSeven: '',
        subscriptEight: '',
        subscriptNine: '',
        oneHalf: '',
        oneThird: '',
        oneQuarter: '',
        oneFifth: '',
        oneSixth: '',
        oneEighth: '',
        twoThirds: '',
        twoFifths: '',
        threeQuarters: '',
        threeFifths: '',
        threeEighths: '',
        fourFifths: '',
        fiveSixths: '',
        fiveEighths: '',
        sevenEighths: '',
        line: '',
        lineBold: '',
        lineDouble: '',
        lineDashed0: '',
        lineDashed1: '',
        lineDashed2: '',
        lineDashed3: '',
        lineDashed4: '',
        lineDashed5: '',
        lineDashed6: '',
        lineDashed7: '',
        lineDashed8: '',
        lineDashed9: '',
        lineDashed10: '',
        lineDashed11: '',
        lineDashed12: '',
        lineDashed13: '',
        lineDashed14: '',
        lineDashed15: '',
        lineVertical: '',
        lineVerticalBold: '',
        lineVerticalDouble: '',
        lineVerticalDashed0: '',
        lineVerticalDashed1: '',
        lineVerticalDashed2: '',
        lineVerticalDashed3: '',
        lineVerticalDashed4: '',
        lineVerticalDashed5: '',
        lineVerticalDashed6: '',
        lineVerticalDashed7: '',
        lineVerticalDashed8: '',
        lineVerticalDashed9: '',
        lineVerticalDashed10: '',
        lineVerticalDashed11: '',
        lineDownLeft: '',
        lineDownLeftArc: '',
        lineDownBoldLeftBold: '',
        lineDownBoldLeft: '',
        lineDownLeftBold: '',
        lineDownDoubleLeftDouble: '',
        lineDownDoubleLeft: '',
        lineDownLeftDouble: '',
        lineDownRight: '',
        lineDownRightArc: '',
        lineDownBoldRightBold: '',
        lineDownBoldRight: '',
        lineDownRightBold: '',
        lineDownDoubleRightDouble: '',
        lineDownDoubleRight: '',
        lineDownRightDouble: '',
        lineUpLeft: '',
        lineUpLeftArc: '',
        lineUpBoldLeftBold: '',
        lineUpBoldLeft: '',
        lineUpLeftBold: '',
        lineUpDoubleLeftDouble: '',
        lineUpDoubleLeft: '',
        lineUpLeftDouble: '',
        lineUpRight: '',
        lineUpRightArc: '',
        lineUpBoldRightBold: '',
        lineUpBoldRight: '',
        lineUpRightBold: '',
        lineUpDoubleRightDouble: '',
        lineUpDoubleRight: '',
        lineUpRightDouble: '',
        lineUpDownLeft: '',
        lineUpBoldDownBoldLeftBold: '',
        lineUpBoldDownBoldLeft: '',
        lineUpDownLeftBold: '',
        lineUpBoldDownLeftBold: '',
        lineUpDownBoldLeftBold: '',
        lineUpDownBoldLeft: '',
        lineUpBoldDownLeft: '',
        lineUpDoubleDownDoubleLeftDouble: '',
        lineUpDoubleDownDoubleLeft: '',
        lineUpDownLeftDouble: '',
        lineUpDownRight: '',
        lineUpBoldDownBoldRightBold: '',
        lineUpBoldDownBoldRight: '',
        lineUpDownRightBold: '',
        lineUpBoldDownRightBold: '',
        lineUpDownBoldRightBold: '',
        lineUpDownBoldRight: '',
        lineUpBoldDownRight: '',
        lineUpDoubleDownDoubleRightDouble: '',
        lineUpDoubleDownDoubleRight: '',
        lineUpDownRightDouble: '',
        lineDownLeftRight: '',
        lineDownBoldLeftBoldRightBold: '',
        lineDownLeftBoldRightBold: '',
        lineDownBoldLeftRight: '',
        lineDownBoldLeftBoldRight: '',
        lineDownBoldLeftRightBold: '',
        lineDownLeftRightBold: '',
        lineDownLeftBoldRight: '',
        lineDownDoubleLeftDoubleRightDouble: '',
        lineDownDoubleLeftRight: '',
        lineDownLeftDoubleRightDouble: '',
        lineUpLeftRight: '',
        lineUpBoldLeftBoldRightBold: '',
        lineUpLeftBoldRightBold: '',
        lineUpBoldLeftRight: '',
        lineUpBoldLeftBoldRight: '',
        lineUpBoldLeftRightBold: '',
        lineUpLeftRightBold: '',
        lineUpLeftBoldRight: '',
        lineUpDoubleLeftDoubleRightDouble: '',
        lineUpDoubleLeftRight: '',
        lineUpLeftDoubleRightDouble: '',
        lineUpDownLeftRight: '',
        lineUpBoldDownBoldLeftBoldRightBold: '',
        lineUpDownBoldLeftBoldRightBold: '',
        lineUpBoldDownLeftBoldRightBold: '',
        lineUpBoldDownBoldLeftRightBold: '',
        lineUpBoldDownBoldLeftBoldRight: '',
        lineUpBoldDownLeftRight: '',
        lineUpDownBoldLeftRight: '',
        lineUpDownLeftBoldRight: '',
        lineUpDownLeftRightBold: '',
        lineUpBoldDownBoldLeftRight: '',
        lineUpDownLeftBoldRightBold: '',
        lineUpBoldDownLeftBoldRight: '',
        lineUpBoldDownLeftRightBold: '',
        lineUpDownBoldLeftBoldRight: '',
        lineUpDownBoldLeftRightBold: '',
        lineUpDoubleDownDoubleLeftDoubleRightDouble: '',
        lineUpDoubleDownDoubleLeftRight: '',
        lineUpDownLeftDoubleRightDouble: '',
        lineCross: '',
        lineBackslash: '',
        lineSlash: ''
    };
    const specialMainSymbols = {
        tick: '',
        info: '',
        warning: '',
        cross: '',
        squareSmall: '',
        squareSmallFilled: '',
        circle: '',
        circleFilled: '',
        circleDotted: '',
        circleDouble: '',
        circleCircle: '',
        circleCross: '',
        circlePipe: '',
        radioOn: '',
        radioOff: '',
        checkboxOn: '',
        checkboxOff: '',
        checkboxCircleOn: '',
        checkboxCircleOff: '',
        pointer: '',
        triangleUpOutline: '',
        triangleLeft: '',
        triangleRight: '',
        lozenge: '',
        lozengeOutline: '',
        hamburger: '',
        smiley: '',
        mustache: '',
        star: '',
        play: '',
        nodejs: '',
        oneSeventh: '',
        oneNinth: '',
        oneTenth: ''
    };
    const specialFallbackSymbols = {
        tick: '',
        info: 'i',
        warning: '',
        cross: '',
        squareSmall: '',
        squareSmallFilled: '',
        circle: '( )',
        circleFilled: '(*)',
        circleDotted: '( )',
        circleDouble: '( )',
        circleCircle: '()',
        circleCross: '()',
        circlePipe: '()',
        radioOn: '(*)',
        radioOff: '( )',
        checkboxOn: '[]',
        checkboxOff: '[ ]',
        checkboxCircleOn: '()',
        checkboxCircleOff: '( )',
        pointer: '>',
        triangleUpOutline: '',
        triangleLeft: '',
        triangleRight: '',
        lozenge: '',
        lozengeOutline: '',
        hamburger: '',
        smiley: '',
        mustache: '',
        star: '',
        play: '',
        nodejs: '',
        oneSeventh: '1/7',
        oneNinth: '1/9',
        oneTenth: '1/10'
    };
    const mainSymbols = {
        ...common,
        ...specialMainSymbols
    };
    const fallbackSymbols = {
        ...common,
        ...specialFallbackSymbols
    };
    const shouldUseMain = isUnicodeSupported();
    const figures = shouldUseMain ? mainSymbols : fallbackSymbols;
    const node_modules_figures = figures;
    Object.entries(specialMainSymbols);
    const external_node_tty_namespaceObject = require("node:tty");
    const hasColors = external_node_tty_namespaceObject?.WriteStream?.prototype?.hasColors?.() ?? false;
    const format = (open, close)=>{
        if (!hasColors) return (input)=>input;
        const openCode = `\u001B[${open}m`;
        const closeCode = `\u001B[${close}m`;
        return (input)=>{
            const string = input + '';
            let index = string.indexOf(closeCode);
            if (-1 === index) return openCode + string + closeCode;
            let result = openCode;
            let lastIndex = 0;
            while(-1 !== index){
                result += string.slice(lastIndex, index) + openCode;
                lastIndex = index + closeCode.length;
                index = string.indexOf(closeCode, lastIndex);
            }
            result += string.slice(lastIndex) + closeCode;
            return result;
        };
    };
    format(0, 0);
    const bold = format(1, 22);
    format(2, 22);
    format(3, 23);
    format(4, 24);
    format(53, 55);
    format(7, 27);
    format(8, 28);
    format(9, 29);
    format(30, 39);
    format(31, 39);
    format(32, 39);
    format(33, 39);
    format(34, 39);
    format(35, 39);
    format(36, 39);
    format(37, 39);
    const gray = format(90, 39);
    format(40, 49);
    format(41, 49);
    format(42, 49);
    format(43, 49);
    format(44, 49);
    format(45, 49);
    format(46, 49);
    format(47, 49);
    format(100, 49);
    const redBright = format(91, 39);
    format(92, 39);
    const yellowBright = format(93, 39);
    format(94, 39);
    format(95, 39);
    format(96, 39);
    format(97, 39);
    format(101, 49);
    format(102, 49);
    format(103, 49);
    format(104, 49);
    format(105, 49);
    format(106, 49);
    format(107, 49);
    const defaultVerboseFunction = ({ type, message, timestamp, piped, commandId, result: { failed = false } = {}, options: { reject = true } })=>{
        const timestampString = serializeTimestamp(timestamp);
        const icon = ICONS[type]({
            failed,
            reject,
            piped
        });
        const color = COLORS[type]({
            reject
        });
        return `${gray(`[${timestampString}]`)} ${gray(`[${commandId}]`)} ${color(icon)} ${color(message)}`;
    };
    const serializeTimestamp = (timestamp)=>`${padField(timestamp.getHours(), 2)}:${padField(timestamp.getMinutes(), 2)}:${padField(timestamp.getSeconds(), 2)}.${padField(timestamp.getMilliseconds(), 3)}`;
    const padField = (field, padding)=>String(field).padStart(padding, '0');
    const getFinalIcon = ({ failed, reject })=>{
        if (!failed) return node_modules_figures.tick;
        return reject ? node_modules_figures.cross : node_modules_figures.warning;
    };
    const ICONS = {
        command: ({ piped })=>piped ? '|' : '$',
        output: ()=>' ',
        ipc: ()=>'*',
        error: getFinalIcon,
        duration: getFinalIcon
    };
    const identity = (string)=>string;
    const COLORS = {
        command: ()=>bold,
        output: ()=>identity,
        ipc: ()=>identity,
        error: ({ reject })=>reject ? redBright : yellowBright,
        duration: ()=>gray
    };
    const applyVerboseOnLines = (printedLines, verboseInfo, fdNumber)=>{
        const verboseFunction = getVerboseFunction(verboseInfo, fdNumber);
        return printedLines.map(({ verboseLine, verboseObject })=>applyVerboseFunction(verboseLine, verboseObject, verboseFunction)).filter((printedLine)=>void 0 !== printedLine).map((printedLine)=>appendNewline(printedLine)).join('');
    };
    const applyVerboseFunction = (verboseLine, verboseObject, verboseFunction)=>{
        if (void 0 === verboseFunction) return verboseLine;
        const printedLine = verboseFunction(verboseLine, verboseObject);
        if ('string' == typeof printedLine) return printedLine;
    };
    const appendNewline = (printedLine)=>printedLine.endsWith('\n') ? printedLine : `${printedLine}\n`;
    const verboseLog = ({ type, verboseMessage, fdNumber, verboseInfo, result })=>{
        const verboseObject = getVerboseObject({
            type,
            result,
            verboseInfo
        });
        const printedLines = getPrintedLines(verboseMessage, verboseObject);
        const finalLines = applyVerboseOnLines(printedLines, verboseInfo, fdNumber);
        if ('' !== finalLines) console.warn(finalLines.slice(0, -1));
    };
    const getVerboseObject = ({ type, result, verboseInfo: { escapedCommand, commandId, rawOptions: { piped = false, ...options } } })=>({
            type,
            escapedCommand,
            commandId: `${commandId}`,
            timestamp: new Date(),
            piped,
            result,
            options
        });
    const getPrintedLines = (verboseMessage, verboseObject)=>verboseMessage.split('\n').map((message)=>getPrintedLine({
                ...verboseObject,
                message
            }));
    const getPrintedLine = (verboseObject)=>{
        const verboseLine = defaultVerboseFunction(verboseObject);
        return {
            verboseLine,
            verboseObject
        };
    };
    const serializeVerboseMessage = (message)=>{
        const messageString = 'string' == typeof message ? message : (0, external_node_util_.inspect)(message);
        const escapedMessage = escapeLines(messageString);
        return escapedMessage.replaceAll('\t', ' '.repeat(TAB_SIZE));
    };
    const TAB_SIZE = 2;
    const logCommand = (escapedCommand, verboseInfo)=>{
        if (!values_isVerbose(verboseInfo)) return;
        verboseLog({
            type: 'command',
            verboseMessage: escapedCommand,
            verboseInfo
        });
    };
    const getVerboseInfo = (verbose, escapedCommand, rawOptions)=>{
        validateVerbose(verbose);
        const commandId = getCommandId(verbose);
        return {
            verbose,
            escapedCommand,
            commandId,
            rawOptions
        };
    };
    const getCommandId = (verbose)=>values_isVerbose({
            verbose
        }) ? COMMAND_ID++ : void 0;
    let COMMAND_ID = 0n;
    const validateVerbose = (verbose)=>{
        for (const fdVerbose of verbose){
            if (false === fdVerbose) throw new TypeError('The "verbose: false" option was renamed to "verbose: \'none\'".');
            if (true === fdVerbose) throw new TypeError('The "verbose: true" option was renamed to "verbose: \'short\'".');
            if (!VERBOSE_VALUES.includes(fdVerbose) && !isVerboseFunction(fdVerbose)) {
                const allowedValues = VERBOSE_VALUES.map((allowedValue)=>`'${allowedValue}'`).join(', ');
                throw new TypeError(`The "verbose" option must not be ${fdVerbose}. Allowed values are: ${allowedValues} or a function.`);
            }
        }
    };
    const getStartTime = ()=>external_node_process_namespaceObject.hrtime.bigint();
    const getDurationMs = (startTime)=>Number(external_node_process_namespaceObject.hrtime.bigint() - startTime) / 1e6;
    const handleCommand = (filePath, rawArguments, rawOptions)=>{
        const startTime = getStartTime();
        const { command, escapedCommand } = joinCommand(filePath, rawArguments);
        const verbose = normalizeFdSpecificOption(rawOptions, 'verbose');
        const verboseInfo = getVerboseInfo(verbose, escapedCommand, {
            ...rawOptions
        });
        logCommand(escapedCommand, verboseInfo);
        return {
            command,
            escapedCommand,
            startTime,
            verboseInfo
        };
    };
    const external_node_path_namespaceObject = require("node:path");
    var cross_spawn = __webpack_require__("../../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/index.js");
    function pathKey(options = {}) {
        const { env = process.env, platform = process.platform } = options;
        if ('win32' !== platform) return 'PATH';
        return Object.keys(env).reverse().find((key)=>'PATH' === key.toUpperCase()) || 'Path';
    }
    (0, external_node_util_.promisify)(external_node_child_process_namespaceObject.execFile);
    function toPath(urlOrPath) {
        return urlOrPath instanceof URL ? (0, external_node_url_.fileURLToPath)(urlOrPath) : urlOrPath;
    }
    function traversePathUp(startPath) {
        return {
            *[Symbol.iterator] () {
                let currentPath = external_node_path_namespaceObject.resolve(toPath(startPath));
                let previousPath;
                while(previousPath !== currentPath){
                    yield currentPath;
                    previousPath = currentPath;
                    currentPath = external_node_path_namespaceObject.resolve(currentPath, '..');
                }
            }
        };
    }
    const npmRunPath = ({ cwd = external_node_process_namespaceObject.cwd(), path: pathOption = external_node_process_namespaceObject.env[pathKey()], preferLocal = true, execPath = external_node_process_namespaceObject.execPath, addExecPath = true } = {})=>{
        const cwdPath = external_node_path_namespaceObject.resolve(toPath(cwd));
        const result = [];
        const pathParts = pathOption.split(external_node_path_namespaceObject.delimiter);
        if (preferLocal) applyPreferLocal(result, pathParts, cwdPath);
        if (addExecPath) applyExecPath(result, pathParts, execPath, cwdPath);
        return '' === pathOption || pathOption === external_node_path_namespaceObject.delimiter ? `${result.join(external_node_path_namespaceObject.delimiter)}${pathOption}` : [
            ...result,
            pathOption
        ].join(external_node_path_namespaceObject.delimiter);
    };
    const applyPreferLocal = (result, pathParts, cwdPath)=>{
        for (const directory of traversePathUp(cwdPath)){
            const pathPart = external_node_path_namespaceObject.join(directory, 'node_modules/.bin');
            if (!pathParts.includes(pathPart)) result.push(pathPart);
        }
    };
    const applyExecPath = (result, pathParts, execPath, cwdPath)=>{
        const pathPart = external_node_path_namespaceObject.resolve(cwdPath, toPath(execPath), '..');
        if (!pathParts.includes(pathPart)) result.push(pathPart);
    };
    const npmRunPathEnv = ({ env = external_node_process_namespaceObject.env, ...options } = {})=>{
        env = {
            ...env
        };
        const pathName = pathKey({
            env
        });
        options.path = env[pathName];
        env[pathName] = npmRunPath(options);
        return env;
    };
    const external_node_timers_promises_namespaceObject = require("node:timers/promises");
    const getFinalError = (originalError, message, isSync)=>{
        const ErrorClass = isSync ? ExecaSyncError : ExecaError;
        const options = originalError instanceof DiscardedError ? {} : {
            cause: originalError
        };
        return new ErrorClass(message, options);
    };
    class DiscardedError extends Error {
    }
    const setErrorName = (ErrorClass, value)=>{
        Object.defineProperty(ErrorClass.prototype, 'name', {
            value,
            writable: true,
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ErrorClass.prototype, execaErrorSymbol, {
            value: true,
            writable: false,
            enumerable: false,
            configurable: false
        });
    };
    const isExecaError = (error)=>isErrorInstance(error) && execaErrorSymbol in error;
    const execaErrorSymbol = Symbol('isExecaError');
    const isErrorInstance = (value)=>'[object Error]' === Object.prototype.toString.call(value);
    class ExecaError extends Error {
    }
    setErrorName(ExecaError, ExecaError.name);
    class ExecaSyncError extends Error {
    }
    setErrorName(ExecaSyncError, ExecaSyncError.name);
    const external_node_os_namespaceObject = require("node:os");
    const SIGNALS = [
        {
            name: "SIGHUP",
            number: 1,
            action: "terminate",
            description: "Terminal closed",
            standard: "posix"
        },
        {
            name: "SIGINT",
            number: 2,
            action: "terminate",
            description: "User interruption with CTRL-C",
            standard: "ansi"
        },
        {
            name: "SIGQUIT",
            number: 3,
            action: "core",
            description: "User interruption with CTRL-\\",
            standard: "posix"
        },
        {
            name: "SIGILL",
            number: 4,
            action: "core",
            description: "Invalid machine instruction",
            standard: "ansi"
        },
        {
            name: "SIGTRAP",
            number: 5,
            action: "core",
            description: "Debugger breakpoint",
            standard: "posix"
        },
        {
            name: "SIGABRT",
            number: 6,
            action: "core",
            description: "Aborted",
            standard: "ansi"
        },
        {
            name: "SIGIOT",
            number: 6,
            action: "core",
            description: "Aborted",
            standard: "bsd"
        },
        {
            name: "SIGBUS",
            number: 7,
            action: "core",
            description: "Bus error due to misaligned, non-existing address or paging error",
            standard: "bsd"
        },
        {
            name: "SIGEMT",
            number: 7,
            action: "terminate",
            description: "Command should be emulated but is not implemented",
            standard: "other"
        },
        {
            name: "SIGFPE",
            number: 8,
            action: "core",
            description: "Floating point arithmetic error",
            standard: "ansi"
        },
        {
            name: "SIGKILL",
            number: 9,
            action: "terminate",
            description: "Forced termination",
            standard: "posix",
            forced: true
        },
        {
            name: "SIGUSR1",
            number: 10,
            action: "terminate",
            description: "Application-specific signal",
            standard: "posix"
        },
        {
            name: "SIGSEGV",
            number: 11,
            action: "core",
            description: "Segmentation fault",
            standard: "ansi"
        },
        {
            name: "SIGUSR2",
            number: 12,
            action: "terminate",
            description: "Application-specific signal",
            standard: "posix"
        },
        {
            name: "SIGPIPE",
            number: 13,
            action: "terminate",
            description: "Broken pipe or socket",
            standard: "posix"
        },
        {
            name: "SIGALRM",
            number: 14,
            action: "terminate",
            description: "Timeout or timer",
            standard: "posix"
        },
        {
            name: "SIGTERM",
            number: 15,
            action: "terminate",
            description: "Termination",
            standard: "ansi"
        },
        {
            name: "SIGSTKFLT",
            number: 16,
            action: "terminate",
            description: "Stack is empty or overflowed",
            standard: "other"
        },
        {
            name: "SIGCHLD",
            number: 17,
            action: "ignore",
            description: "Child process terminated, paused or unpaused",
            standard: "posix"
        },
        {
            name: "SIGCLD",
            number: 17,
            action: "ignore",
            description: "Child process terminated, paused or unpaused",
            standard: "other"
        },
        {
            name: "SIGCONT",
            number: 18,
            action: "unpause",
            description: "Unpaused",
            standard: "posix",
            forced: true
        },
        {
            name: "SIGSTOP",
            number: 19,
            action: "pause",
            description: "Paused",
            standard: "posix",
            forced: true
        },
        {
            name: "SIGTSTP",
            number: 20,
            action: "pause",
            description: "Paused using CTRL-Z or \"suspend\"",
            standard: "posix"
        },
        {
            name: "SIGTTIN",
            number: 21,
            action: "pause",
            description: "Background process cannot read terminal input",
            standard: "posix"
        },
        {
            name: "SIGBREAK",
            number: 21,
            action: "terminate",
            description: "User interruption with CTRL-BREAK",
            standard: "other"
        },
        {
            name: "SIGTTOU",
            number: 22,
            action: "pause",
            description: "Background process cannot write to terminal output",
            standard: "posix"
        },
        {
            name: "SIGURG",
            number: 23,
            action: "ignore",
            description: "Socket received out-of-band data",
            standard: "bsd"
        },
        {
            name: "SIGXCPU",
            number: 24,
            action: "core",
            description: "Process timed out",
            standard: "bsd"
        },
        {
            name: "SIGXFSZ",
            number: 25,
            action: "core",
            description: "File too big",
            standard: "bsd"
        },
        {
            name: "SIGVTALRM",
            number: 26,
            action: "terminate",
            description: "Timeout or timer",
            standard: "bsd"
        },
        {
            name: "SIGPROF",
            number: 27,
            action: "terminate",
            description: "Timeout or timer",
            standard: "bsd"
        },
        {
            name: "SIGWINCH",
            number: 28,
            action: "ignore",
            description: "Terminal window size changed",
            standard: "bsd"
        },
        {
            name: "SIGIO",
            number: 29,
            action: "terminate",
            description: "I/O is available",
            standard: "other"
        },
        {
            name: "SIGPOLL",
            number: 29,
            action: "terminate",
            description: "Watched event",
            standard: "other"
        },
        {
            name: "SIGINFO",
            number: 29,
            action: "ignore",
            description: "Request for process information",
            standard: "other"
        },
        {
            name: "SIGPWR",
            number: 30,
            action: "terminate",
            description: "Device running out of power",
            standard: "systemv"
        },
        {
            name: "SIGSYS",
            number: 31,
            action: "core",
            description: "Invalid system call",
            standard: "other"
        },
        {
            name: "SIGUNUSED",
            number: 31,
            action: "terminate",
            description: "Invalid system call",
            standard: "other"
        }
    ];
    const getRealtimeSignals = ()=>{
        const length = SIGRTMAX - SIGRTMIN + 1;
        return Array.from({
            length
        }, getRealtimeSignal);
    };
    const getRealtimeSignal = (value, index)=>({
            name: `SIGRT${index + 1}`,
            number: SIGRTMIN + index,
            action: "terminate",
            description: "Application-specific signal (realtime)",
            standard: "posix"
        });
    const SIGRTMIN = 34;
    const SIGRTMAX = 64;
    const getSignals = ()=>{
        const realtimeSignals = getRealtimeSignals();
        const signals = [
            ...SIGNALS,
            ...realtimeSignals
        ].map(normalizeSignal);
        return signals;
    };
    const normalizeSignal = ({ name, number: defaultNumber, description, action, forced = false, standard })=>{
        const { signals: { [name]: constantSignal } } = external_node_os_namespaceObject.constants;
        const supported = void 0 !== constantSignal;
        const number = supported ? constantSignal : defaultNumber;
        return {
            name,
            number,
            description,
            supported,
            action,
            forced,
            standard
        };
    };
    const getSignalsByName = ()=>{
        const signals = getSignals();
        return Object.fromEntries(signals.map(getSignalByName));
    };
    const getSignalByName = ({ name, number, description, supported, action, forced, standard })=>[
            name,
            {
                name,
                number,
                description,
                supported,
                action,
                forced,
                standard
            }
        ];
    const signalsByName = getSignalsByName();
    const getSignalsByNumber = ()=>{
        const signals = getSignals();
        const length = 65;
        const signalsA = Array.from({
            length
        }, (value, number)=>getSignalByNumber(number, signals));
        return Object.assign({}, ...signalsA);
    };
    const getSignalByNumber = (number, signals)=>{
        const signal = findSignalByNumber(number, signals);
        if (void 0 === signal) return {};
        const { name, description, supported, action, forced, standard } = signal;
        return {
            [number]: {
                name,
                number,
                description,
                supported,
                action,
                forced,
                standard
            }
        };
    };
    const findSignalByNumber = (number, signals)=>{
        const signal = signals.find(({ name })=>external_node_os_namespaceObject.constants.signals[name] === number);
        if (void 0 !== signal) return signal;
        return signals.find((signalA)=>signalA.number === number);
    };
    getSignalsByNumber();
    const normalizeKillSignal = (killSignal)=>{
        const optionName = 'option `killSignal`';
        if (0 === killSignal) throw new TypeError(`Invalid ${optionName}: 0 cannot be used.`);
        return signal_normalizeSignal(killSignal, optionName);
    };
    const normalizeSignalArgument = (signal)=>0 === signal ? signal : signal_normalizeSignal(signal, '`subprocess.kill()`\'s argument');
    const signal_normalizeSignal = (signalNameOrInteger, optionName)=>{
        if (Number.isInteger(signalNameOrInteger)) return normalizeSignalInteger(signalNameOrInteger, optionName);
        if ('string' == typeof signalNameOrInteger) return normalizeSignalName(signalNameOrInteger, optionName);
        throw new TypeError(`Invalid ${optionName} ${String(signalNameOrInteger)}: it must be a string or an integer.\n${getAvailableSignals()}`);
    };
    const normalizeSignalInteger = (signalInteger, optionName)=>{
        if (signalsIntegerToName.has(signalInteger)) return signalsIntegerToName.get(signalInteger);
        throw new TypeError(`Invalid ${optionName} ${signalInteger}: this signal integer does not exist.\n${getAvailableSignals()}`);
    };
    const getSignalsIntegerToName = ()=>new Map(Object.entries(external_node_os_namespaceObject.constants.signals).reverse().map(([signalName, signalInteger])=>[
                signalInteger,
                signalName
            ]));
    const signalsIntegerToName = getSignalsIntegerToName();
    const normalizeSignalName = (signalName, optionName)=>{
        if (signalName in external_node_os_namespaceObject.constants.signals) return signalName;
        if (signalName.toUpperCase() in external_node_os_namespaceObject.constants.signals) throw new TypeError(`Invalid ${optionName} '${signalName}': please rename it to '${signalName.toUpperCase()}'.`);
        throw new TypeError(`Invalid ${optionName} '${signalName}': this signal name does not exist.\n${getAvailableSignals()}`);
    };
    const getAvailableSignals = ()=>`Available signal names: ${getAvailableSignalNames()}.
Available signal numbers: ${getAvailableSignalIntegers()}.`;
    const getAvailableSignalNames = ()=>Object.keys(external_node_os_namespaceObject.constants.signals).sort().map((signalName)=>`'${signalName}'`).join(', ');
    const getAvailableSignalIntegers = ()=>[
            ...new Set(Object.values(external_node_os_namespaceObject.constants.signals).sort((signalInteger, signalIntegerTwo)=>signalInteger - signalIntegerTwo))
        ].join(', ');
    const getSignalDescription = (signal)=>signalsByName[signal].description;
    const normalizeForceKillAfterDelay = (forceKillAfterDelay)=>{
        if (false === forceKillAfterDelay) return forceKillAfterDelay;
        if (true === forceKillAfterDelay) return DEFAULT_FORCE_KILL_TIMEOUT;
        if (!Number.isFinite(forceKillAfterDelay) || forceKillAfterDelay < 0) throw new TypeError(`Expected the \`forceKillAfterDelay\` option to be a non-negative integer, got \`${forceKillAfterDelay}\` (${typeof forceKillAfterDelay})`);
        return forceKillAfterDelay;
    };
    const DEFAULT_FORCE_KILL_TIMEOUT = 5000;
    const subprocessKill = ({ kill, options: { forceKillAfterDelay, killSignal }, onInternalError, context, controller }, signalOrError, errorArgument)=>{
        const { signal, error } = parseKillArguments(signalOrError, errorArgument, killSignal);
        emitKillError(error, onInternalError);
        const killResult = kill(signal);
        setKillTimeout({
            kill,
            signal,
            forceKillAfterDelay,
            killSignal,
            killResult,
            context,
            controller
        });
        return killResult;
    };
    const parseKillArguments = (signalOrError, errorArgument, killSignal)=>{
        const [signal = killSignal, error] = isErrorInstance(signalOrError) ? [
            void 0,
            signalOrError
        ] : [
            signalOrError,
            errorArgument
        ];
        if ('string' != typeof signal && !Number.isInteger(signal)) throw new TypeError(`The first argument must be an error instance or a signal name string/integer: ${String(signal)}`);
        if (void 0 !== error && !isErrorInstance(error)) throw new TypeError(`The second argument is optional. If specified, it must be an error instance: ${error}`);
        return {
            signal: normalizeSignalArgument(signal),
            error
        };
    };
    const emitKillError = (error, onInternalError)=>{
        if (void 0 !== error) onInternalError.reject(error);
    };
    const setKillTimeout = async ({ kill, signal, forceKillAfterDelay, killSignal, killResult, context, controller })=>{
        if (signal === killSignal && killResult) killOnTimeout({
            kill,
            forceKillAfterDelay,
            context,
            controllerSignal: controller.signal
        });
    };
    const killOnTimeout = async ({ kill, forceKillAfterDelay, context, controllerSignal })=>{
        if (false === forceKillAfterDelay) return;
        try {
            await (0, external_node_timers_promises_namespaceObject.setTimeout)(forceKillAfterDelay, void 0, {
                signal: controllerSignal
            });
            if (kill('SIGKILL')) context.isForcefullyTerminated ??= true;
        } catch  {}
    };
    var external_node_events_ = __webpack_require__("node:events");
    const onAbortedSignal = async (mainSignal, stopSignal)=>{
        if (!mainSignal.aborted) await (0, external_node_events_.once)(mainSignal, 'abort', {
            signal: stopSignal
        });
    };
    const validateCancelSignal = ({ cancelSignal })=>{
        if (void 0 !== cancelSignal && '[object AbortSignal]' !== Object.prototype.toString.call(cancelSignal)) throw new Error(`The \`cancelSignal\` option must be an AbortSignal: ${String(cancelSignal)}`);
    };
    const throwOnCancel = ({ subprocess, cancelSignal, gracefulCancel, context, controller })=>void 0 === cancelSignal || gracefulCancel ? [] : [
            terminateOnCancel(subprocess, cancelSignal, context, controller)
        ];
    const terminateOnCancel = async (subprocess, cancelSignal, context, { signal })=>{
        await onAbortedSignal(cancelSignal, signal);
        context.terminationReason ??= 'cancel';
        subprocess.kill();
        throw cancelSignal.reason;
    };
    const validateIpcMethod = ({ methodName, isSubprocess, ipc, isConnected })=>{
        validateIpcOption(methodName, isSubprocess, ipc);
        validateConnection(methodName, isSubprocess, isConnected);
    };
    const validateIpcOption = (methodName, isSubprocess, ipc)=>{
        if (!ipc) throw new Error(`${getMethodName(methodName, isSubprocess)} can only be used if the \`ipc\` option is \`true\`.`);
    };
    const validateConnection = (methodName, isSubprocess, isConnected)=>{
        if (!isConnected) throw new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} has already exited or disconnected.`);
    };
    const throwOnEarlyDisconnect = (isSubprocess)=>{
        throw new Error(`${getMethodName('getOneMessage', isSubprocess)} could not complete: the ${getOtherProcessName(isSubprocess)} exited or disconnected.`);
    };
    const throwOnStrictDeadlockError = (isSubprocess)=>{
        throw new Error(`${getMethodName('sendMessage', isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is sending a message too, instead of listening to incoming messages.
This can be fixed by both sending a message and listening to incoming messages at the same time:

const [receivedMessage] = await Promise.all([
	${getMethodName('getOneMessage', isSubprocess)},
	${getMethodName('sendMessage', isSubprocess, 'message, {strict: true}')},
]);`);
    };
    const getStrictResponseError = (error, isSubprocess)=>new Error(`${getMethodName('sendMessage', isSubprocess)} failed when sending an acknowledgment response to the ${getOtherProcessName(isSubprocess)}.`, {
            cause: error
        });
    const throwOnMissingStrict = (isSubprocess)=>{
        throw new Error(`${getMethodName('sendMessage', isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is not listening to incoming messages.`);
    };
    const throwOnStrictDisconnect = (isSubprocess)=>{
        throw new Error(`${getMethodName('sendMessage', isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} exited without listening to incoming messages.`);
    };
    const getAbortDisconnectError = ()=>new Error(`\`cancelSignal\` aborted: the ${getOtherProcessName(true)} disconnected.`);
    const throwOnMissingParent = ()=>{
        throw new Error('`getCancelSignal()` cannot be used without setting the `cancelSignal` subprocess option.');
    };
    const handleEpipeError = ({ error, methodName, isSubprocess })=>{
        if ('EPIPE' === error.code) throw new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} is disconnecting.`, {
            cause: error
        });
    };
    const handleSerializationError = ({ error, methodName, isSubprocess, message })=>{
        if (isSerializationError(error)) throw new Error(`${getMethodName(methodName, isSubprocess)}'s argument type is invalid: the message cannot be serialized: ${String(message)}.`, {
            cause: error
        });
    };
    const isSerializationError = ({ code, message })=>SERIALIZATION_ERROR_CODES.has(code) || SERIALIZATION_ERROR_MESSAGES.some((serializationErrorMessage)=>message.includes(serializationErrorMessage));
    const SERIALIZATION_ERROR_CODES = new Set([
        'ERR_MISSING_ARGS',
        'ERR_INVALID_ARG_TYPE'
    ]);
    const SERIALIZATION_ERROR_MESSAGES = [
        'could not be cloned',
        'circular structure',
        'call stack size exceeded'
    ];
    const getMethodName = (methodName, isSubprocess, parameters = '')=>'cancelSignal' === methodName ? '`cancelSignal`\'s `controller.abort()`' : `${getNamespaceName(isSubprocess)}${methodName}(${parameters})`;
    const getNamespaceName = (isSubprocess)=>isSubprocess ? '' : 'subprocess.';
    const getOtherProcessName = (isSubprocess)=>isSubprocess ? 'parent process' : 'subprocess';
    const disconnect = (anyProcess)=>{
        if (anyProcess.connected) anyProcess.disconnect();
    };
    const createDeferred = ()=>{
        const methods = {};
        const promise = new Promise((resolve, reject)=>{
            Object.assign(methods, {
                resolve,
                reject
            });
        });
        return Object.assign(promise, methods);
    };
    const getToStream = (destination, to = 'stdin')=>{
        const isWritable = true;
        const { options, fileDescriptors } = SUBPROCESS_OPTIONS.get(destination);
        const fdNumber = getFdNumber(fileDescriptors, to, isWritable);
        const destinationStream = destination.stdio[fdNumber];
        if (null === destinationStream) throw new TypeError(getInvalidStdioOptionMessage(fdNumber, to, options, isWritable));
        return destinationStream;
    };
    const getFromStream = (source, from = 'stdout')=>{
        const isWritable = false;
        const { options, fileDescriptors } = SUBPROCESS_OPTIONS.get(source);
        const fdNumber = getFdNumber(fileDescriptors, from, isWritable);
        const sourceStream = 'all' === fdNumber ? source.all : source.stdio[fdNumber];
        if (null == sourceStream) throw new TypeError(getInvalidStdioOptionMessage(fdNumber, from, options, isWritable));
        return sourceStream;
    };
    const SUBPROCESS_OPTIONS = new WeakMap();
    const getFdNumber = (fileDescriptors, fdName, isWritable)=>{
        const fdNumber = parseFdNumber(fdName, isWritable);
        validateFdNumber(fdNumber, fdName, isWritable, fileDescriptors);
        return fdNumber;
    };
    const parseFdNumber = (fdName, isWritable)=>{
        const fdNumber = parseFd(fdName);
        if (void 0 !== fdNumber) return fdNumber;
        const { validOptions, defaultValue } = isWritable ? {
            validOptions: '"stdin"',
            defaultValue: 'stdin'
        } : {
            validOptions: '"stdout", "stderr", "all"',
            defaultValue: 'stdout'
        };
        throw new TypeError(`"${getOptionName(isWritable)}" must not be "${fdName}".
It must be ${validOptions} or "fd3", "fd4" (and so on).
It is optional and defaults to "${defaultValue}".`);
    };
    const validateFdNumber = (fdNumber, fdName, isWritable, fileDescriptors)=>{
        const fileDescriptor = fileDescriptors[getUsedDescriptor(fdNumber)];
        if (void 0 === fileDescriptor) throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. That file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);
        if ('input' === fileDescriptor.direction && !isWritable) throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. It must be a readable stream, not writable.`);
        if ('input' !== fileDescriptor.direction && isWritable) throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. It must be a writable stream, not readable.`);
    };
    const getInvalidStdioOptionMessage = (fdNumber, fdName, options, isWritable)=>{
        if ('all' === fdNumber && !options.all) return 'The "all" option must be true to use "from: \'all\'".';
        const { optionName, optionValue } = getInvalidStdioOption(fdNumber, options);
        return `The "${optionName}: ${serializeOptionValue(optionValue)}" option is incompatible with using "${getOptionName(isWritable)}: ${serializeOptionValue(fdName)}".
Please set this option with "pipe" instead.`;
    };
    const getInvalidStdioOption = (fdNumber, { stdin, stdout, stderr, stdio })=>{
        const usedDescriptor = getUsedDescriptor(fdNumber);
        if (0 === usedDescriptor && void 0 !== stdin) return {
            optionName: 'stdin',
            optionValue: stdin
        };
        if (1 === usedDescriptor && void 0 !== stdout) return {
            optionName: 'stdout',
            optionValue: stdout
        };
        if (2 === usedDescriptor && void 0 !== stderr) return {
            optionName: 'stderr',
            optionValue: stderr
        };
        return {
            optionName: `stdio[${usedDescriptor}]`,
            optionValue: stdio[usedDescriptor]
        };
    };
    const getUsedDescriptor = (fdNumber)=>'all' === fdNumber ? 1 : fdNumber;
    const getOptionName = (isWritable)=>isWritable ? 'to' : 'from';
    const serializeOptionValue = (value)=>{
        if ('string' == typeof value) return `'${value}'`;
        return 'number' == typeof value ? `${value}` : 'Stream';
    };
    const incrementMaxListeners = (eventEmitter, maxListenersIncrement, signal)=>{
        const maxListeners = eventEmitter.getMaxListeners();
        if (0 === maxListeners || maxListeners === 1 / 0) return;
        eventEmitter.setMaxListeners(maxListeners + maxListenersIncrement);
        (0, external_node_events_.addAbortListener)(signal, ()=>{
            eventEmitter.setMaxListeners(eventEmitter.getMaxListeners() - maxListenersIncrement);
        });
    };
    const addReference = (channel, reference)=>{
        if (reference) addReferenceCount(channel);
    };
    const addReferenceCount = (channel)=>{
        channel.refCounted();
    };
    const removeReference = (channel, reference)=>{
        if (reference) removeReferenceCount(channel);
    };
    const removeReferenceCount = (channel)=>{
        channel.unrefCounted();
    };
    const undoAddedReferences = (channel, isSubprocess)=>{
        if (isSubprocess) {
            removeReferenceCount(channel);
            removeReferenceCount(channel);
        }
    };
    const redoAddedReferences = (channel, isSubprocess)=>{
        if (isSubprocess) {
            addReferenceCount(channel);
            addReferenceCount(channel);
        }
    };
    const onMessage = async ({ anyProcess, channel, isSubprocess, ipcEmitter }, wrappedMessage)=>{
        if (handleStrictResponse(wrappedMessage) || handleAbort(wrappedMessage)) return;
        if (!INCOMING_MESSAGES.has(anyProcess)) INCOMING_MESSAGES.set(anyProcess, []);
        const incomingMessages = INCOMING_MESSAGES.get(anyProcess);
        incomingMessages.push(wrappedMessage);
        if (incomingMessages.length > 1) return;
        while(incomingMessages.length > 0){
            await waitForOutgoingMessages(anyProcess, ipcEmitter, wrappedMessage);
            await external_node_timers_promises_namespaceObject.scheduler["yield"]();
            const message = await handleStrictRequest({
                wrappedMessage: incomingMessages[0],
                anyProcess,
                channel,
                isSubprocess,
                ipcEmitter
            });
            incomingMessages.shift();
            ipcEmitter.emit('message', message);
            ipcEmitter.emit('message:done');
        }
    };
    const onDisconnect = async ({ anyProcess, channel, isSubprocess, ipcEmitter, boundOnMessage })=>{
        abortOnDisconnect();
        const incomingMessages = INCOMING_MESSAGES.get(anyProcess);
        while(incomingMessages?.length > 0)await (0, external_node_events_.once)(ipcEmitter, 'message:done');
        anyProcess.removeListener('message', boundOnMessage);
        redoAddedReferences(channel, isSubprocess);
        ipcEmitter.connected = false;
        ipcEmitter.emit('disconnect');
    };
    const INCOMING_MESSAGES = new WeakMap();
    const getIpcEmitter = (anyProcess, channel, isSubprocess)=>{
        if (IPC_EMITTERS.has(anyProcess)) return IPC_EMITTERS.get(anyProcess);
        const ipcEmitter = new external_node_events_.EventEmitter();
        ipcEmitter.connected = true;
        IPC_EMITTERS.set(anyProcess, ipcEmitter);
        forwardEvents({
            ipcEmitter,
            anyProcess,
            channel,
            isSubprocess
        });
        return ipcEmitter;
    };
    const IPC_EMITTERS = new WeakMap();
    const forwardEvents = ({ ipcEmitter, anyProcess, channel, isSubprocess })=>{
        const boundOnMessage = onMessage.bind(void 0, {
            anyProcess,
            channel,
            isSubprocess,
            ipcEmitter
        });
        anyProcess.on('message', boundOnMessage);
        anyProcess.once('disconnect', onDisconnect.bind(void 0, {
            anyProcess,
            channel,
            isSubprocess,
            ipcEmitter,
            boundOnMessage
        }));
        undoAddedReferences(channel, isSubprocess);
    };
    const forward_isConnected = (anyProcess)=>{
        const ipcEmitter = IPC_EMITTERS.get(anyProcess);
        return void 0 === ipcEmitter ? null !== anyProcess.channel : ipcEmitter.connected;
    };
    const handleSendStrict = ({ anyProcess, channel, isSubprocess, message, strict })=>{
        if (!strict) return message;
        const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
        const hasListeners = hasMessageListeners(anyProcess, ipcEmitter);
        return {
            id: strict_count++,
            type: REQUEST_TYPE,
            message,
            hasListeners
        };
    };
    let strict_count = 0n;
    const validateStrictDeadlock = (outgoingMessages, wrappedMessage)=>{
        if (wrappedMessage?.type !== REQUEST_TYPE || wrappedMessage.hasListeners) return;
        for (const { id } of outgoingMessages)if (void 0 !== id) STRICT_RESPONSES[id].resolve({
            isDeadlock: true,
            hasListeners: false
        });
    };
    const handleStrictRequest = async ({ wrappedMessage, anyProcess, channel, isSubprocess, ipcEmitter })=>{
        if (wrappedMessage?.type !== REQUEST_TYPE || !anyProcess.connected) return wrappedMessage;
        const { id, message } = wrappedMessage;
        const response = {
            id,
            type: RESPONSE_TYPE,
            message: hasMessageListeners(anyProcess, ipcEmitter)
        };
        try {
            await sendMessage({
                anyProcess,
                channel,
                isSubprocess,
                ipc: true
            }, response);
        } catch (error) {
            ipcEmitter.emit('strict:error', error);
        }
        return message;
    };
    const handleStrictResponse = (wrappedMessage)=>{
        if (wrappedMessage?.type !== RESPONSE_TYPE) return false;
        const { id, message: hasListeners } = wrappedMessage;
        STRICT_RESPONSES[id]?.resolve({
            isDeadlock: false,
            hasListeners
        });
        return true;
    };
    const waitForStrictResponse = async (wrappedMessage, anyProcess, isSubprocess)=>{
        if (wrappedMessage?.type !== REQUEST_TYPE) return;
        const deferred = createDeferred();
        STRICT_RESPONSES[wrappedMessage.id] = deferred;
        const controller = new AbortController();
        try {
            const { isDeadlock, hasListeners } = await Promise.race([
                deferred,
                throwOnDisconnect(anyProcess, isSubprocess, controller)
            ]);
            if (isDeadlock) throwOnStrictDeadlockError(isSubprocess);
            if (!hasListeners) throwOnMissingStrict(isSubprocess);
        } finally{
            controller.abort();
            delete STRICT_RESPONSES[wrappedMessage.id];
        }
    };
    const STRICT_RESPONSES = {};
    const throwOnDisconnect = async (anyProcess, isSubprocess, { signal })=>{
        incrementMaxListeners(anyProcess, 1, signal);
        await (0, external_node_events_.once)(anyProcess, 'disconnect', {
            signal
        });
        throwOnStrictDisconnect(isSubprocess);
    };
    const REQUEST_TYPE = 'execa:ipc:request';
    const RESPONSE_TYPE = 'execa:ipc:response';
    const startSendMessage = (anyProcess, wrappedMessage, strict)=>{
        if (!OUTGOING_MESSAGES.has(anyProcess)) OUTGOING_MESSAGES.set(anyProcess, new Set());
        const outgoingMessages = OUTGOING_MESSAGES.get(anyProcess);
        const onMessageSent = createDeferred();
        const id = strict ? wrappedMessage.id : void 0;
        const outgoingMessage = {
            onMessageSent,
            id
        };
        outgoingMessages.add(outgoingMessage);
        return {
            outgoingMessages,
            outgoingMessage
        };
    };
    const endSendMessage = ({ outgoingMessages, outgoingMessage })=>{
        outgoingMessages.delete(outgoingMessage);
        outgoingMessage.onMessageSent.resolve();
    };
    const waitForOutgoingMessages = async (anyProcess, ipcEmitter, wrappedMessage)=>{
        while(!hasMessageListeners(anyProcess, ipcEmitter) && OUTGOING_MESSAGES.get(anyProcess)?.size > 0){
            const outgoingMessages = [
                ...OUTGOING_MESSAGES.get(anyProcess)
            ];
            validateStrictDeadlock(outgoingMessages, wrappedMessage);
            await Promise.all(outgoingMessages.map(({ onMessageSent })=>onMessageSent));
        }
    };
    const OUTGOING_MESSAGES = new WeakMap();
    const hasMessageListeners = (anyProcess, ipcEmitter)=>ipcEmitter.listenerCount('message') > getMinListenerCount(anyProcess);
    const getMinListenerCount = (anyProcess)=>SUBPROCESS_OPTIONS.has(anyProcess) && !getFdSpecificValue(SUBPROCESS_OPTIONS.get(anyProcess).options.buffer, 'ipc') ? 1 : 0;
    const sendMessage = ({ anyProcess, channel, isSubprocess, ipc }, message, { strict = false } = {})=>{
        const methodName = 'sendMessage';
        validateIpcMethod({
            methodName,
            isSubprocess,
            ipc,
            isConnected: anyProcess.connected
        });
        return sendMessageAsync({
            anyProcess,
            channel,
            methodName,
            isSubprocess,
            message,
            strict
        });
    };
    const sendMessageAsync = async ({ anyProcess, channel, methodName, isSubprocess, message, strict })=>{
        const wrappedMessage = handleSendStrict({
            anyProcess,
            channel,
            isSubprocess,
            message,
            strict
        });
        const outgoingMessagesState = startSendMessage(anyProcess, wrappedMessage, strict);
        try {
            await sendOneMessage({
                anyProcess,
                methodName,
                isSubprocess,
                wrappedMessage,
                message
            });
        } catch (error) {
            disconnect(anyProcess);
            throw error;
        } finally{
            endSendMessage(outgoingMessagesState);
        }
    };
    const sendOneMessage = async ({ anyProcess, methodName, isSubprocess, wrappedMessage, message })=>{
        const sendMethod = getSendMethod(anyProcess);
        try {
            await Promise.all([
                waitForStrictResponse(wrappedMessage, anyProcess, isSubprocess),
                sendMethod(wrappedMessage)
            ]);
        } catch (error) {
            handleEpipeError({
                error,
                methodName,
                isSubprocess
            });
            handleSerializationError({
                error,
                methodName,
                isSubprocess,
                message
            });
            throw error;
        }
    };
    const getSendMethod = (anyProcess)=>{
        if (PROCESS_SEND_METHODS.has(anyProcess)) return PROCESS_SEND_METHODS.get(anyProcess);
        const sendMethod = (0, external_node_util_.promisify)(anyProcess.send.bind(anyProcess));
        PROCESS_SEND_METHODS.set(anyProcess, sendMethod);
        return sendMethod;
    };
    const PROCESS_SEND_METHODS = new WeakMap();
    const sendAbort = (subprocess, message)=>{
        const methodName = 'cancelSignal';
        validateConnection(methodName, false, subprocess.connected);
        return sendOneMessage({
            anyProcess: subprocess,
            methodName,
            isSubprocess: false,
            wrappedMessage: {
                type: GRACEFUL_CANCEL_TYPE,
                message
            },
            message
        });
    };
    const getCancelSignal = async ({ anyProcess, channel, isSubprocess, ipc })=>{
        await startIpc({
            anyProcess,
            channel,
            isSubprocess,
            ipc
        });
        return cancelController.signal;
    };
    const startIpc = async ({ anyProcess, channel, isSubprocess, ipc })=>{
        if (cancelListening) return;
        cancelListening = true;
        if (!ipc) return void throwOnMissingParent();
        if (null === channel) return void abortOnDisconnect();
        getIpcEmitter(anyProcess, channel, isSubprocess);
        await external_node_timers_promises_namespaceObject.scheduler["yield"]();
    };
    let cancelListening = false;
    const handleAbort = (wrappedMessage)=>{
        if (wrappedMessage?.type !== GRACEFUL_CANCEL_TYPE) return false;
        cancelController.abort(wrappedMessage.message);
        return true;
    };
    const GRACEFUL_CANCEL_TYPE = 'execa:ipc:cancel';
    const abortOnDisconnect = ()=>{
        cancelController.abort(getAbortDisconnectError());
    };
    const cancelController = new AbortController();
    const validateGracefulCancel = ({ gracefulCancel, cancelSignal, ipc, serialization })=>{
        if (!gracefulCancel) return;
        if (void 0 === cancelSignal) throw new Error('The `cancelSignal` option must be defined when setting the `gracefulCancel` option.');
        if (!ipc) throw new Error('The `ipc` option cannot be false when setting the `gracefulCancel` option.');
        if ('json' === serialization) throw new Error('The `serialization` option cannot be \'json\' when setting the `gracefulCancel` option.');
    };
    const throwOnGracefulCancel = ({ subprocess, cancelSignal, gracefulCancel, forceKillAfterDelay, context, controller })=>gracefulCancel ? [
            sendOnAbort({
                subprocess,
                cancelSignal,
                forceKillAfterDelay,
                context,
                controller
            })
        ] : [];
    const sendOnAbort = async ({ subprocess, cancelSignal, forceKillAfterDelay, context, controller: { signal } })=>{
        await onAbortedSignal(cancelSignal, signal);
        const reason = getReason(cancelSignal);
        await sendAbort(subprocess, reason);
        killOnTimeout({
            kill: subprocess.kill,
            forceKillAfterDelay,
            context,
            controllerSignal: signal
        });
        context.terminationReason ??= 'gracefulCancel';
        throw cancelSignal.reason;
    };
    const getReason = ({ reason })=>{
        if (!(reason instanceof DOMException)) return reason;
        const error = new Error(reason.message);
        Object.defineProperty(error, 'stack', {
            value: reason.stack,
            enumerable: false,
            configurable: true,
            writable: true
        });
        return error;
    };
    const validateTimeout = ({ timeout })=>{
        if (void 0 !== timeout && (!Number.isFinite(timeout) || timeout < 0)) throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
    };
    const throwOnTimeout = (subprocess, timeout, context, controller)=>0 === timeout || void 0 === timeout ? [] : [
            killAfterTimeout(subprocess, timeout, context, controller)
        ];
    const killAfterTimeout = async (subprocess, timeout, context, { signal })=>{
        await (0, external_node_timers_promises_namespaceObject.setTimeout)(timeout, void 0, {
            signal
        });
        context.terminationReason ??= 'timeout';
        subprocess.kill();
        throw new DiscardedError();
    };
    const mapNode = ({ options })=>{
        if (false === options.node) throw new TypeError('The "node" option cannot be false with `execaNode()`.');
        return {
            options: {
                ...options,
                node: true
            }
        };
    };
    const handleNodeOption = (file, commandArguments, { node: shouldHandleNode = false, nodePath = external_node_process_namespaceObject.execPath, nodeOptions = external_node_process_namespaceObject.execArgv.filter((nodeOption)=>!nodeOption.startsWith('--inspect')), cwd, execPath: formerNodePath, ...options })=>{
        if (void 0 !== formerNodePath) throw new TypeError('The "execPath" option has been removed. Please use the "nodePath" option instead.');
        const normalizedNodePath = safeNormalizeFileUrl(nodePath, 'The "nodePath" option');
        const resolvedNodePath = external_node_path_namespaceObject.resolve(cwd, normalizedNodePath);
        const newOptions = {
            ...options,
            nodePath: resolvedNodePath,
            node: shouldHandleNode,
            cwd
        };
        if (!shouldHandleNode) return [
            file,
            commandArguments,
            newOptions
        ];
        if ('node' === external_node_path_namespaceObject.basename(file, '.exe')) throw new TypeError('When the "node" option is true, the first argument does not need to be "node".');
        return [
            resolvedNodePath,
            [
                ...nodeOptions,
                file,
                ...commandArguments
            ],
            {
                ipc: true,
                ...newOptions,
                shell: false
            }
        ];
    };
    const external_node_v8_namespaceObject = require("node:v8");
    const validateIpcInputOption = ({ ipcInput, ipc, serialization })=>{
        if (void 0 === ipcInput) return;
        if (!ipc) throw new Error('The `ipcInput` option cannot be set unless the `ipc` option is `true`.');
        validateIpcInput[serialization](ipcInput);
    };
    const validateAdvancedInput = (ipcInput)=>{
        try {
            (0, external_node_v8_namespaceObject.serialize)(ipcInput);
        } catch (error) {
            throw new Error('The `ipcInput` option is not serializable with a structured clone.', {
                cause: error
            });
        }
    };
    const validateJsonInput = (ipcInput)=>{
        try {
            JSON.stringify(ipcInput);
        } catch (error) {
            throw new Error('The `ipcInput` option is not serializable with JSON.', {
                cause: error
            });
        }
    };
    const validateIpcInput = {
        advanced: validateAdvancedInput,
        json: validateJsonInput
    };
    const sendIpcInput = async (subprocess, ipcInput)=>{
        if (void 0 === ipcInput) return;
        await subprocess.sendMessage(ipcInput);
    };
    const validateEncoding = ({ encoding })=>{
        if (ENCODINGS.has(encoding)) return;
        const correctEncoding = getCorrectEncoding(encoding);
        if (void 0 !== correctEncoding) throw new TypeError(`Invalid option \`encoding: ${serializeEncoding(encoding)}\`.
Please rename it to ${serializeEncoding(correctEncoding)}.`);
        const correctEncodings = [
            ...ENCODINGS
        ].map((correctEncoding)=>serializeEncoding(correctEncoding)).join(', ');
        throw new TypeError(`Invalid option \`encoding: ${serializeEncoding(encoding)}\`.
Please rename it to one of: ${correctEncodings}.`);
    };
    const TEXT_ENCODINGS = new Set([
        'utf8',
        'utf16le'
    ]);
    const BINARY_ENCODINGS = new Set([
        'buffer',
        'hex',
        'base64',
        'base64url',
        'latin1',
        'ascii'
    ]);
    const ENCODINGS = new Set([
        ...TEXT_ENCODINGS,
        ...BINARY_ENCODINGS
    ]);
    const getCorrectEncoding = (encoding)=>{
        if (null === encoding) return 'buffer';
        if ('string' != typeof encoding) return;
        const lowerEncoding = encoding.toLowerCase();
        if (lowerEncoding in ENCODING_ALIASES) return ENCODING_ALIASES[lowerEncoding];
        if (ENCODINGS.has(lowerEncoding)) return lowerEncoding;
    };
    const ENCODING_ALIASES = {
        'utf-8': 'utf8',
        'utf-16le': 'utf16le',
        'ucs-2': 'utf16le',
        ucs2: 'utf16le',
        binary: 'latin1'
    };
    const serializeEncoding = (encoding)=>'string' == typeof encoding ? `"${encoding}"` : String(encoding);
    const external_node_fs_namespaceObject = require("node:fs");
    const normalizeCwd = (cwd = getDefaultCwd())=>{
        const cwdString = safeNormalizeFileUrl(cwd, 'The "cwd" option');
        return external_node_path_namespaceObject.resolve(cwdString);
    };
    const getDefaultCwd = ()=>{
        try {
            return external_node_process_namespaceObject.cwd();
        } catch (error) {
            error.message = `The current directory does not exist.\n${error.message}`;
            throw error;
        }
    };
    const fixCwdError = (originalMessage, cwd)=>{
        if (cwd === getDefaultCwd()) return originalMessage;
        let cwdStat;
        try {
            cwdStat = (0, external_node_fs_namespaceObject.statSync)(cwd);
        } catch (error) {
            return `The "cwd" option is invalid: ${cwd}.\n${error.message}\n${originalMessage}`;
        }
        if (!cwdStat.isDirectory()) return `The "cwd" option is not a directory: ${cwd}.\n${originalMessage}`;
        return originalMessage;
    };
    const normalizeOptions = (filePath, rawArguments, rawOptions)=>{
        rawOptions.cwd = normalizeCwd(rawOptions.cwd);
        const [processedFile, processedArguments, processedOptions] = handleNodeOption(filePath, rawArguments, rawOptions);
        const { command: file, args: commandArguments, options: initialOptions } = cross_spawn._parse(processedFile, processedArguments, processedOptions);
        const fdOptions = normalizeFdSpecificOptions(initialOptions);
        const options = addDefaultOptions(fdOptions);
        validateTimeout(options);
        validateEncoding(options);
        validateIpcInputOption(options);
        validateCancelSignal(options);
        validateGracefulCancel(options);
        options.shell = normalizeFileUrl(options.shell);
        options.env = getEnv(options);
        options.killSignal = normalizeKillSignal(options.killSignal);
        options.forceKillAfterDelay = normalizeForceKillAfterDelay(options.forceKillAfterDelay);
        options.lines = options.lines.map((lines, fdNumber)=>lines && !BINARY_ENCODINGS.has(options.encoding) && options.buffer[fdNumber]);
        if ('win32' === external_node_process_namespaceObject.platform && 'cmd' === external_node_path_namespaceObject.basename(file, '.exe')) commandArguments.unshift('/q');
        return {
            file,
            commandArguments,
            options
        };
    };
    const addDefaultOptions = ({ extendEnv = true, preferLocal = false, cwd, localDir: localDirectory = cwd, encoding = 'utf8', reject = true, cleanup = true, all = false, windowsHide = true, killSignal = 'SIGTERM', forceKillAfterDelay = true, gracefulCancel = false, ipcInput, ipc = void 0 !== ipcInput || gracefulCancel, serialization = 'advanced', ...options })=>({
            ...options,
            extendEnv,
            preferLocal,
            cwd,
            localDirectory,
            encoding,
            reject,
            cleanup,
            all,
            windowsHide,
            killSignal,
            forceKillAfterDelay,
            gracefulCancel,
            ipcInput,
            ipc,
            serialization
        });
    const getEnv = ({ env: envOption, extendEnv, preferLocal, node, localDirectory, nodePath })=>{
        const env = extendEnv ? {
            ...external_node_process_namespaceObject.env,
            ...envOption
        } : envOption;
        if (preferLocal || node) return npmRunPathEnv({
            env,
            cwd: localDirectory,
            execPath: nodePath,
            preferLocal,
            addExecPath: node
        });
        return env;
    };
    const concatenateShell = (file, commandArguments, options)=>options.shell && commandArguments.length > 0 ? [
            [
                file,
                ...commandArguments
            ].join(' '),
            [],
            options
        ] : [
            file,
            commandArguments,
            options
        ];
    function strip_final_newline_stripFinalNewline(input) {
        if ('string' == typeof input) return stripFinalNewlineString(input);
        if (!(ArrayBuffer.isView(input) && 1 === input.BYTES_PER_ELEMENT)) throw new Error('Input must be a string or a Uint8Array');
        return stripFinalNewlineBinary(input);
    }
    const stripFinalNewlineString = (input)=>input.at(-1) === strip_final_newline_LF ? input.slice(0, input.at(-2) === CR ? -2 : -1) : input;
    const stripFinalNewlineBinary = (input)=>input.at(-1) === LF_BINARY ? input.subarray(0, input.at(-2) === CR_BINARY ? -2 : -1) : input;
    const strip_final_newline_LF = '\n';
    const LF_BINARY = strip_final_newline_LF.codePointAt(0);
    const CR = '\r';
    const CR_BINARY = CR.codePointAt(0);
    function isStream(stream, { checkOpen = true } = {}) {
        return null !== stream && 'object' == typeof stream && (stream.writable || stream.readable || !checkOpen || void 0 === stream.writable && void 0 === stream.readable) && 'function' == typeof stream.pipe;
    }
    function isWritableStream(stream, { checkOpen = true } = {}) {
        return isStream(stream, {
            checkOpen
        }) && (stream.writable || !checkOpen) && 'function' == typeof stream.write && 'function' == typeof stream.end && 'boolean' == typeof stream.writable && 'boolean' == typeof stream.writableObjectMode && 'function' == typeof stream.destroy && 'boolean' == typeof stream.destroyed;
    }
    function isReadableStream(stream, { checkOpen = true } = {}) {
        return isStream(stream, {
            checkOpen
        }) && (stream.readable || !checkOpen) && 'function' == typeof stream.read && 'boolean' == typeof stream.readable && 'boolean' == typeof stream.readableObjectMode && 'function' == typeof stream.destroy && 'boolean' == typeof stream.destroyed;
    }
    function isDuplexStream(stream, options) {
        return isWritableStream(stream, options) && isReadableStream(stream, options);
    }
    const asyncIterator_a = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);
    class asyncIterator_c {
        #t;
        #n;
        #r = !1;
        #e = void 0;
        constructor(e, t){
            this.#t = e, this.#n = t;
        }
        next() {
            const e = ()=>this.#s();
            return this.#e = this.#e ? this.#e.then(e, e) : e(), this.#e;
        }
        return(e) {
            const t = ()=>this.#i(e);
            return this.#e ? this.#e.then(t, t) : t();
        }
        async #s() {
            if (this.#r) return {
                done: !0,
                value: void 0
            };
            let e;
            try {
                e = await this.#t.read();
            } catch (t) {
                throw this.#e = void 0, this.#r = !0, this.#t.releaseLock(), t;
            }
            return e.done && (this.#e = void 0, this.#r = !0, this.#t.releaseLock()), e;
        }
        async #i(e) {
            if (this.#r) return {
                done: !0,
                value: e
            };
            if (this.#r = !0, !this.#n) {
                const t = this.#t.cancel(e);
                return this.#t.releaseLock(), await t, {
                    done: !0,
                    value: e
                };
            }
            return this.#t.releaseLock(), {
                done: !0,
                value: e
            };
        }
    }
    const asyncIterator_n = Symbol();
    function asyncIterator_i() {
        return this[asyncIterator_n].next();
    }
    Object.defineProperty(asyncIterator_i, "name", {
        value: "next"
    });
    function o(r) {
        return this[asyncIterator_n].return(r);
    }
    Object.defineProperty(o, "name", {
        value: "return"
    });
    const u = Object.create(asyncIterator_a, {
        next: {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: asyncIterator_i
        },
        return: {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: o
        }
    });
    function h({ preventCancel: r = !1 } = {}) {
        const e = this.getReader(), t = new asyncIterator_c(e, r), s = Object.create(u);
        return s[asyncIterator_n] = t, s;
    }
    const getAsyncIterable = (stream)=>{
        if (isReadableStream(stream, {
            checkOpen: false
        }) && void 0 !== nodeImports.on) return getStreamIterable(stream);
        if ('function' == typeof stream?.[Symbol.asyncIterator]) return stream;
        if ('[object ReadableStream]' === stream_toString.call(stream)) return h.call(stream);
        throw new TypeError('The first argument must be a Readable, a ReadableStream, or an async iterable.');
    };
    const { toString: stream_toString } = Object.prototype;
    const getStreamIterable = async function*(stream) {
        const controller = new AbortController();
        const state = {};
        handleStreamEnd(stream, controller, state);
        try {
            for await (const [chunk] of nodeImports.on(stream, 'data', {
                signal: controller.signal
            }))yield chunk;
        } catch (error) {
            if (void 0 !== state.error) throw state.error;
            if (!controller.signal.aborted) throw error;
        } finally{
            stream.destroy();
        }
    };
    const handleStreamEnd = async (stream, controller, state)=>{
        try {
            await nodeImports.finished(stream, {
                cleanup: true,
                readable: true,
                writable: false,
                error: false
            });
        } catch (error) {
            state.error = error;
        } finally{
            controller.abort();
        }
    };
    const nodeImports = {};
    const getStreamContents = async (stream, { init, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize }, { maxBuffer = 1 / 0 } = {})=>{
        const asyncIterable = getAsyncIterable(stream);
        const state = init();
        state.length = 0;
        try {
            for await (const chunk of asyncIterable){
                const chunkType = getChunkType(chunk);
                const convertedChunk = convertChunk[chunkType](chunk, state);
                appendChunk({
                    convertedChunk,
                    state,
                    getSize,
                    truncateChunk,
                    addChunk,
                    maxBuffer
                });
            }
            appendFinalChunk({
                state,
                convertChunk,
                getSize,
                truncateChunk,
                addChunk,
                getFinalChunk,
                maxBuffer
            });
            return finalize(state);
        } catch (error) {
            const normalizedError = 'object' == typeof error && null !== error ? error : new Error(error);
            normalizedError.bufferedData = finalize(state);
            throw normalizedError;
        }
    };
    const appendFinalChunk = ({ state, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer })=>{
        const convertedChunk = getFinalChunk(state);
        if (void 0 !== convertedChunk) appendChunk({
            convertedChunk,
            state,
            getSize,
            truncateChunk,
            addChunk,
            maxBuffer
        });
    };
    const appendChunk = ({ convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer })=>{
        const chunkSize = getSize(convertedChunk);
        const newLength = state.length + chunkSize;
        if (newLength <= maxBuffer) return void addNewChunk(convertedChunk, state, addChunk, newLength);
        const truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);
        if (void 0 !== truncatedChunk) addNewChunk(truncatedChunk, state, addChunk, maxBuffer);
        throw new MaxBufferError();
    };
    const addNewChunk = (convertedChunk, state, addChunk, newLength)=>{
        state.contents = addChunk(convertedChunk, state, newLength);
        state.length = newLength;
    };
    const getChunkType = (chunk)=>{
        const typeOfChunk = typeof chunk;
        if ('string' === typeOfChunk) return 'string';
        if ('object' !== typeOfChunk || null === chunk) return 'others';
        if (globalThis.Buffer?.isBuffer(chunk)) return 'buffer';
        const prototypeName = contents_objectToString.call(chunk);
        if ('[object ArrayBuffer]' === prototypeName) return 'arrayBuffer';
        if ('[object DataView]' === prototypeName) return 'dataView';
        if (Number.isInteger(chunk.byteLength) && Number.isInteger(chunk.byteOffset) && '[object ArrayBuffer]' === contents_objectToString.call(chunk.buffer)) return 'typedArray';
        return 'others';
    };
    const { toString: contents_objectToString } = Object.prototype;
    class MaxBufferError extends Error {
        name = 'MaxBufferError';
        constructor(){
            super('maxBuffer exceeded');
        }
    }
    const handleMaxBuffer = ({ error, stream, readableObjectMode, lines, encoding, fdNumber })=>{
        if (!(error instanceof MaxBufferError)) throw error;
        if ('all' === fdNumber) return error;
        const unit = getMaxBufferUnit(readableObjectMode, lines, encoding);
        error.maxBufferInfo = {
            fdNumber,
            unit
        };
        stream.destroy();
        throw error;
    };
    const getMaxBufferUnit = (readableObjectMode, lines, encoding)=>{
        if (readableObjectMode) return 'objects';
        if (lines) return 'lines';
        if ('buffer' === encoding) return 'bytes';
        return 'characters';
    };
    const checkIpcMaxBuffer = (subprocess, ipcOutput, maxBuffer)=>{
        if (ipcOutput.length !== maxBuffer) return;
        const error = new MaxBufferError();
        error.maxBufferInfo = {
            fdNumber: 'ipc'
        };
        throw error;
    };
    const getMaxBufferMessage = (error, maxBuffer)=>{
        const { streamName, threshold, unit } = getMaxBufferInfo(error, maxBuffer);
        return `Command's ${streamName} was larger than ${threshold} ${unit}`;
    };
    const getMaxBufferInfo = (error, maxBuffer)=>{
        if (error?.maxBufferInfo === void 0) return {
            streamName: 'output',
            threshold: maxBuffer[1],
            unit: 'bytes'
        };
        const { maxBufferInfo: { fdNumber, unit } } = error;
        delete error.maxBufferInfo;
        const threshold = getFdSpecificValue(maxBuffer, fdNumber);
        if ('ipc' === fdNumber) return {
            streamName: 'IPC output',
            threshold,
            unit: 'messages'
        };
        return {
            streamName: getStreamName(fdNumber),
            threshold,
            unit
        };
    };
    const isMaxBufferSync = (resultError, output, maxBuffer)=>resultError?.code === 'ENOBUFS' && null !== output && output.some((result)=>null !== result && result.length > getMaxBufferSync(maxBuffer));
    const truncateMaxBufferSync = (result, isMaxBuffer, maxBuffer)=>{
        if (!isMaxBuffer) return result;
        const maxBufferValue = getMaxBufferSync(maxBuffer);
        return result.length > maxBufferValue ? result.slice(0, maxBufferValue) : result;
    };
    const getMaxBufferSync = ([, stdoutMaxBuffer])=>stdoutMaxBuffer;
    const createMessages = ({ stdio, all, ipcOutput, originalError, signal, signalDescription, exitCode, escapedCommand, timedOut, isCanceled, isGracefullyCanceled, isMaxBuffer, isForcefullyTerminated, forceKillAfterDelay, killSignal, maxBuffer, timeout, cwd })=>{
        const errorCode = originalError?.code;
        const prefix = getErrorPrefix({
            originalError,
            timedOut,
            timeout,
            isMaxBuffer,
            maxBuffer,
            errorCode,
            signal,
            signalDescription,
            exitCode,
            isCanceled,
            isGracefullyCanceled,
            isForcefullyTerminated,
            forceKillAfterDelay,
            killSignal
        });
        const originalMessage = getOriginalMessage(originalError, cwd);
        const suffix = void 0 === originalMessage ? '' : `\n${originalMessage}`;
        const shortMessage = `${prefix}: ${escapedCommand}${suffix}`;
        const messageStdio = void 0 === all ? [
            stdio[2],
            stdio[1]
        ] : [
            all
        ];
        const message = [
            shortMessage,
            ...messageStdio,
            ...stdio.slice(3),
            ipcOutput.map((ipcMessage)=>serializeIpcMessage(ipcMessage)).join('\n')
        ].map((messagePart)=>escapeLines(strip_final_newline_stripFinalNewline(serializeMessagePart(messagePart)))).filter(Boolean).join('\n\n');
        return {
            originalMessage,
            shortMessage,
            message
        };
    };
    const getErrorPrefix = ({ originalError, timedOut, timeout, isMaxBuffer, maxBuffer, errorCode, signal, signalDescription, exitCode, isCanceled, isGracefullyCanceled, isForcefullyTerminated, forceKillAfterDelay, killSignal })=>{
        const forcefulSuffix = getForcefulSuffix(isForcefullyTerminated, forceKillAfterDelay);
        if (timedOut) return `Command timed out after ${timeout} milliseconds${forcefulSuffix}`;
        if (isGracefullyCanceled) {
            if (void 0 === signal) return `Command was gracefully canceled with exit code ${exitCode}`;
            return isForcefullyTerminated ? `Command was gracefully canceled${forcefulSuffix}` : `Command was gracefully canceled with ${signal} (${signalDescription})`;
        }
        if (isCanceled) return `Command was canceled${forcefulSuffix}`;
        if (isMaxBuffer) return `${getMaxBufferMessage(originalError, maxBuffer)}${forcefulSuffix}`;
        if (void 0 !== errorCode) return `Command failed with ${errorCode}${forcefulSuffix}`;
        if (isForcefullyTerminated) return `Command was killed with ${killSignal} (${getSignalDescription(killSignal)})${forcefulSuffix}`;
        if (void 0 !== signal) return `Command was killed with ${signal} (${signalDescription})`;
        if (void 0 !== exitCode) return `Command failed with exit code ${exitCode}`;
        return 'Command failed';
    };
    const getForcefulSuffix = (isForcefullyTerminated, forceKillAfterDelay)=>isForcefullyTerminated ? ` and was forcefully terminated after ${forceKillAfterDelay} milliseconds` : '';
    const getOriginalMessage = (originalError, cwd)=>{
        if (originalError instanceof DiscardedError) return;
        const originalMessage = isExecaError(originalError) ? originalError.originalMessage : String(originalError?.message ?? originalError);
        const escapedOriginalMessage = escapeLines(fixCwdError(originalMessage, cwd));
        return '' === escapedOriginalMessage ? void 0 : escapedOriginalMessage;
    };
    const serializeIpcMessage = (ipcMessage)=>'string' == typeof ipcMessage ? ipcMessage : (0, external_node_util_.inspect)(ipcMessage);
    const serializeMessagePart = (messagePart)=>Array.isArray(messagePart) ? messagePart.map((messageItem)=>strip_final_newline_stripFinalNewline(serializeMessageItem(messageItem))).filter(Boolean).join('\n') : serializeMessageItem(messagePart);
    const serializeMessageItem = (messageItem)=>{
        if ('string' == typeof messageItem) return messageItem;
        if (isUint8Array(messageItem)) return uint8ArrayToString(messageItem);
        return '';
    };
    const makeSuccessResult = ({ command, escapedCommand, stdio, all, ipcOutput, options: { cwd }, startTime })=>omitUndefinedProperties({
            command,
            escapedCommand,
            cwd,
            durationMs: getDurationMs(startTime),
            failed: false,
            timedOut: false,
            isCanceled: false,
            isGracefullyCanceled: false,
            isTerminated: false,
            isMaxBuffer: false,
            isForcefullyTerminated: false,
            exitCode: 0,
            stdout: stdio[1],
            stderr: stdio[2],
            all,
            stdio,
            ipcOutput,
            pipedFrom: []
        });
    const makeEarlyError = ({ error, command, escapedCommand, fileDescriptors, options, startTime, isSync })=>makeError({
            error,
            command,
            escapedCommand,
            startTime,
            timedOut: false,
            isCanceled: false,
            isGracefullyCanceled: false,
            isMaxBuffer: false,
            isForcefullyTerminated: false,
            stdio: Array.from({
                length: fileDescriptors.length
            }),
            ipcOutput: [],
            options,
            isSync
        });
    const makeError = ({ error: originalError, command, escapedCommand, startTime, timedOut, isCanceled, isGracefullyCanceled, isMaxBuffer, isForcefullyTerminated, exitCode: rawExitCode, signal: rawSignal, stdio, all, ipcOutput, options: { timeoutDuration, timeout = timeoutDuration, forceKillAfterDelay, killSignal, cwd, maxBuffer }, isSync })=>{
        const { exitCode, signal, signalDescription } = normalizeExitPayload(rawExitCode, rawSignal);
        const { originalMessage, shortMessage, message } = createMessages({
            stdio,
            all,
            ipcOutput,
            originalError,
            signal,
            signalDescription,
            exitCode,
            escapedCommand,
            timedOut,
            isCanceled,
            isGracefullyCanceled,
            isMaxBuffer,
            isForcefullyTerminated,
            forceKillAfterDelay,
            killSignal,
            maxBuffer,
            timeout,
            cwd
        });
        const error = getFinalError(originalError, message, isSync);
        Object.assign(error, getErrorProperties({
            error,
            command,
            escapedCommand,
            startTime,
            timedOut,
            isCanceled,
            isGracefullyCanceled,
            isMaxBuffer,
            isForcefullyTerminated,
            exitCode,
            signal,
            signalDescription,
            stdio,
            all,
            ipcOutput,
            cwd,
            originalMessage,
            shortMessage
        }));
        return error;
    };
    const getErrorProperties = ({ error, command, escapedCommand, startTime, timedOut, isCanceled, isGracefullyCanceled, isMaxBuffer, isForcefullyTerminated, exitCode, signal, signalDescription, stdio, all, ipcOutput, cwd, originalMessage, shortMessage })=>omitUndefinedProperties({
            shortMessage,
            originalMessage,
            command,
            escapedCommand,
            cwd,
            durationMs: getDurationMs(startTime),
            failed: true,
            timedOut,
            isCanceled,
            isGracefullyCanceled,
            isTerminated: void 0 !== signal,
            isMaxBuffer,
            isForcefullyTerminated,
            exitCode,
            signal,
            signalDescription,
            code: error.cause?.code,
            stdout: stdio[1],
            stderr: stdio[2],
            all,
            stdio,
            ipcOutput,
            pipedFrom: []
        });
    const omitUndefinedProperties = (result)=>Object.fromEntries(Object.entries(result).filter(([, value])=>void 0 !== value));
    const normalizeExitPayload = (rawExitCode, rawSignal)=>{
        const exitCode = null === rawExitCode ? void 0 : rawExitCode;
        const signal = null === rawSignal ? void 0 : rawSignal;
        const signalDescription = void 0 === signal ? void 0 : getSignalDescription(rawSignal);
        return {
            exitCode,
            signal,
            signalDescription
        };
    };
    const toZeroIfInfinity = (value)=>Number.isFinite(value) ? value : 0;
    function parseNumber(milliseconds) {
        return {
            days: Math.trunc(milliseconds / 86400000),
            hours: Math.trunc(milliseconds / 3600000 % 24),
            minutes: Math.trunc(milliseconds / 60000 % 60),
            seconds: Math.trunc(milliseconds / 1000 % 60),
            milliseconds: Math.trunc(milliseconds % 1000),
            microseconds: Math.trunc(toZeroIfInfinity(1000 * milliseconds) % 1000),
            nanoseconds: Math.trunc(toZeroIfInfinity(1e6 * milliseconds) % 1000)
        };
    }
    function parseBigint(milliseconds) {
        return {
            days: milliseconds / 86400000n,
            hours: milliseconds / 3600000n % 24n,
            minutes: milliseconds / 60000n % 60n,
            seconds: milliseconds / 1000n % 60n,
            milliseconds: milliseconds % 1000n,
            microseconds: 0n,
            nanoseconds: 0n
        };
    }
    function parseMilliseconds(milliseconds) {
        switch(typeof milliseconds){
            case 'number':
                if (Number.isFinite(milliseconds)) return parseNumber(milliseconds);
                break;
            case 'bigint':
                return parseBigint(milliseconds);
        }
        throw new TypeError('Expected a finite number or bigint');
    }
    const isZero = (value)=>0 === value || 0n === value;
    const pluralize = (word, count)=>1 === count || 1n === count ? word : `${word}s`;
    const SECOND_ROUNDING_EPSILON = 0.0000001;
    const ONE_DAY_IN_MILLISECONDS = 24n * 60n * 60n * 1000n;
    function prettyMilliseconds(milliseconds, options) {
        const isBigInt = 'bigint' == typeof milliseconds;
        if (!isBigInt && !Number.isFinite(milliseconds)) throw new TypeError('Expected a finite number or bigint');
        options = {
            ...options
        };
        const sign = milliseconds < 0 ? '-' : '';
        milliseconds = milliseconds < 0 ? -milliseconds : milliseconds;
        if (options.colonNotation) {
            options.compact = false;
            options.formatSubMilliseconds = false;
            options.separateMilliseconds = false;
            options.verbose = false;
        }
        if (options.compact) {
            options.unitCount = 1;
            options.secondsDecimalDigits = 0;
            options.millisecondsDecimalDigits = 0;
        }
        let result = [];
        const floorDecimals = (value, decimalDigits)=>{
            const flooredInterimValue = Math.floor(value * 10 ** decimalDigits + SECOND_ROUNDING_EPSILON);
            const flooredValue = Math.round(flooredInterimValue) / 10 ** decimalDigits;
            return flooredValue.toFixed(decimalDigits);
        };
        const add = (value, long, short, valueString)=>{
            if ((0 === result.length || !options.colonNotation) && isZero(value) && !(options.colonNotation && 'm' === short)) return;
            valueString ??= String(value);
            if (options.colonNotation) {
                const wholeDigits = valueString.includes('.') ? valueString.split('.')[0].length : valueString.length;
                const minLength = result.length > 0 ? 2 : 1;
                valueString = '0'.repeat(Math.max(0, minLength - wholeDigits)) + valueString;
            } else valueString += options.verbose ? ' ' + pluralize(long, value) : short;
            result.push(valueString);
        };
        const parsed = parseMilliseconds(milliseconds);
        const days = BigInt(parsed.days);
        if (options.hideYearAndDays) add(24n * BigInt(days) + BigInt(parsed.hours), 'hour', 'h');
        else {
            if (options.hideYear) add(days, 'day', 'd');
            else {
                add(days / 365n, 'year', 'y');
                add(days % 365n, 'day', 'd');
            }
            add(Number(parsed.hours), 'hour', 'h');
        }
        add(Number(parsed.minutes), 'minute', 'm');
        if (!options.hideSeconds) if (options.separateMilliseconds || options.formatSubMilliseconds || !options.colonNotation && milliseconds < 1000) {
            const seconds = Number(parsed.seconds);
            const milliseconds = Number(parsed.milliseconds);
            const microseconds = Number(parsed.microseconds);
            const nanoseconds = Number(parsed.nanoseconds);
            add(seconds, 'second', 's');
            if (options.formatSubMilliseconds) {
                add(milliseconds, 'millisecond', 'ms');
                add(microseconds, 'microsecond', 's');
                add(nanoseconds, 'nanosecond', 'ns');
            } else {
                const millisecondsAndBelow = milliseconds + microseconds / 1000 + nanoseconds / 1e6;
                const millisecondsDecimalDigits = 'number' == typeof options.millisecondsDecimalDigits ? options.millisecondsDecimalDigits : 0;
                const roundedMilliseconds = millisecondsAndBelow >= 1 ? Math.round(millisecondsAndBelow) : Math.ceil(millisecondsAndBelow);
                const millisecondsString = millisecondsDecimalDigits ? millisecondsAndBelow.toFixed(millisecondsDecimalDigits) : roundedMilliseconds;
                add(Number.parseFloat(millisecondsString), 'millisecond', 'ms', millisecondsString);
            }
        } else {
            const seconds = (isBigInt ? Number(milliseconds % ONE_DAY_IN_MILLISECONDS) : milliseconds) / 1000 % 60;
            const secondsDecimalDigits = 'number' == typeof options.secondsDecimalDigits ? options.secondsDecimalDigits : 1;
            const secondsFixed = floorDecimals(seconds, secondsDecimalDigits);
            const secondsString = options.keepDecimalsOnWholeSeconds ? secondsFixed : secondsFixed.replace(/\.0+$/, '');
            add(Number.parseFloat(secondsString), 'second', 's', secondsString);
        }
        if (0 === result.length) return sign + '0' + (options.verbose ? ' milliseconds' : 'ms');
        const separator = options.colonNotation ? ':' : ' ';
        if ('number' == typeof options.unitCount) result = result.slice(0, Math.max(options.unitCount, 1));
        return sign + result.join(separator);
    }
    const logError = (result, verboseInfo)=>{
        if (result.failed) verboseLog({
            type: 'error',
            verboseMessage: result.shortMessage,
            verboseInfo,
            result
        });
    };
    const logResult = (result, verboseInfo)=>{
        if (!values_isVerbose(verboseInfo)) return;
        logError(result, verboseInfo);
        logDuration(result, verboseInfo);
    };
    const logDuration = (result, verboseInfo)=>{
        const verboseMessage = `(done in ${prettyMilliseconds(result.durationMs)})`;
        verboseLog({
            type: 'duration',
            verboseMessage,
            verboseInfo,
            result
        });
    };
    const reject_handleResult = (result, verboseInfo, { reject })=>{
        logResult(result, verboseInfo);
        if (result.failed && reject) throw result;
        return result;
    };
    const getStdioItemType = (value, optionName)=>{
        if (isAsyncGenerator(value)) return 'asyncGenerator';
        if (isSyncGenerator(value)) return 'generator';
        if (isUrl(value)) return 'fileUrl';
        if (isFilePathObject(value)) return 'filePath';
        if (isWebStream(value)) return 'webStream';
        if (isStream(value, {
            checkOpen: false
        })) return 'native';
        if (isUint8Array(value)) return 'uint8Array';
        if (isAsyncIterableObject(value)) return 'asyncIterable';
        if (isIterableObject(value)) return 'iterable';
        if (type_isTransformStream(value)) return getTransformStreamType({
            transform: value
        }, optionName);
        if (isTransformOptions(value)) return getTransformObjectType(value, optionName);
        return 'native';
    };
    const getTransformObjectType = (value, optionName)=>{
        if (isDuplexStream(value.transform, {
            checkOpen: false
        })) return getDuplexType(value, optionName);
        if (type_isTransformStream(value.transform)) return getTransformStreamType(value, optionName);
        return getGeneratorObjectType(value, optionName);
    };
    const getDuplexType = (value, optionName)=>{
        validateNonGeneratorType(value, optionName, 'Duplex stream');
        return 'duplex';
    };
    const getTransformStreamType = (value, optionName)=>{
        validateNonGeneratorType(value, optionName, 'web TransformStream');
        return 'webTransform';
    };
    const validateNonGeneratorType = ({ final, binary, objectMode }, optionName, typeName)=>{
        checkUndefinedOption(final, `${optionName}.final`, typeName);
        checkUndefinedOption(binary, `${optionName}.binary`, typeName);
        checkBooleanOption(objectMode, `${optionName}.objectMode`);
    };
    const checkUndefinedOption = (value, optionName, typeName)=>{
        if (void 0 !== value) throw new TypeError(`The \`${optionName}\` option can only be defined when using a generator, not a ${typeName}.`);
    };
    const getGeneratorObjectType = ({ transform, final, binary, objectMode }, optionName)=>{
        if (void 0 !== transform && !isGenerator(transform)) throw new TypeError(`The \`${optionName}.transform\` option must be a generator, a Duplex stream or a web TransformStream.`);
        if (isDuplexStream(final, {
            checkOpen: false
        })) throw new TypeError(`The \`${optionName}.final\` option must not be a Duplex stream.`);
        if (type_isTransformStream(final)) throw new TypeError(`The \`${optionName}.final\` option must not be a web TransformStream.`);
        if (void 0 !== final && !isGenerator(final)) throw new TypeError(`The \`${optionName}.final\` option must be a generator.`);
        checkBooleanOption(binary, `${optionName}.binary`);
        checkBooleanOption(objectMode, `${optionName}.objectMode`);
        return isAsyncGenerator(transform) || isAsyncGenerator(final) ? 'asyncGenerator' : 'generator';
    };
    const checkBooleanOption = (value, optionName)=>{
        if (void 0 !== value && 'boolean' != typeof value) throw new TypeError(`The \`${optionName}\` option must use a boolean.`);
    };
    const isGenerator = (value)=>isAsyncGenerator(value) || isSyncGenerator(value);
    const isAsyncGenerator = (value)=>'[object AsyncGeneratorFunction]' === Object.prototype.toString.call(value);
    const isSyncGenerator = (value)=>'[object GeneratorFunction]' === Object.prototype.toString.call(value);
    const isTransformOptions = (value)=>isPlainObject(value) && (void 0 !== value.transform || void 0 !== value.final);
    const isUrl = (value)=>'[object URL]' === Object.prototype.toString.call(value);
    const isRegularUrl = (value)=>isUrl(value) && 'file:' !== value.protocol;
    const isFilePathObject = (value)=>isPlainObject(value) && Object.keys(value).length > 0 && Object.keys(value).every((key)=>FILE_PATH_KEYS.has(key)) && isFilePathString(value.file);
    const FILE_PATH_KEYS = new Set([
        'file',
        'append'
    ]);
    const isFilePathString = (file)=>'string' == typeof file;
    const isUnknownStdioString = (type, value)=>'native' === type && 'string' == typeof value && !KNOWN_STDIO_STRINGS.has(value);
    const KNOWN_STDIO_STRINGS = new Set([
        'ipc',
        'ignore',
        'inherit',
        'overlapped',
        'pipe'
    ]);
    const type_isReadableStream = (value)=>'[object ReadableStream]' === Object.prototype.toString.call(value);
    const type_isWritableStream = (value)=>'[object WritableStream]' === Object.prototype.toString.call(value);
    const isWebStream = (value)=>type_isReadableStream(value) || type_isWritableStream(value);
    const type_isTransformStream = (value)=>type_isReadableStream(value?.readable) && type_isWritableStream(value?.writable);
    const isAsyncIterableObject = (value)=>isObject(value) && 'function' == typeof value[Symbol.asyncIterator];
    const isIterableObject = (value)=>isObject(value) && 'function' == typeof value[Symbol.iterator];
    const isObject = (value)=>'object' == typeof value && null !== value;
    const TRANSFORM_TYPES = new Set([
        'generator',
        'asyncGenerator',
        'duplex',
        'webTransform'
    ]);
    const FILE_TYPES = new Set([
        'fileUrl',
        'filePath',
        'fileNumber'
    ]);
    const SPECIAL_DUPLICATE_TYPES_SYNC = new Set([
        'fileUrl',
        'filePath'
    ]);
    const SPECIAL_DUPLICATE_TYPES = new Set([
        ...SPECIAL_DUPLICATE_TYPES_SYNC,
        'webStream',
        'nodeStream'
    ]);
    const FORBID_DUPLICATE_TYPES = new Set([
        'webTransform',
        'duplex'
    ]);
    const TYPE_TO_MESSAGE = {
        generator: 'a generator',
        asyncGenerator: 'an async generator',
        fileUrl: 'a file URL',
        filePath: 'a file path string',
        fileNumber: "a file descriptor number",
        webStream: 'a web stream',
        nodeStream: 'a Node.js stream',
        webTransform: 'a web TransformStream',
        duplex: 'a Duplex stream',
        native: 'any value',
        iterable: 'an iterable',
        asyncIterable: 'an async iterable',
        string: 'a string',
        uint8Array: 'a Uint8Array'
    };
    const getTransformObjectModes = (objectMode, index, newTransforms, direction)=>'output' === direction ? getOutputObjectModes(objectMode, index, newTransforms) : getInputObjectModes(objectMode, index, newTransforms);
    const getOutputObjectModes = (objectMode, index, newTransforms)=>{
        const writableObjectMode = 0 !== index && newTransforms[index - 1].value.readableObjectMode;
        const readableObjectMode = objectMode ?? writableObjectMode;
        return {
            writableObjectMode,
            readableObjectMode
        };
    };
    const getInputObjectModes = (objectMode, index, newTransforms)=>{
        const writableObjectMode = 0 === index ? true === objectMode : newTransforms[index - 1].value.readableObjectMode;
        const readableObjectMode = index !== newTransforms.length - 1 && (objectMode ?? writableObjectMode);
        return {
            writableObjectMode,
            readableObjectMode
        };
    };
    const getFdObjectMode = (stdioItems, direction)=>{
        const lastTransform = stdioItems.findLast(({ type })=>TRANSFORM_TYPES.has(type));
        if (void 0 === lastTransform) return false;
        return 'input' === direction ? lastTransform.value.writableObjectMode : lastTransform.value.readableObjectMode;
    };
    const normalizeTransforms = (stdioItems, optionName, direction, options)=>[
            ...stdioItems.filter(({ type })=>!TRANSFORM_TYPES.has(type)),
            ...getTransforms(stdioItems, optionName, direction, options)
        ];
    const getTransforms = (stdioItems, optionName, direction, { encoding })=>{
        const transforms = stdioItems.filter(({ type })=>TRANSFORM_TYPES.has(type));
        const newTransforms = Array.from({
            length: transforms.length
        });
        for (const [index, stdioItem] of Object.entries(transforms))newTransforms[index] = normalizeTransform({
            stdioItem,
            index: Number(index),
            newTransforms,
            optionName,
            direction,
            encoding
        });
        return sortTransforms(newTransforms, direction);
    };
    const normalizeTransform = ({ stdioItem, stdioItem: { type }, index, newTransforms, optionName, direction, encoding })=>{
        if ('duplex' === type) return normalizeDuplex({
            stdioItem,
            optionName
        });
        if ('webTransform' === type) return normalizeTransformStream({
            stdioItem,
            index,
            newTransforms,
            direction
        });
        return normalizeGenerator({
            stdioItem,
            index,
            newTransforms,
            direction,
            encoding
        });
    };
    const normalizeDuplex = ({ stdioItem, stdioItem: { value: { transform, transform: { writableObjectMode, readableObjectMode }, objectMode = readableObjectMode } }, optionName })=>{
        if (objectMode && !readableObjectMode) throw new TypeError(`The \`${optionName}.objectMode\` option can only be \`true\` if \`new Duplex({objectMode: true})\` is used.`);
        if (!objectMode && readableObjectMode) throw new TypeError(`The \`${optionName}.objectMode\` option cannot be \`false\` if \`new Duplex({objectMode: true})\` is used.`);
        return {
            ...stdioItem,
            value: {
                transform,
                writableObjectMode,
                readableObjectMode
            }
        };
    };
    const normalizeTransformStream = ({ stdioItem, stdioItem: { value }, index, newTransforms, direction })=>{
        const { transform, objectMode } = isPlainObject(value) ? value : {
            transform: value
        };
        const { writableObjectMode, readableObjectMode } = getTransformObjectModes(objectMode, index, newTransforms, direction);
        return {
            ...stdioItem,
            value: {
                transform,
                writableObjectMode,
                readableObjectMode
            }
        };
    };
    const normalizeGenerator = ({ stdioItem, stdioItem: { value }, index, newTransforms, direction, encoding })=>{
        const { transform, final, binary: binaryOption = false, preserveNewlines = false, objectMode } = isPlainObject(value) ? value : {
            transform: value
        };
        const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
        const { writableObjectMode, readableObjectMode } = getTransformObjectModes(objectMode, index, newTransforms, direction);
        return {
            ...stdioItem,
            value: {
                transform,
                final,
                binary,
                preserveNewlines,
                writableObjectMode,
                readableObjectMode
            }
        };
    };
    const sortTransforms = (newTransforms, direction)=>'input' === direction ? newTransforms.reverse() : newTransforms;
    const getStreamDirection = (stdioItems, fdNumber, optionName)=>{
        const directions = stdioItems.map((stdioItem)=>getStdioItemDirection(stdioItem, fdNumber));
        if (directions.includes('input') && directions.includes('output')) throw new TypeError(`The \`${optionName}\` option must not be an array of both readable and writable values.`);
        return directions.find(Boolean) ?? DEFAULT_DIRECTION;
    };
    const getStdioItemDirection = ({ type, value }, fdNumber)=>KNOWN_DIRECTIONS[fdNumber] ?? guessStreamDirection[type](value);
    const KNOWN_DIRECTIONS = [
        'input',
        'output',
        'output'
    ];
    const anyDirection = ()=>void 0;
    const alwaysInput = ()=>'input';
    const guessStreamDirection = {
        generator: anyDirection,
        asyncGenerator: anyDirection,
        fileUrl: anyDirection,
        filePath: anyDirection,
        iterable: alwaysInput,
        asyncIterable: alwaysInput,
        uint8Array: alwaysInput,
        webStream: (value)=>type_isWritableStream(value) ? 'output' : 'input',
        nodeStream (value) {
            if (!isReadableStream(value, {
                checkOpen: false
            })) return 'output';
            return isWritableStream(value, {
                checkOpen: false
            }) ? void 0 : 'input';
        },
        webTransform: anyDirection,
        duplex: anyDirection,
        native (value) {
            const standardStreamDirection = getStandardStreamDirection(value);
            if (void 0 !== standardStreamDirection) return standardStreamDirection;
            if (isStream(value, {
                checkOpen: false
            })) return guessStreamDirection.nodeStream(value);
        }
    };
    const getStandardStreamDirection = (value)=>{
        if ([
            0,
            external_node_process_namespaceObject.stdin
        ].includes(value)) return 'input';
        if ([
            1,
            2,
            external_node_process_namespaceObject.stdout,
            external_node_process_namespaceObject.stderr
        ].includes(value)) return 'output';
    };
    const DEFAULT_DIRECTION = 'output';
    const normalizeIpcStdioArray = (stdioArray, ipc)=>ipc && !stdioArray.includes('ipc') ? [
            ...stdioArray,
            'ipc'
        ] : stdioArray;
    const normalizeStdioOption = ({ stdio, ipc, buffer, ...options }, verboseInfo, isSync)=>{
        const stdioArray = getStdioArray(stdio, options).map((stdioOption, fdNumber)=>stdio_option_addDefaultValue(stdioOption, fdNumber));
        return isSync ? normalizeStdioSync(stdioArray, buffer, verboseInfo) : normalizeIpcStdioArray(stdioArray, ipc);
    };
    const getStdioArray = (stdio, options)=>{
        if (void 0 === stdio) return STANDARD_STREAMS_ALIASES.map((alias)=>options[alias]);
        if (hasAlias(options)) throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${STANDARD_STREAMS_ALIASES.map((alias)=>`\`${alias}\``).join(', ')}`);
        if ('string' == typeof stdio) return [
            stdio,
            stdio,
            stdio
        ];
        if (!Array.isArray(stdio)) throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
        const length = Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length);
        return Array.from({
            length
        }, (_, fdNumber)=>stdio[fdNumber]);
    };
    const hasAlias = (options)=>STANDARD_STREAMS_ALIASES.some((alias)=>void 0 !== options[alias]);
    const stdio_option_addDefaultValue = (stdioOption, fdNumber)=>{
        if (Array.isArray(stdioOption)) return stdioOption.map((item)=>stdio_option_addDefaultValue(item, fdNumber));
        if (null == stdioOption) return fdNumber >= STANDARD_STREAMS_ALIASES.length ? 'ignore' : 'pipe';
        return stdioOption;
    };
    const normalizeStdioSync = (stdioArray, buffer, verboseInfo)=>stdioArray.map((stdioOption, fdNumber)=>!buffer[fdNumber] && 0 !== fdNumber && !isFullVerbose(verboseInfo, fdNumber) && isOutputPipeOnly(stdioOption) ? 'ignore' : stdioOption);
    const isOutputPipeOnly = (stdioOption)=>'pipe' === stdioOption || Array.isArray(stdioOption) && stdioOption.every((item)=>'pipe' === item);
    const handleNativeStream = ({ stdioItem, stdioItem: { type }, isStdioArray, fdNumber, direction, isSync })=>{
        if (!isStdioArray || 'native' !== type) return stdioItem;
        return isSync ? handleNativeStreamSync({
            stdioItem,
            fdNumber,
            direction
        }) : handleNativeStreamAsync({
            stdioItem,
            fdNumber
        });
    };
    const handleNativeStreamSync = ({ stdioItem, stdioItem: { value, optionName }, fdNumber, direction })=>{
        const targetFd = getTargetFd({
            value,
            optionName,
            fdNumber,
            direction
        });
        if (void 0 !== targetFd) return targetFd;
        if (isStream(value, {
            checkOpen: false
        })) throw new TypeError(`The \`${optionName}: Stream\` option cannot both be an array and include a stream with synchronous methods.`);
        return stdioItem;
    };
    const getTargetFd = ({ value, optionName, fdNumber, direction })=>{
        const targetFdNumber = getTargetFdNumber(value, fdNumber);
        if (void 0 === targetFdNumber) return;
        if ('output' === direction) return {
            type: 'fileNumber',
            value: targetFdNumber,
            optionName
        };
        if (external_node_tty_namespaceObject.isatty(targetFdNumber)) throw new TypeError(`The \`${optionName}: ${serializeOptionValue(value)}\` option is invalid: it cannot be a TTY with synchronous methods.`);
        return {
            type: 'uint8Array',
            value: bufferToUint8Array((0, external_node_fs_namespaceObject.readFileSync)(targetFdNumber)),
            optionName
        };
    };
    const getTargetFdNumber = (value, fdNumber)=>{
        if ('inherit' === value) return fdNumber;
        if ('number' == typeof value) return value;
        const standardStreamIndex = STANDARD_STREAMS.indexOf(value);
        if (-1 !== standardStreamIndex) return standardStreamIndex;
    };
    const handleNativeStreamAsync = ({ stdioItem, stdioItem: { value, optionName }, fdNumber })=>{
        if ('inherit' === value) return {
            type: 'nodeStream',
            value: getStandardStream(fdNumber, value, optionName),
            optionName
        };
        if ('number' == typeof value) return {
            type: 'nodeStream',
            value: getStandardStream(value, value, optionName),
            optionName
        };
        if (isStream(value, {
            checkOpen: false
        })) return {
            type: 'nodeStream',
            value,
            optionName
        };
        return stdioItem;
    };
    const getStandardStream = (fdNumber, value, optionName)=>{
        const standardStream = STANDARD_STREAMS[fdNumber];
        if (void 0 === standardStream) throw new TypeError(`The \`${optionName}: ${value}\` option is invalid: no such standard stream.`);
        return standardStream;
    };
    const handleInputOptions = ({ input, inputFile }, fdNumber)=>0 === fdNumber ? [
            ...handleInputOption(input),
            ...handleInputFileOption(inputFile)
        ] : [];
    const handleInputOption = (input)=>void 0 === input ? [] : [
            {
                type: getInputType(input),
                value: input,
                optionName: 'input'
            }
        ];
    const getInputType = (input)=>{
        if (isReadableStream(input, {
            checkOpen: false
        })) return 'nodeStream';
        if ('string' == typeof input) return 'string';
        if (isUint8Array(input)) return 'uint8Array';
        throw new Error('The `input` option must be a string, a Uint8Array or a Node.js Readable stream.');
    };
    const handleInputFileOption = (inputFile)=>void 0 === inputFile ? [] : [
            {
                ...getInputFileType(inputFile),
                optionName: 'inputFile'
            }
        ];
    const getInputFileType = (inputFile)=>{
        if (isUrl(inputFile)) return {
            type: 'fileUrl',
            value: inputFile
        };
        if (isFilePathString(inputFile)) return {
            type: 'filePath',
            value: {
                file: inputFile
            }
        };
        throw new Error('The `inputFile` option must be a file path string or a file URL.');
    };
    const filterDuplicates = (stdioItems)=>stdioItems.filter((stdioItemOne, indexOne)=>stdioItems.every((stdioItemTwo, indexTwo)=>stdioItemOne.value !== stdioItemTwo.value || indexOne >= indexTwo || 'generator' === stdioItemOne.type || 'asyncGenerator' === stdioItemOne.type));
    const getDuplicateStream = ({ stdioItem: { type, value, optionName }, direction, fileDescriptors, isSync })=>{
        const otherStdioItems = getOtherStdioItems(fileDescriptors, type);
        if (0 === otherStdioItems.length) return;
        if (isSync) return void validateDuplicateStreamSync({
            otherStdioItems,
            type,
            value,
            optionName,
            direction
        });
        if (SPECIAL_DUPLICATE_TYPES.has(type)) return getDuplicateStreamInstance({
            otherStdioItems,
            type,
            value,
            optionName,
            direction
        });
        if (FORBID_DUPLICATE_TYPES.has(type)) validateDuplicateTransform({
            otherStdioItems,
            type,
            value,
            optionName
        });
    };
    const getOtherStdioItems = (fileDescriptors, type)=>fileDescriptors.flatMap(({ direction, stdioItems })=>stdioItems.filter((stdioItem)=>stdioItem.type === type).map((stdioItem)=>({
                    ...stdioItem,
                    direction
                })));
    const validateDuplicateStreamSync = ({ otherStdioItems, type, value, optionName, direction })=>{
        if (SPECIAL_DUPLICATE_TYPES_SYNC.has(type)) getDuplicateStreamInstance({
            otherStdioItems,
            type,
            value,
            optionName,
            direction
        });
    };
    const getDuplicateStreamInstance = ({ otherStdioItems, type, value, optionName, direction })=>{
        const duplicateStdioItems = otherStdioItems.filter((stdioItem)=>hasSameValue(stdioItem, value));
        if (0 === duplicateStdioItems.length) return;
        const differentStdioItem = duplicateStdioItems.find((stdioItem)=>stdioItem.direction !== direction);
        throwOnDuplicateStream(differentStdioItem, optionName, type);
        return 'output' === direction ? duplicateStdioItems[0].stream : void 0;
    };
    const hasSameValue = ({ type, value }, secondValue)=>{
        if ('filePath' === type) return value.file === secondValue.file;
        if ('fileUrl' === type) return value.href === secondValue.href;
        return value === secondValue;
    };
    const validateDuplicateTransform = ({ otherStdioItems, type, value, optionName })=>{
        const duplicateStdioItem = otherStdioItems.find(({ value: { transform } })=>transform === value.transform);
        throwOnDuplicateStream(duplicateStdioItem, optionName, type);
    };
    const throwOnDuplicateStream = (stdioItem, optionName, type)=>{
        if (void 0 !== stdioItem) throw new TypeError(`The \`${stdioItem.optionName}\` and \`${optionName}\` options must not target ${TYPE_TO_MESSAGE[type]} that is the same.`);
    };
    const handleStdio = (addProperties, options, verboseInfo, isSync)=>{
        const stdio = normalizeStdioOption(options, verboseInfo, isSync);
        const initialFileDescriptors = stdio.map((stdioOption, fdNumber)=>getFileDescriptor({
                stdioOption,
                fdNumber,
                options,
                isSync
            }));
        const fileDescriptors = getFinalFileDescriptors({
            initialFileDescriptors,
            addProperties,
            options,
            isSync
        });
        options.stdio = fileDescriptors.map(({ stdioItems })=>forwardStdio(stdioItems));
        return fileDescriptors;
    };
    const getFileDescriptor = ({ stdioOption, fdNumber, options, isSync })=>{
        const optionName = getStreamName(fdNumber);
        const { stdioItems: initialStdioItems, isStdioArray } = initializeStdioItems({
            stdioOption,
            fdNumber,
            options,
            optionName
        });
        const direction = getStreamDirection(initialStdioItems, fdNumber, optionName);
        const stdioItems = initialStdioItems.map((stdioItem)=>handleNativeStream({
                stdioItem,
                isStdioArray,
                fdNumber,
                direction,
                isSync
            }));
        const normalizedStdioItems = normalizeTransforms(stdioItems, optionName, direction, options);
        const objectMode = getFdObjectMode(normalizedStdioItems, direction);
        validateFileObjectMode(normalizedStdioItems, objectMode);
        return {
            direction,
            objectMode,
            stdioItems: normalizedStdioItems
        };
    };
    const initializeStdioItems = ({ stdioOption, fdNumber, options, optionName })=>{
        const values = Array.isArray(stdioOption) ? stdioOption : [
            stdioOption
        ];
        const initialStdioItems = [
            ...values.map((value)=>initializeStdioItem(value, optionName)),
            ...handleInputOptions(options, fdNumber)
        ];
        const stdioItems = filterDuplicates(initialStdioItems);
        const isStdioArray = stdioItems.length > 1;
        validateStdioArray(stdioItems, isStdioArray, optionName);
        validateStreams(stdioItems);
        return {
            stdioItems,
            isStdioArray
        };
    };
    const initializeStdioItem = (value, optionName)=>({
            type: getStdioItemType(value, optionName),
            value,
            optionName
        });
    const validateStdioArray = (stdioItems, isStdioArray, optionName)=>{
        if (0 === stdioItems.length) throw new TypeError(`The \`${optionName}\` option must not be an empty array.`);
        if (!isStdioArray) return;
        for (const { value, optionName } of stdioItems)if (INVALID_STDIO_ARRAY_OPTIONS.has(value)) throw new Error(`The \`${optionName}\` option must not include \`${value}\`.`);
    };
    const INVALID_STDIO_ARRAY_OPTIONS = new Set([
        'ignore',
        'ipc'
    ]);
    const validateStreams = (stdioItems)=>{
        for (const stdioItem of stdioItems)validateFileStdio(stdioItem);
    };
    const validateFileStdio = ({ type, value, optionName })=>{
        if (isRegularUrl(value)) throw new TypeError(`The \`${optionName}: URL\` option must use the \`file:\` scheme.
For example, you can use the \`pathToFileURL()\` method of the \`url\` core module.`);
        if (isUnknownStdioString(type, value)) throw new TypeError(`The \`${optionName}: { file: '...' }\` option must be used instead of \`${optionName}: '...'\`.`);
    };
    const validateFileObjectMode = (stdioItems, objectMode)=>{
        if (!objectMode) return;
        const fileStdioItem = stdioItems.find(({ type })=>FILE_TYPES.has(type));
        if (void 0 !== fileStdioItem) throw new TypeError(`The \`${fileStdioItem.optionName}\` option cannot use both files and transforms in objectMode.`);
    };
    const getFinalFileDescriptors = ({ initialFileDescriptors, addProperties, options, isSync })=>{
        const fileDescriptors = [];
        try {
            for (const fileDescriptor of initialFileDescriptors)fileDescriptors.push(getFinalFileDescriptor({
                fileDescriptor,
                fileDescriptors,
                addProperties,
                options,
                isSync
            }));
            return fileDescriptors;
        } catch (error) {
            cleanupCustomStreams(fileDescriptors);
            throw error;
        }
    };
    const getFinalFileDescriptor = ({ fileDescriptor: { direction, objectMode, stdioItems }, fileDescriptors, addProperties, options, isSync })=>{
        const finalStdioItems = stdioItems.map((stdioItem)=>addStreamProperties({
                stdioItem,
                addProperties,
                direction,
                options,
                fileDescriptors,
                isSync
            }));
        return {
            direction,
            objectMode,
            stdioItems: finalStdioItems
        };
    };
    const addStreamProperties = ({ stdioItem, addProperties, direction, options, fileDescriptors, isSync })=>{
        const duplicateStream = getDuplicateStream({
            stdioItem,
            direction,
            fileDescriptors,
            isSync
        });
        if (void 0 !== duplicateStream) return {
            ...stdioItem,
            stream: duplicateStream
        };
        return {
            ...stdioItem,
            ...addProperties[direction][stdioItem.type](stdioItem, options)
        };
    };
    const cleanupCustomStreams = (fileDescriptors)=>{
        for (const { stdioItems } of fileDescriptors)for (const { stream } of stdioItems)if (void 0 !== stream && !isStandardStream(stream)) stream.destroy();
    };
    const forwardStdio = (stdioItems)=>{
        if (stdioItems.length > 1) return stdioItems.some(({ value })=>'overlapped' === value) ? 'overlapped' : 'pipe';
        const [{ type, value }] = stdioItems;
        return 'native' === type ? value : 'pipe';
    };
    const handleStdioSync = (options, verboseInfo)=>handleStdio(addPropertiesSync, options, verboseInfo, true);
    const forbiddenIfSync = ({ type, optionName })=>{
        throwInvalidSyncValue(optionName, TYPE_TO_MESSAGE[type]);
    };
    const forbiddenNativeIfSync = ({ optionName, value })=>{
        if ('ipc' === value || 'overlapped' === value) throwInvalidSyncValue(optionName, `"${value}"`);
        return {};
    };
    const throwInvalidSyncValue = (optionName, value)=>{
        throw new TypeError(`The \`${optionName}\` option cannot be ${value} with synchronous methods.`);
    };
    const handle_sync_addProperties = {
        generator () {},
        asyncGenerator: forbiddenIfSync,
        webStream: forbiddenIfSync,
        nodeStream: forbiddenIfSync,
        webTransform: forbiddenIfSync,
        duplex: forbiddenIfSync,
        asyncIterable: forbiddenIfSync,
        native: forbiddenNativeIfSync
    };
    const addPropertiesSync = {
        input: {
            ...handle_sync_addProperties,
            fileUrl: ({ value })=>({
                    contents: [
                        bufferToUint8Array((0, external_node_fs_namespaceObject.readFileSync)(value))
                    ]
                }),
            filePath: ({ value: { file } })=>({
                    contents: [
                        bufferToUint8Array((0, external_node_fs_namespaceObject.readFileSync)(file))
                    ]
                }),
            fileNumber: forbiddenIfSync,
            iterable: ({ value })=>({
                    contents: [
                        ...value
                    ]
                }),
            string: ({ value })=>({
                    contents: [
                        value
                    ]
                }),
            uint8Array: ({ value })=>({
                    contents: [
                        value
                    ]
                })
        },
        output: {
            ...handle_sync_addProperties,
            fileUrl: ({ value })=>({
                    path: value
                }),
            filePath: ({ value: { file, append } })=>({
                    path: file,
                    append
                }),
            fileNumber: ({ value })=>({
                    path: value
                }),
            iterable: forbiddenIfSync,
            string: forbiddenIfSync,
            uint8Array: forbiddenIfSync
        }
    };
    const stripNewline = (value, { stripFinalNewline }, fdNumber)=>getStripFinalNewline(stripFinalNewline, fdNumber) && void 0 !== value && !Array.isArray(value) ? strip_final_newline_stripFinalNewline(value) : value;
    const getStripFinalNewline = (stripFinalNewline, fdNumber)=>'all' === fdNumber ? stripFinalNewline[1] || stripFinalNewline[2] : stripFinalNewline[fdNumber];
    var external_node_stream_ = __webpack_require__("node:stream");
    const getSplitLinesGenerator = (binary, preserveNewlines, skipped, state)=>binary || skipped ? void 0 : initializeSplitLines(preserveNewlines, state);
    const splitLinesSync = (chunk, preserveNewlines, objectMode)=>objectMode ? chunk.flatMap((item)=>splitLinesItemSync(item, preserveNewlines)) : splitLinesItemSync(chunk, preserveNewlines);
    const splitLinesItemSync = (chunk, preserveNewlines)=>{
        const { transform, final } = initializeSplitLines(preserveNewlines, {});
        return [
            ...transform(chunk),
            ...final()
        ];
    };
    const initializeSplitLines = (preserveNewlines, state)=>{
        state.previousChunks = '';
        return {
            transform: splitGenerator.bind(void 0, state, preserveNewlines),
            final: linesFinal.bind(void 0, state)
        };
    };
    const splitGenerator = function*(state, preserveNewlines, chunk) {
        if ('string' != typeof chunk) return void (yield chunk);
        let { previousChunks } = state;
        let start = -1;
        for(let end = 0; end < chunk.length; end += 1)if ('\n' === chunk[end]) {
            const newlineLength = getNewlineLength(chunk, end, preserveNewlines, state);
            let line = chunk.slice(start + 1, end + 1 - newlineLength);
            if (previousChunks.length > 0) {
                line = concatString(previousChunks, line);
                previousChunks = '';
            }
            yield line;
            start = end;
        }
        if (start !== chunk.length - 1) previousChunks = concatString(previousChunks, chunk.slice(start + 1));
        state.previousChunks = previousChunks;
    };
    const getNewlineLength = (chunk, end, preserveNewlines, state)=>{
        if (preserveNewlines) return 0;
        state.isWindowsNewline = 0 !== end && '\r' === chunk[end - 1];
        return state.isWindowsNewline ? 2 : 1;
    };
    const linesFinal = function*({ previousChunks }) {
        if (previousChunks.length > 0) yield previousChunks;
    };
    const getAppendNewlineGenerator = ({ binary, preserveNewlines, readableObjectMode, state })=>binary || preserveNewlines || readableObjectMode ? void 0 : {
            transform: appendNewlineGenerator.bind(void 0, state)
        };
    const appendNewlineGenerator = function*({ isWindowsNewline = false }, chunk) {
        const { unixNewline, windowsNewline, LF, concatBytes } = 'string' == typeof chunk ? linesStringInfo : linesUint8ArrayInfo;
        if (chunk.at(-1) === LF) return void (yield chunk);
        const newline = isWindowsNewline ? windowsNewline : unixNewline;
        yield concatBytes(chunk, newline);
    };
    const concatString = (firstChunk, secondChunk)=>`${firstChunk}${secondChunk}`;
    const linesStringInfo = {
        windowsNewline: '\r\n',
        unixNewline: '\n',
        LF: '\n',
        concatBytes: concatString
    };
    const concatUint8Array = (firstChunk, secondChunk)=>{
        const chunk = new Uint8Array(firstChunk.length + secondChunk.length);
        chunk.set(firstChunk, 0);
        chunk.set(secondChunk, firstChunk.length);
        return chunk;
    };
    const linesUint8ArrayInfo = {
        windowsNewline: new Uint8Array([
            0x0D,
            0x0A
        ]),
        unixNewline: new Uint8Array([
            0x0A
        ]),
        LF: 0x0A,
        concatBytes: concatUint8Array
    };
    var external_node_buffer_ = __webpack_require__("node:buffer");
    const getValidateTransformInput = (writableObjectMode, optionName)=>writableObjectMode ? void 0 : validateStringTransformInput.bind(void 0, optionName);
    const validateStringTransformInput = function*(optionName, chunk) {
        if ('string' != typeof chunk && !isUint8Array(chunk) && !external_node_buffer_.Buffer.isBuffer(chunk)) throw new TypeError(`The \`${optionName}\` option's transform must use "objectMode: true" to receive as input: ${typeof chunk}.`);
        yield chunk;
    };
    const getValidateTransformReturn = (readableObjectMode, optionName)=>readableObjectMode ? validateObjectTransformReturn.bind(void 0, optionName) : validateStringTransformReturn.bind(void 0, optionName);
    const validateObjectTransformReturn = function*(optionName, chunk) {
        validateEmptyReturn(optionName, chunk);
        yield chunk;
    };
    const validateStringTransformReturn = function*(optionName, chunk) {
        validateEmptyReturn(optionName, chunk);
        if ('string' != typeof chunk && !isUint8Array(chunk)) throw new TypeError(`The \`${optionName}\` option's function must yield a string or an Uint8Array, not ${typeof chunk}.`);
        yield chunk;
    };
    const validateEmptyReturn = (optionName, chunk)=>{
        if (null == chunk) throw new TypeError(`The \`${optionName}\` option's function must not call \`yield ${chunk}\`.
Instead, \`yield\` should either be called with a value, or not be called at all. For example:
  if (condition) { yield value; }`);
    };
    const getEncodingTransformGenerator = (binary, encoding, skipped)=>{
        if (skipped) return;
        if (binary) return {
            transform: encodingUint8ArrayGenerator.bind(void 0, new TextEncoder())
        };
        const stringDecoder = new external_node_string_decoder_namespaceObject.StringDecoder(encoding);
        return {
            transform: encodingStringGenerator.bind(void 0, stringDecoder),
            final: encodingStringFinal.bind(void 0, stringDecoder)
        };
    };
    const encodingUint8ArrayGenerator = function*(textEncoder, chunk) {
        if (external_node_buffer_.Buffer.isBuffer(chunk)) yield bufferToUint8Array(chunk);
        else if ('string' == typeof chunk) yield textEncoder.encode(chunk);
        else yield chunk;
    };
    const encodingStringGenerator = function*(stringDecoder, chunk) {
        yield isUint8Array(chunk) ? stringDecoder.write(chunk) : chunk;
    };
    const encodingStringFinal = function*(stringDecoder) {
        const lastChunk = stringDecoder.end();
        if ('' !== lastChunk) yield lastChunk;
    };
    const pushChunks = (0, external_node_util_.callbackify)(async (getChunks, state, getChunksArguments, transformStream)=>{
        state.currentIterable = getChunks(...getChunksArguments);
        try {
            for await (const chunk of state.currentIterable)transformStream.push(chunk);
        } finally{
            delete state.currentIterable;
        }
    });
    const transformChunk = async function*(chunk, generators, index) {
        if (index === generators.length) return void (yield chunk);
        const { transform = identityGenerator } = generators[index];
        for await (const transformedChunk of transform(chunk))yield* transformChunk(transformedChunk, generators, index + 1);
    };
    const finalChunks = async function*(generators) {
        for (const [index, { final }] of Object.entries(generators))yield* generatorFinalChunks(final, Number(index), generators);
    };
    const generatorFinalChunks = async function*(final, index, generators) {
        if (void 0 === final) return;
        for await (const finalChunk of final())yield* transformChunk(finalChunk, generators, index + 1);
    };
    const destroyTransform = (0, external_node_util_.callbackify)(async ({ currentIterable }, error)=>{
        if (void 0 !== currentIterable) return void await (error ? currentIterable.throw(error) : currentIterable.return());
        if (error) throw error;
    });
    const identityGenerator = function*(chunk) {
        yield chunk;
    };
    const pushChunksSync = (getChunksSync, getChunksArguments, transformStream, done)=>{
        try {
            for (const chunk of getChunksSync(...getChunksArguments))transformStream.push(chunk);
            done();
        } catch (error) {
            done(error);
        }
    };
    const runTransformSync = (generators, chunks)=>[
            ...chunks.flatMap((chunk)=>[
                    ...transformChunkSync(chunk, generators, 0)
                ]),
            ...finalChunksSync(generators)
        ];
    const transformChunkSync = function*(chunk, generators, index) {
        if (index === generators.length) return void (yield chunk);
        const { transform = run_sync_identityGenerator } = generators[index];
        for (const transformedChunk of transform(chunk))yield* transformChunkSync(transformedChunk, generators, index + 1);
    };
    const finalChunksSync = function*(generators) {
        for (const [index, { final }] of Object.entries(generators))yield* generatorFinalChunksSync(final, Number(index), generators);
    };
    const generatorFinalChunksSync = function*(final, index, generators) {
        if (void 0 === final) return;
        for (const finalChunk of final())yield* transformChunkSync(finalChunk, generators, index + 1);
    };
    const run_sync_identityGenerator = function*(chunk) {
        yield chunk;
    };
    const generatorToStream = ({ value, value: { transform, final, writableObjectMode, readableObjectMode }, optionName }, { encoding })=>{
        const state = {};
        const generators = addInternalGenerators(value, encoding, optionName);
        const transformAsync = isAsyncGenerator(transform);
        const finalAsync = isAsyncGenerator(final);
        const transformMethod = transformAsync ? pushChunks.bind(void 0, transformChunk, state) : pushChunksSync.bind(void 0, transformChunkSync);
        const finalMethod = transformAsync || finalAsync ? pushChunks.bind(void 0, finalChunks, state) : pushChunksSync.bind(void 0, finalChunksSync);
        const destroyMethod = transformAsync || finalAsync ? destroyTransform.bind(void 0, state) : void 0;
        const stream = new external_node_stream_.Transform({
            writableObjectMode,
            writableHighWaterMark: (0, external_node_stream_.getDefaultHighWaterMark)(writableObjectMode),
            readableObjectMode,
            readableHighWaterMark: (0, external_node_stream_.getDefaultHighWaterMark)(readableObjectMode),
            transform (chunk, encoding, done) {
                transformMethod([
                    chunk,
                    generators,
                    0
                ], this, done);
            },
            flush (done) {
                finalMethod([
                    generators
                ], this, done);
            },
            destroy: destroyMethod
        });
        return {
            stream
        };
    };
    const runGeneratorsSync = (chunks, stdioItems, encoding, isInput)=>{
        const generators = stdioItems.filter(({ type })=>'generator' === type);
        const reversedGenerators = isInput ? generators.reverse() : generators;
        for (const { value, optionName } of reversedGenerators){
            const generators = addInternalGenerators(value, encoding, optionName);
            chunks = runTransformSync(generators, chunks);
        }
        return chunks;
    };
    const addInternalGenerators = ({ transform, final, binary, writableObjectMode, readableObjectMode, preserveNewlines }, encoding, optionName)=>{
        const state = {};
        return [
            {
                transform: getValidateTransformInput(writableObjectMode, optionName)
            },
            getEncodingTransformGenerator(binary, encoding, writableObjectMode),
            getSplitLinesGenerator(binary, preserveNewlines, writableObjectMode, state),
            {
                transform,
                final
            },
            {
                transform: getValidateTransformReturn(readableObjectMode, optionName)
            },
            getAppendNewlineGenerator({
                binary,
                preserveNewlines,
                readableObjectMode,
                state
            })
        ].filter(Boolean);
    };
    const addInputOptionsSync = (fileDescriptors, options)=>{
        for (const fdNumber of getInputFdNumbers(fileDescriptors))addInputOptionSync(fileDescriptors, fdNumber, options);
    };
    const getInputFdNumbers = (fileDescriptors)=>new Set(Object.entries(fileDescriptors).filter(([, { direction }])=>'input' === direction).map(([fdNumber])=>Number(fdNumber)));
    const addInputOptionSync = (fileDescriptors, fdNumber, options)=>{
        const { stdioItems } = fileDescriptors[fdNumber];
        const allStdioItems = stdioItems.filter(({ contents })=>void 0 !== contents);
        if (0 === allStdioItems.length) return;
        if (0 !== fdNumber) {
            const [{ type, optionName }] = allStdioItems;
            throw new TypeError(`Only the \`stdin\` option, not \`${optionName}\`, can be ${TYPE_TO_MESSAGE[type]} with synchronous methods.`);
        }
        const allContents = allStdioItems.map(({ contents })=>contents);
        const transformedContents = allContents.map((contents)=>applySingleInputGeneratorsSync(contents, stdioItems));
        options.input = joinToUint8Array(transformedContents);
    };
    const applySingleInputGeneratorsSync = (contents, stdioItems)=>{
        const newContents = runGeneratorsSync(contents, stdioItems, 'utf8', true);
        validateSerializable(newContents);
        return joinToUint8Array(newContents);
    };
    const validateSerializable = (newContents)=>{
        const invalidItem = newContents.find((item)=>'string' != typeof item && !isUint8Array(item));
        if (void 0 !== invalidItem) throw new TypeError(`The \`stdin\` option is invalid: when passing objects as input, a transform must be used to serialize them to strings or Uint8Arrays: ${invalidItem}.`);
    };
    const shouldLogOutput = ({ stdioItems, encoding, verboseInfo, fdNumber })=>'all' !== fdNumber && isFullVerbose(verboseInfo, fdNumber) && !BINARY_ENCODINGS.has(encoding) && fdUsesVerbose(fdNumber) && (stdioItems.some(({ type, value })=>'native' === type && PIPED_STDIO_VALUES.has(value)) || stdioItems.every(({ type })=>TRANSFORM_TYPES.has(type)));
    const fdUsesVerbose = (fdNumber)=>1 === fdNumber || 2 === fdNumber;
    const PIPED_STDIO_VALUES = new Set([
        'pipe',
        'overlapped'
    ]);
    const logLines = async (linesIterable, stream, fdNumber, verboseInfo)=>{
        for await (const line of linesIterable)if (!isPipingStream(stream)) logLine(line, fdNumber, verboseInfo);
    };
    const logLinesSync = (linesArray, fdNumber, verboseInfo)=>{
        for (const line of linesArray)logLine(line, fdNumber, verboseInfo);
    };
    const isPipingStream = (stream)=>stream._readableState.pipes.length > 0;
    const logLine = (line, fdNumber, verboseInfo)=>{
        const verboseMessage = serializeVerboseMessage(line);
        verboseLog({
            type: 'output',
            verboseMessage,
            fdNumber,
            verboseInfo
        });
    };
    const transformOutputSync = ({ fileDescriptors, syncResult: { output }, options, isMaxBuffer, verboseInfo })=>{
        if (null === output) return {
            output: Array.from({
                length: 3
            })
        };
        const state = {};
        const outputFiles = new Set([]);
        const transformedOutput = output.map((result, fdNumber)=>transformOutputResultSync({
                result,
                fileDescriptors,
                fdNumber,
                state,
                outputFiles,
                isMaxBuffer,
                verboseInfo
            }, options));
        return {
            output: transformedOutput,
            ...state
        };
    };
    const transformOutputResultSync = ({ result, fileDescriptors, fdNumber, state, outputFiles, isMaxBuffer, verboseInfo }, { buffer, encoding, lines, stripFinalNewline, maxBuffer })=>{
        if (null === result) return;
        const truncatedResult = truncateMaxBufferSync(result, isMaxBuffer, maxBuffer);
        const uint8ArrayResult = bufferToUint8Array(truncatedResult);
        const { stdioItems, objectMode } = fileDescriptors[fdNumber];
        const chunks = runOutputGeneratorsSync([
            uint8ArrayResult
        ], stdioItems, encoding, state);
        const { serializedResult, finalResult = serializedResult } = serializeChunks({
            chunks,
            objectMode,
            encoding,
            lines,
            stripFinalNewline,
            fdNumber
        });
        logOutputSync({
            serializedResult,
            fdNumber,
            state,
            verboseInfo,
            encoding,
            stdioItems,
            objectMode
        });
        const returnedResult = buffer[fdNumber] ? finalResult : void 0;
        try {
            if (void 0 === state.error) writeToFiles(serializedResult, stdioItems, outputFiles);
            return returnedResult;
        } catch (error) {
            state.error = error;
            return returnedResult;
        }
    };
    const runOutputGeneratorsSync = (chunks, stdioItems, encoding, state)=>{
        try {
            return runGeneratorsSync(chunks, stdioItems, encoding, false);
        } catch (error) {
            state.error = error;
            return chunks;
        }
    };
    const serializeChunks = ({ chunks, objectMode, encoding, lines, stripFinalNewline, fdNumber })=>{
        if (objectMode) return {
            serializedResult: chunks
        };
        if ('buffer' === encoding) return {
            serializedResult: joinToUint8Array(chunks)
        };
        const serializedResult = joinToString(chunks, encoding);
        if (lines[fdNumber]) return {
            serializedResult,
            finalResult: splitLinesSync(serializedResult, !stripFinalNewline[fdNumber], objectMode)
        };
        return {
            serializedResult
        };
    };
    const logOutputSync = ({ serializedResult, fdNumber, state, verboseInfo, encoding, stdioItems, objectMode })=>{
        if (!shouldLogOutput({
            stdioItems,
            encoding,
            verboseInfo,
            fdNumber
        })) return;
        const linesArray = splitLinesSync(serializedResult, false, objectMode);
        try {
            logLinesSync(linesArray, fdNumber, verboseInfo);
        } catch (error) {
            state.error ??= error;
        }
    };
    const writeToFiles = (serializedResult, stdioItems, outputFiles)=>{
        for (const { path, append } of stdioItems.filter(({ type })=>FILE_TYPES.has(type))){
            const pathString = 'string' == typeof path ? path : path.toString();
            if (append || outputFiles.has(pathString)) (0, external_node_fs_namespaceObject.appendFileSync)(path, serializedResult);
            else {
                outputFiles.add(pathString);
                (0, external_node_fs_namespaceObject.writeFileSync)(path, serializedResult);
            }
        }
    };
    const getAllSync = ([, stdout, stderr], options)=>{
        if (!options.all) return;
        if (void 0 === stdout) return stderr;
        if (void 0 === stderr) return stdout;
        if (Array.isArray(stdout)) return Array.isArray(stderr) ? [
            ...stdout,
            ...stderr
        ] : [
            ...stdout,
            stripNewline(stderr, options, 'all')
        ];
        if (Array.isArray(stderr)) return [
            stripNewline(stdout, options, 'all'),
            ...stderr
        ];
        if (isUint8Array(stdout) && isUint8Array(stderr)) return concatUint8Arrays([
            stdout,
            stderr
        ]);
        return `${stdout}${stderr}`;
    };
    const waitForExit = async (subprocess, context)=>{
        const [exitCode, signal] = await waitForExitOrError(subprocess);
        context.isForcefullyTerminated ??= false;
        return [
            exitCode,
            signal
        ];
    };
    const waitForExitOrError = async (subprocess)=>{
        const [spawnPayload, exitPayload] = await Promise.allSettled([
            (0, external_node_events_.once)(subprocess, 'spawn'),
            (0, external_node_events_.once)(subprocess, 'exit')
        ]);
        if ('rejected' === spawnPayload.status) return [];
        return 'rejected' === exitPayload.status ? waitForSubprocessExit(subprocess) : exitPayload.value;
    };
    const waitForSubprocessExit = async (subprocess)=>{
        try {
            return await (0, external_node_events_.once)(subprocess, 'exit');
        } catch  {
            return waitForSubprocessExit(subprocess);
        }
    };
    const waitForSuccessfulExit = async (exitPromise)=>{
        const [exitCode, signal] = await exitPromise;
        if (!isSubprocessErrorExit(exitCode, signal) && isFailedExit(exitCode, signal)) throw new DiscardedError();
        return [
            exitCode,
            signal
        ];
    };
    const isSubprocessErrorExit = (exitCode, signal)=>void 0 === exitCode && void 0 === signal;
    const isFailedExit = (exitCode, signal)=>0 !== exitCode || null !== signal;
    const getExitResultSync = ({ error, status: exitCode, signal, output }, { maxBuffer })=>{
        const resultError = getResultError(error, exitCode, signal);
        const timedOut = resultError?.code === 'ETIMEDOUT';
        const isMaxBuffer = isMaxBufferSync(resultError, output, maxBuffer);
        return {
            resultError,
            exitCode,
            signal,
            timedOut,
            isMaxBuffer
        };
    };
    const getResultError = (error, exitCode, signal)=>{
        if (void 0 !== error) return error;
        return isFailedExit(exitCode, signal) ? new DiscardedError() : void 0;
    };
    const execaCoreSync = (rawFile, rawArguments, rawOptions)=>{
        const { file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors } = handleSyncArguments(rawFile, rawArguments, rawOptions);
        const result = spawnSubprocessSync({
            file,
            commandArguments,
            options,
            command,
            escapedCommand,
            verboseInfo,
            fileDescriptors,
            startTime
        });
        return reject_handleResult(result, verboseInfo, options);
    };
    const handleSyncArguments = (rawFile, rawArguments, rawOptions)=>{
        const { command, escapedCommand, startTime, verboseInfo } = handleCommand(rawFile, rawArguments, rawOptions);
        const syncOptions = normalizeSyncOptions(rawOptions);
        const { file, commandArguments, options } = normalizeOptions(rawFile, rawArguments, syncOptions);
        validateSyncOptions(options);
        const fileDescriptors = handleStdioSync(options, verboseInfo);
        return {
            file,
            commandArguments,
            command,
            escapedCommand,
            startTime,
            verboseInfo,
            options,
            fileDescriptors
        };
    };
    const normalizeSyncOptions = (options)=>options.node && !options.ipc ? {
            ...options,
            ipc: false
        } : options;
    const validateSyncOptions = ({ ipc, ipcInput, detached, cancelSignal })=>{
        if (ipcInput) throwInvalidSyncOption('ipcInput');
        if (ipc) throwInvalidSyncOption('ipc: true');
        if (detached) throwInvalidSyncOption('detached: true');
        if (cancelSignal) throwInvalidSyncOption('cancelSignal');
    };
    const throwInvalidSyncOption = (value)=>{
        throw new TypeError(`The "${value}" option cannot be used with synchronous methods.`);
    };
    const spawnSubprocessSync = ({ file, commandArguments, options, command, escapedCommand, verboseInfo, fileDescriptors, startTime })=>{
        const syncResult = runSubprocessSync({
            file,
            commandArguments,
            options,
            command,
            escapedCommand,
            fileDescriptors,
            startTime
        });
        if (syncResult.failed) return syncResult;
        const { resultError, exitCode, signal, timedOut, isMaxBuffer } = getExitResultSync(syncResult, options);
        const { output, error = resultError } = transformOutputSync({
            fileDescriptors,
            syncResult,
            options,
            isMaxBuffer,
            verboseInfo
        });
        const stdio = output.map((stdioOutput, fdNumber)=>stripNewline(stdioOutput, options, fdNumber));
        const all = stripNewline(getAllSync(output, options), options, 'all');
        return getSyncResult({
            error,
            exitCode,
            signal,
            timedOut,
            isMaxBuffer,
            stdio,
            all,
            options,
            command,
            escapedCommand,
            startTime
        });
    };
    const runSubprocessSync = ({ file, commandArguments, options, command, escapedCommand, fileDescriptors, startTime })=>{
        try {
            addInputOptionsSync(fileDescriptors, options);
            const normalizedOptions = normalizeSpawnSyncOptions(options);
            return (0, external_node_child_process_namespaceObject.spawnSync)(...concatenateShell(file, commandArguments, normalizedOptions));
        } catch (error) {
            return makeEarlyError({
                error,
                command,
                escapedCommand,
                fileDescriptors,
                options,
                startTime,
                isSync: true
            });
        }
    };
    const normalizeSpawnSyncOptions = ({ encoding, maxBuffer, ...options })=>({
            ...options,
            encoding: 'buffer',
            maxBuffer: getMaxBufferSync(maxBuffer)
        });
    const getSyncResult = ({ error, exitCode, signal, timedOut, isMaxBuffer, stdio, all, options, command, escapedCommand, startTime })=>void 0 === error ? makeSuccessResult({
            command,
            escapedCommand,
            stdio,
            all,
            ipcOutput: [],
            options,
            startTime
        }) : makeError({
            error,
            command,
            escapedCommand,
            timedOut,
            isCanceled: false,
            isGracefullyCanceled: false,
            isMaxBuffer,
            isForcefullyTerminated: false,
            exitCode,
            signal,
            stdio,
            all,
            ipcOutput: [],
            options,
            startTime,
            isSync: true
        });
    const getOneMessage = ({ anyProcess, channel, isSubprocess, ipc }, { reference = true, filter } = {})=>{
        validateIpcMethod({
            methodName: 'getOneMessage',
            isSubprocess,
            ipc,
            isConnected: forward_isConnected(anyProcess)
        });
        return getOneMessageAsync({
            anyProcess,
            channel,
            isSubprocess,
            filter,
            reference
        });
    };
    const getOneMessageAsync = async ({ anyProcess, channel, isSubprocess, filter, reference })=>{
        addReference(channel, reference);
        const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
        const controller = new AbortController();
        try {
            return await Promise.race([
                getMessage(ipcEmitter, filter, controller),
                get_one_throwOnDisconnect(ipcEmitter, isSubprocess, controller),
                throwOnStrictError(ipcEmitter, isSubprocess, controller)
            ]);
        } catch (error) {
            disconnect(anyProcess);
            throw error;
        } finally{
            controller.abort();
            removeReference(channel, reference);
        }
    };
    const getMessage = async (ipcEmitter, filter, { signal })=>{
        if (void 0 === filter) {
            const [message] = await (0, external_node_events_.once)(ipcEmitter, 'message', {
                signal
            });
            return message;
        }
        for await (const [message] of (0, external_node_events_.on)(ipcEmitter, 'message', {
            signal
        }))if (filter(message)) return message;
    };
    const get_one_throwOnDisconnect = async (ipcEmitter, isSubprocess, { signal })=>{
        await (0, external_node_events_.once)(ipcEmitter, 'disconnect', {
            signal
        });
        throwOnEarlyDisconnect(isSubprocess);
    };
    const throwOnStrictError = async (ipcEmitter, isSubprocess, { signal })=>{
        const [error] = await (0, external_node_events_.once)(ipcEmitter, 'strict:error', {
            signal
        });
        throw getStrictResponseError(error, isSubprocess);
    };
    const getEachMessage = ({ anyProcess, channel, isSubprocess, ipc }, { reference = true } = {})=>loopOnMessages({
            anyProcess,
            channel,
            isSubprocess,
            ipc,
            shouldAwait: !isSubprocess,
            reference
        });
    const loopOnMessages = ({ anyProcess, channel, isSubprocess, ipc, shouldAwait, reference })=>{
        validateIpcMethod({
            methodName: 'getEachMessage',
            isSubprocess,
            ipc,
            isConnected: forward_isConnected(anyProcess)
        });
        addReference(channel, reference);
        const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
        const controller = new AbortController();
        const state = {};
        stopOnDisconnect(anyProcess, ipcEmitter, controller);
        abortOnStrictError({
            ipcEmitter,
            isSubprocess,
            controller,
            state
        });
        return iterateOnMessages({
            anyProcess,
            channel,
            ipcEmitter,
            isSubprocess,
            shouldAwait,
            controller,
            state,
            reference
        });
    };
    const stopOnDisconnect = async (anyProcess, ipcEmitter, controller)=>{
        try {
            await (0, external_node_events_.once)(ipcEmitter, 'disconnect', {
                signal: controller.signal
            });
            controller.abort();
        } catch  {}
    };
    const abortOnStrictError = async ({ ipcEmitter, isSubprocess, controller, state })=>{
        try {
            const [error] = await (0, external_node_events_.once)(ipcEmitter, 'strict:error', {
                signal: controller.signal
            });
            state.error = getStrictResponseError(error, isSubprocess);
            controller.abort();
        } catch  {}
    };
    const iterateOnMessages = async function*({ anyProcess, channel, ipcEmitter, isSubprocess, shouldAwait, controller, state, reference }) {
        try {
            for await (const [message] of (0, external_node_events_.on)(ipcEmitter, 'message', {
                signal: controller.signal
            })){
                throwIfStrictError(state);
                yield message;
            }
        } catch  {
            throwIfStrictError(state);
        } finally{
            controller.abort();
            removeReference(channel, reference);
            if (!isSubprocess) disconnect(anyProcess);
            if (shouldAwait) await anyProcess;
        }
    };
    const throwIfStrictError = ({ error })=>{
        if (error) throw error;
    };
    const addIpcMethods = (subprocess, { ipc })=>{
        Object.assign(subprocess, getIpcMethods(subprocess, false, ipc));
    };
    const getIpcExport = ()=>{
        const anyProcess = external_node_process_namespaceObject;
        const isSubprocess = true;
        const ipc = void 0 !== external_node_process_namespaceObject.channel;
        return {
            ...getIpcMethods(anyProcess, isSubprocess, ipc),
            getCancelSignal: getCancelSignal.bind(void 0, {
                anyProcess,
                channel: anyProcess.channel,
                isSubprocess,
                ipc
            })
        };
    };
    const getIpcMethods = (anyProcess, isSubprocess, ipc)=>({
            sendMessage: sendMessage.bind(void 0, {
                anyProcess,
                channel: anyProcess.channel,
                isSubprocess,
                ipc
            }),
            getOneMessage: getOneMessage.bind(void 0, {
                anyProcess,
                channel: anyProcess.channel,
                isSubprocess,
                ipc
            }),
            getEachMessage: getEachMessage.bind(void 0, {
                anyProcess,
                channel: anyProcess.channel,
                isSubprocess,
                ipc
            })
        });
    const handleEarlyError = ({ error, command, escapedCommand, fileDescriptors, options, startTime, verboseInfo })=>{
        cleanupCustomStreams(fileDescriptors);
        const subprocess = new external_node_child_process_namespaceObject.ChildProcess();
        createDummyStreams(subprocess, fileDescriptors);
        Object.assign(subprocess, {
            readable: early_error_readable,
            writable: early_error_writable,
            duplex: early_error_duplex
        });
        const earlyError = makeEarlyError({
            error,
            command,
            escapedCommand,
            fileDescriptors,
            options,
            startTime,
            isSync: false
        });
        const promise = handleDummyPromise(earlyError, verboseInfo, options);
        return {
            subprocess,
            promise
        };
    };
    const createDummyStreams = (subprocess, fileDescriptors)=>{
        const stdin = createDummyStream();
        const stdout = createDummyStream();
        const stderr = createDummyStream();
        const extraStdio = Array.from({
            length: fileDescriptors.length - 3
        }, createDummyStream);
        const all = createDummyStream();
        const stdio = [
            stdin,
            stdout,
            stderr,
            ...extraStdio
        ];
        Object.assign(subprocess, {
            stdin,
            stdout,
            stderr,
            all,
            stdio
        });
    };
    const createDummyStream = ()=>{
        const stream = new external_node_stream_.PassThrough();
        stream.end();
        return stream;
    };
    const early_error_readable = ()=>new external_node_stream_.Readable({
            read () {}
        });
    const early_error_writable = ()=>new external_node_stream_.Writable({
            write () {}
        });
    const early_error_duplex = ()=>new external_node_stream_.Duplex({
            read () {},
            write () {}
        });
    const handleDummyPromise = async (error, verboseInfo, options)=>reject_handleResult(error, verboseInfo, options);
    const handleStdioAsync = (options, verboseInfo)=>handleStdio(addPropertiesAsync, options, verboseInfo, false);
    const forbiddenIfAsync = ({ type, optionName })=>{
        throw new TypeError(`The \`${optionName}\` option cannot be ${TYPE_TO_MESSAGE[type]}.`);
    };
    const handle_async_addProperties = {
        fileNumber: forbiddenIfAsync,
        generator: generatorToStream,
        asyncGenerator: generatorToStream,
        nodeStream: ({ value })=>({
                stream: value
            }),
        webTransform ({ value: { transform, writableObjectMode, readableObjectMode } }) {
            const objectMode = writableObjectMode || readableObjectMode;
            const stream = external_node_stream_.Duplex.fromWeb(transform, {
                objectMode
            });
            return {
                stream
            };
        },
        duplex: ({ value: { transform } })=>({
                stream: transform
            }),
        native () {}
    };
    const addPropertiesAsync = {
        input: {
            ...handle_async_addProperties,
            fileUrl: ({ value })=>({
                    stream: (0, external_node_fs_namespaceObject.createReadStream)(value)
                }),
            filePath: ({ value: { file } })=>({
                    stream: (0, external_node_fs_namespaceObject.createReadStream)(file)
                }),
            webStream: ({ value })=>({
                    stream: external_node_stream_.Readable.fromWeb(value)
                }),
            iterable: ({ value })=>({
                    stream: external_node_stream_.Readable.from(value)
                }),
            asyncIterable: ({ value })=>({
                    stream: external_node_stream_.Readable.from(value)
                }),
            string: ({ value })=>({
                    stream: external_node_stream_.Readable.from(value)
                }),
            uint8Array: ({ value })=>({
                    stream: external_node_stream_.Readable.from(external_node_buffer_.Buffer.from(value))
                })
        },
        output: {
            ...handle_async_addProperties,
            fileUrl: ({ value })=>({
                    stream: (0, external_node_fs_namespaceObject.createWriteStream)(value)
                }),
            filePath: ({ value: { file, append } })=>({
                    stream: (0, external_node_fs_namespaceObject.createWriteStream)(file, append ? {
                        flags: 'a'
                    } : {})
                }),
            webStream: ({ value })=>({
                    stream: external_node_stream_.Writable.fromWeb(value)
                }),
            iterable: forbiddenIfAsync,
            asyncIterable: forbiddenIfAsync,
            string: forbiddenIfAsync,
            uint8Array: forbiddenIfAsync
        }
    };
    const external_node_stream_promises_namespaceObject = require("node:stream/promises");
    function mergeStreams(streams) {
        if (!Array.isArray(streams)) throw new TypeError(`Expected an array, got \`${typeof streams}\`.`);
        for (const stream of streams)validateStream(stream);
        const objectMode = streams.some(({ readableObjectMode })=>readableObjectMode);
        const highWaterMark = getHighWaterMark(streams, objectMode);
        const passThroughStream = new MergedStream({
            objectMode,
            writableHighWaterMark: highWaterMark,
            readableHighWaterMark: highWaterMark
        });
        for (const stream of streams)passThroughStream.add(stream);
        return passThroughStream;
    }
    const getHighWaterMark = (streams, objectMode)=>{
        if (0 === streams.length) return (0, external_node_stream_.getDefaultHighWaterMark)(objectMode);
        const highWaterMarks = streams.filter(({ readableObjectMode })=>readableObjectMode === objectMode).map(({ readableHighWaterMark })=>readableHighWaterMark);
        return Math.max(...highWaterMarks);
    };
    class MergedStream extends external_node_stream_.PassThrough {
        #streams = new Set([]);
        #ended = new Set([]);
        #aborted = new Set([]);
        #onFinished;
        #unpipeEvent = Symbol('unpipe');
        #streamPromises = new WeakMap();
        add(stream) {
            validateStream(stream);
            if (this.#streams.has(stream)) return;
            this.#streams.add(stream);
            this.#onFinished ??= onMergedStreamFinished(this, this.#streams, this.#unpipeEvent);
            const streamPromise = endWhenStreamsDone({
                passThroughStream: this,
                stream,
                streams: this.#streams,
                ended: this.#ended,
                aborted: this.#aborted,
                onFinished: this.#onFinished,
                unpipeEvent: this.#unpipeEvent
            });
            this.#streamPromises.set(stream, streamPromise);
            stream.pipe(this, {
                end: false
            });
        }
        async remove(stream) {
            validateStream(stream);
            if (!this.#streams.has(stream)) return false;
            const streamPromise = this.#streamPromises.get(stream);
            if (void 0 === streamPromise) return false;
            this.#streamPromises.delete(stream);
            stream.unpipe(this);
            await streamPromise;
            return true;
        }
    }
    const onMergedStreamFinished = async (passThroughStream, streams, unpipeEvent)=>{
        updateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_COUNT);
        const controller = new AbortController();
        try {
            await Promise.race([
                onMergedStreamEnd(passThroughStream, controller),
                onInputStreamsUnpipe(passThroughStream, streams, unpipeEvent, controller)
            ]);
        } finally{
            controller.abort();
            updateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_COUNT);
        }
    };
    const onMergedStreamEnd = async (passThroughStream, { signal })=>{
        try {
            await (0, external_node_stream_promises_namespaceObject.finished)(passThroughStream, {
                signal,
                cleanup: true
            });
        } catch (error) {
            errorOrAbortStream(passThroughStream, error);
            throw error;
        }
    };
    const onInputStreamsUnpipe = async (passThroughStream, streams, unpipeEvent, { signal })=>{
        for await (const [unpipedStream] of (0, external_node_events_.on)(passThroughStream, 'unpipe', {
            signal
        }))if (streams.has(unpipedStream)) unpipedStream.emit(unpipeEvent);
    };
    const validateStream = (stream)=>{
        if ('function' != typeof stream?.pipe) throw new TypeError(`Expected a readable stream, got: \`${typeof stream}\`.`);
    };
    const endWhenStreamsDone = async ({ passThroughStream, stream, streams, ended, aborted, onFinished, unpipeEvent })=>{
        updateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_PER_STREAM);
        const controller = new AbortController();
        try {
            await Promise.race([
                afterMergedStreamFinished(onFinished, stream, controller),
                onInputStreamEnd({
                    passThroughStream,
                    stream,
                    streams,
                    ended,
                    aborted,
                    controller
                }),
                onInputStreamUnpipe({
                    stream,
                    streams,
                    ended,
                    aborted,
                    unpipeEvent,
                    controller
                })
            ]);
        } finally{
            controller.abort();
            updateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_PER_STREAM);
        }
        if (streams.size > 0 && streams.size === ended.size + aborted.size) if (0 === ended.size && aborted.size > 0) abortStream(passThroughStream);
        else endStream(passThroughStream);
    };
    const afterMergedStreamFinished = async (onFinished, stream, { signal })=>{
        try {
            await onFinished;
            if (!signal.aborted) abortStream(stream);
        } catch (error) {
            if (!signal.aborted) errorOrAbortStream(stream, error);
        }
    };
    const onInputStreamEnd = async ({ passThroughStream, stream, streams, ended, aborted, controller: { signal } })=>{
        try {
            await (0, external_node_stream_promises_namespaceObject.finished)(stream, {
                signal,
                cleanup: true,
                readable: true,
                writable: false
            });
            if (streams.has(stream)) ended.add(stream);
        } catch (error) {
            if (signal.aborted || !streams.has(stream)) return;
            if (isAbortError(error)) aborted.add(stream);
            else errorStream(passThroughStream, error);
        }
    };
    const onInputStreamUnpipe = async ({ stream, streams, ended, aborted, unpipeEvent, controller: { signal } })=>{
        await (0, external_node_events_.once)(stream, unpipeEvent, {
            signal
        });
        if (!stream.readable) return (0, external_node_events_.once)(signal, 'abort', {
            signal
        });
        streams.delete(stream);
        ended.delete(stream);
        aborted.delete(stream);
    };
    const endStream = (stream)=>{
        if (stream.writable) stream.end();
    };
    const errorOrAbortStream = (stream, error)=>{
        if (isAbortError(error)) abortStream(stream);
        else errorStream(stream, error);
    };
    const isAbortError = (error)=>error?.code === 'ERR_STREAM_PREMATURE_CLOSE';
    const abortStream = (stream)=>{
        if (stream.readable || stream.writable) stream.destroy();
    };
    const errorStream = (stream, error)=>{
        if (!stream.destroyed) {
            stream.once('error', noop);
            stream.destroy(error);
        }
    };
    const noop = ()=>{};
    const updateMaxListeners = (passThroughStream, increment)=>{
        const maxListeners = passThroughStream.getMaxListeners();
        if (0 !== maxListeners && maxListeners !== 1 / 0) passThroughStream.setMaxListeners(maxListeners + increment);
    };
    const PASSTHROUGH_LISTENERS_COUNT = 2;
    const PASSTHROUGH_LISTENERS_PER_STREAM = 1;
    const pipeStreams = (source, destination)=>{
        source.pipe(destination);
        onSourceFinish(source, destination);
        onDestinationFinish(source, destination);
    };
    const onSourceFinish = async (source, destination)=>{
        if (isStandardStream(source) || isStandardStream(destination)) return;
        try {
            await (0, external_node_stream_promises_namespaceObject.finished)(source, {
                cleanup: true,
                readable: true,
                writable: false
            });
        } catch  {}
        endDestinationStream(destination);
    };
    const endDestinationStream = (destination)=>{
        if (destination.writable) destination.end();
    };
    const onDestinationFinish = async (source, destination)=>{
        if (isStandardStream(source) || isStandardStream(destination)) return;
        try {
            await (0, external_node_stream_promises_namespaceObject.finished)(destination, {
                cleanup: true,
                readable: false,
                writable: true
            });
        } catch  {}
        abortSourceStream(source);
    };
    const abortSourceStream = (source)=>{
        if (source.readable) source.destroy();
    };
    const pipeOutputAsync = (subprocess, fileDescriptors, controller)=>{
        const pipeGroups = new Map();
        for (const [fdNumber, { stdioItems, direction }] of Object.entries(fileDescriptors)){
            for (const { stream } of stdioItems.filter(({ type })=>TRANSFORM_TYPES.has(type)))pipeTransform(subprocess, stream, direction, fdNumber);
            for (const { stream } of stdioItems.filter(({ type })=>!TRANSFORM_TYPES.has(type)))pipeStdioItem({
                subprocess,
                stream,
                direction,
                fdNumber,
                pipeGroups,
                controller
            });
        }
        for (const [outputStream, inputStreams] of pipeGroups.entries()){
            const inputStream = 1 === inputStreams.length ? inputStreams[0] : mergeStreams(inputStreams);
            pipeStreams(inputStream, outputStream);
        }
    };
    const pipeTransform = (subprocess, stream, direction, fdNumber)=>{
        'output' === direction ? pipeStreams(subprocess.stdio[fdNumber], stream) : pipeStreams(stream, subprocess.stdio[fdNumber]);
        const streamProperty = SUBPROCESS_STREAM_PROPERTIES[fdNumber];
        if (void 0 !== streamProperty) subprocess[streamProperty] = stream;
        subprocess.stdio[fdNumber] = stream;
    };
    const SUBPROCESS_STREAM_PROPERTIES = [
        'stdin',
        'stdout',
        'stderr'
    ];
    const pipeStdioItem = ({ subprocess, stream, direction, fdNumber, pipeGroups, controller })=>{
        if (void 0 === stream) return;
        setStandardStreamMaxListeners(stream, controller);
        const [inputStream, outputStream] = 'output' === direction ? [
            stream,
            subprocess.stdio[fdNumber]
        ] : [
            subprocess.stdio[fdNumber],
            stream
        ];
        const outputStreams = pipeGroups.get(inputStream) ?? [];
        pipeGroups.set(inputStream, [
            ...outputStreams,
            outputStream
        ]);
    };
    const setStandardStreamMaxListeners = (stream, { signal })=>{
        if (isStandardStream(stream)) incrementMaxListeners(stream, MAX_LISTENERS_INCREMENT, signal);
    };
    const MAX_LISTENERS_INCREMENT = 2;
    const signals_signals = [];
    signals_signals.push('SIGHUP', 'SIGINT', 'SIGTERM');
    if ('win32' !== process.platform) signals_signals.push('SIGALRM', 'SIGABRT', 'SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT');
    if ('linux' === process.platform) signals_signals.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT');
    const processOk = (process1)=>!!process1 && 'object' == typeof process1 && 'function' == typeof process1.removeListener && 'function' == typeof process1.emit && 'function' == typeof process1.reallyExit && 'function' == typeof process1.listeners && 'function' == typeof process1.kill && 'number' == typeof process1.pid && 'function' == typeof process1.on;
    const kExitEmitter = Symbol.for('signal-exit emitter');
    const global1 = globalThis;
    const ObjectDefineProperty = Object.defineProperty.bind(Object);
    class Emitter {
        emitted = {
            afterExit: false,
            exit: false
        };
        listeners = {
            afterExit: [],
            exit: []
        };
        count = 0;
        id = Math.random();
        constructor(){
            if (global1[kExitEmitter]) return global1[kExitEmitter];
            ObjectDefineProperty(global1, kExitEmitter, {
                value: this,
                writable: false,
                enumerable: false,
                configurable: false
            });
        }
        on(ev, fn) {
            this.listeners[ev].push(fn);
        }
        removeListener(ev, fn) {
            const list = this.listeners[ev];
            const i = list.indexOf(fn);
            if (-1 === i) return;
            if (0 === i && 1 === list.length) list.length = 0;
            else list.splice(i, 1);
        }
        emit(ev, code, signal) {
            if (this.emitted[ev]) return false;
            this.emitted[ev] = true;
            let ret = false;
            for (const fn of this.listeners[ev])ret = true === fn(code, signal) || ret;
            if ('exit' === ev) ret = this.emit('afterExit', code, signal) || ret;
            return ret;
        }
    }
    class SignalExitBase {
    }
    const signalExitWrap = (handler)=>({
            onExit (cb, opts) {
                return handler.onExit(cb, opts);
            },
            load () {
                return handler.load();
            },
            unload () {
                return handler.unload();
            }
        });
    class SignalExitFallback extends SignalExitBase {
        onExit() {
            return ()=>{};
        }
        load() {}
        unload() {}
    }
    class SignalExit extends SignalExitBase {
        #hupSig = 'win32' === mjs_process.platform ? 'SIGINT' : 'SIGHUP';
        #emitter = new Emitter();
        #process;
        #originalProcessEmit;
        #originalProcessReallyExit;
        #sigListeners = {};
        #loaded = false;
        constructor(process1){
            super();
            this.#process = process1;
            this.#sigListeners = {};
            for (const sig of signals_signals)this.#sigListeners[sig] = ()=>{
                const listeners = this.#process.listeners(sig);
                let { count } = this.#emitter;
                const p = process1;
                if ('object' == typeof p.__signal_exit_emitter__ && 'number' == typeof p.__signal_exit_emitter__.count) count += p.__signal_exit_emitter__.count;
                if (listeners.length === count) {
                    this.unload();
                    const ret = this.#emitter.emit('exit', null, sig);
                    const s = 'SIGHUP' === sig ? this.#hupSig : sig;
                    if (!ret) process1.kill(process1.pid, s);
                }
            };
            this.#originalProcessReallyExit = process1.reallyExit;
            this.#originalProcessEmit = process1.emit;
        }
        onExit(cb, opts) {
            if (!processOk(this.#process)) return ()=>{};
            if (false === this.#loaded) this.load();
            const ev = opts?.alwaysLast ? 'afterExit' : 'exit';
            this.#emitter.on(ev, cb);
            return ()=>{
                this.#emitter.removeListener(ev, cb);
                if (0 === this.#emitter.listeners['exit'].length && 0 === this.#emitter.listeners['afterExit'].length) this.unload();
            };
        }
        load() {
            if (this.#loaded) return;
            this.#loaded = true;
            this.#emitter.count += 1;
            for (const sig of signals_signals)try {
                const fn = this.#sigListeners[sig];
                if (fn) this.#process.on(sig, fn);
            } catch (_) {}
            this.#process.emit = (ev, ...a)=>this.#processEmit(ev, ...a);
            this.#process.reallyExit = (code)=>this.#processReallyExit(code);
        }
        unload() {
            if (!this.#loaded) return;
            this.#loaded = false;
            signals_signals.forEach((sig)=>{
                const listener = this.#sigListeners[sig];
                if (!listener) throw new Error('Listener not defined for signal: ' + sig);
                try {
                    this.#process.removeListener(sig, listener);
                } catch (_) {}
            });
            this.#process.emit = this.#originalProcessEmit;
            this.#process.reallyExit = this.#originalProcessReallyExit;
            this.#emitter.count -= 1;
        }
        #processReallyExit(code) {
            if (!processOk(this.#process)) return 0;
            this.#process.exitCode = code || 0;
            this.#emitter.emit('exit', this.#process.exitCode, null);
            return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
        }
        #processEmit(ev, ...args) {
            const og = this.#originalProcessEmit;
            if (!('exit' === ev && processOk(this.#process))) return og.call(this.#process, ev, ...args);
            {
                if ('number' == typeof args[0]) this.#process.exitCode = args[0];
                const ret = og.call(this.#process, ev, ...args);
                this.#emitter.emit('exit', this.#process.exitCode, null);
                return ret;
            }
        }
    }
    const mjs_process = globalThis.process;
    const { onExit, load, unload } = signalExitWrap(processOk(mjs_process) ? new SignalExit(mjs_process) : new SignalExitFallback());
    const cleanupOnExit = (subprocess, { cleanup, detached }, { signal })=>{
        if (!cleanup || detached) return;
        const removeExitHandler = onExit(()=>{
            subprocess.kill();
        });
        (0, external_node_events_.addAbortListener)(signal, ()=>{
            removeExitHandler();
        });
    };
    const normalizePipeArguments = ({ source, sourcePromise, boundOptions, createNested }, ...pipeArguments)=>{
        const startTime = getStartTime();
        const { destination, destinationStream, destinationError, from, unpipeSignal } = getDestinationStream(boundOptions, createNested, pipeArguments);
        const { sourceStream, sourceError } = getSourceStream(source, from);
        const { options: sourceOptions, fileDescriptors } = SUBPROCESS_OPTIONS.get(source);
        return {
            sourcePromise,
            sourceStream,
            sourceOptions,
            sourceError,
            destination,
            destinationStream,
            destinationError,
            unpipeSignal,
            fileDescriptors,
            startTime
        };
    };
    const getDestinationStream = (boundOptions, createNested, pipeArguments)=>{
        try {
            const { destination, pipeOptions: { from, to, unpipeSignal } = {} } = getDestination(boundOptions, createNested, ...pipeArguments);
            const destinationStream = getToStream(destination, to);
            return {
                destination,
                destinationStream,
                from,
                unpipeSignal
            };
        } catch (error) {
            return {
                destinationError: error
            };
        }
    };
    const getDestination = (boundOptions, createNested, firstArgument, ...pipeArguments)=>{
        if (Array.isArray(firstArgument)) {
            const destination = createNested(mapDestinationArguments, boundOptions)(firstArgument, ...pipeArguments);
            return {
                destination,
                pipeOptions: boundOptions
            };
        }
        if ('string' == typeof firstArgument || firstArgument instanceof URL || isDenoExecPath(firstArgument)) {
            if (Object.keys(boundOptions).length > 0) throw new TypeError('Please use .pipe("file", ..., options) or .pipe(execa("file", ..., options)) instead of .pipe(options)("file", ...).');
            const [rawFile, rawArguments, rawOptions] = normalizeParameters(firstArgument, ...pipeArguments);
            const destination = createNested(mapDestinationArguments)(rawFile, rawArguments, rawOptions);
            return {
                destination,
                pipeOptions: rawOptions
            };
        }
        if (SUBPROCESS_OPTIONS.has(firstArgument)) {
            if (Object.keys(boundOptions).length > 0) throw new TypeError('Please use .pipe(options)`command` or .pipe($(options)`command`) instead of .pipe(options)($`command`).');
            return {
                destination: firstArgument,
                pipeOptions: pipeArguments[0]
            };
        }
        throw new TypeError(`The first argument must be a template string, an options object, or an Execa subprocess: ${firstArgument}`);
    };
    const mapDestinationArguments = ({ options })=>({
            options: {
                ...options,
                stdin: 'pipe',
                piped: true
            }
        });
    const getSourceStream = (source, from)=>{
        try {
            const sourceStream = getFromStream(source, from);
            return {
                sourceStream
            };
        } catch (error) {
            return {
                sourceError: error
            };
        }
    };
    const handlePipeArgumentsError = ({ sourceStream, sourceError, destinationStream, destinationError, fileDescriptors, sourceOptions, startTime })=>{
        const error = getPipeArgumentsError({
            sourceStream,
            sourceError,
            destinationStream,
            destinationError
        });
        if (void 0 !== error) throw createNonCommandError({
            error,
            fileDescriptors,
            sourceOptions,
            startTime
        });
    };
    const getPipeArgumentsError = ({ sourceStream, sourceError, destinationStream, destinationError })=>{
        if (void 0 !== sourceError && void 0 !== destinationError) return destinationError;
        if (void 0 !== destinationError) {
            abortSourceStream(sourceStream);
            return destinationError;
        }
        if (void 0 !== sourceError) {
            endDestinationStream(destinationStream);
            return sourceError;
        }
    };
    const createNonCommandError = ({ error, fileDescriptors, sourceOptions, startTime })=>makeEarlyError({
            error,
            command: PIPE_COMMAND_MESSAGE,
            escapedCommand: PIPE_COMMAND_MESSAGE,
            fileDescriptors,
            options: sourceOptions,
            startTime,
            isSync: false
        });
    const PIPE_COMMAND_MESSAGE = 'source.pipe(destination)';
    const waitForBothSubprocesses = async (subprocessPromises)=>{
        const [{ status: sourceStatus, reason: sourceReason, value: sourceResult = sourceReason }, { status: destinationStatus, reason: destinationReason, value: destinationResult = destinationReason }] = await subprocessPromises;
        if (!destinationResult.pipedFrom.includes(sourceResult)) destinationResult.pipedFrom.push(sourceResult);
        if ('rejected' === destinationStatus) throw destinationResult;
        if ('rejected' === sourceStatus) throw sourceResult;
        return destinationResult;
    };
    const pipeSubprocessStream = (sourceStream, destinationStream, maxListenersController)=>{
        const mergedStream = MERGED_STREAMS.has(destinationStream) ? pipeMoreSubprocessStream(sourceStream, destinationStream) : pipeFirstSubprocessStream(sourceStream, destinationStream);
        incrementMaxListeners(sourceStream, SOURCE_LISTENERS_PER_PIPE, maxListenersController.signal);
        incrementMaxListeners(destinationStream, DESTINATION_LISTENERS_PER_PIPE, maxListenersController.signal);
        cleanupMergedStreamsMap(destinationStream);
        return mergedStream;
    };
    const pipeFirstSubprocessStream = (sourceStream, destinationStream)=>{
        const mergedStream = mergeStreams([
            sourceStream
        ]);
        pipeStreams(mergedStream, destinationStream);
        MERGED_STREAMS.set(destinationStream, mergedStream);
        return mergedStream;
    };
    const pipeMoreSubprocessStream = (sourceStream, destinationStream)=>{
        const mergedStream = MERGED_STREAMS.get(destinationStream);
        mergedStream.add(sourceStream);
        return mergedStream;
    };
    const cleanupMergedStreamsMap = async (destinationStream)=>{
        try {
            await (0, external_node_stream_promises_namespaceObject.finished)(destinationStream, {
                cleanup: true,
                readable: false,
                writable: true
            });
        } catch  {}
        MERGED_STREAMS.delete(destinationStream);
    };
    const MERGED_STREAMS = new WeakMap();
    const SOURCE_LISTENERS_PER_PIPE = 2;
    const DESTINATION_LISTENERS_PER_PIPE = 1;
    const unpipeOnAbort = (unpipeSignal, unpipeContext)=>void 0 === unpipeSignal ? [] : [
            unpipeOnSignalAbort(unpipeSignal, unpipeContext)
        ];
    const unpipeOnSignalAbort = async (unpipeSignal, { sourceStream, mergedStream, fileDescriptors, sourceOptions, startTime })=>{
        await (0, external_node_util_.aborted)(unpipeSignal, sourceStream);
        await mergedStream.remove(sourceStream);
        const error = new Error('Pipe canceled by `unpipeSignal` option.');
        throw createNonCommandError({
            error,
            fileDescriptors,
            sourceOptions,
            startTime
        });
    };
    const pipeToSubprocess = (sourceInfo, ...pipeArguments)=>{
        if (isPlainObject(pipeArguments[0])) return pipeToSubprocess.bind(void 0, {
            ...sourceInfo,
            boundOptions: {
                ...sourceInfo.boundOptions,
                ...pipeArguments[0]
            }
        });
        const { destination, ...normalizedInfo } = normalizePipeArguments(sourceInfo, ...pipeArguments);
        const promise = handlePipePromise({
            ...normalizedInfo,
            destination
        });
        promise.pipe = pipeToSubprocess.bind(void 0, {
            ...sourceInfo,
            source: destination,
            sourcePromise: promise,
            boundOptions: {}
        });
        return promise;
    };
    const handlePipePromise = async ({ sourcePromise, sourceStream, sourceOptions, sourceError, destination, destinationStream, destinationError, unpipeSignal, fileDescriptors, startTime })=>{
        const subprocessPromises = getSubprocessPromises(sourcePromise, destination);
        handlePipeArgumentsError({
            sourceStream,
            sourceError,
            destinationStream,
            destinationError,
            fileDescriptors,
            sourceOptions,
            startTime
        });
        const maxListenersController = new AbortController();
        try {
            const mergedStream = pipeSubprocessStream(sourceStream, destinationStream, maxListenersController);
            return await Promise.race([
                waitForBothSubprocesses(subprocessPromises),
                ...unpipeOnAbort(unpipeSignal, {
                    sourceStream,
                    mergedStream,
                    sourceOptions,
                    fileDescriptors,
                    startTime
                })
            ]);
        } finally{
            maxListenersController.abort();
        }
    };
    const getSubprocessPromises = (sourcePromise, destination)=>Promise.allSettled([
            sourcePromise,
            destination
        ]);
    const utils_identity = (value)=>value;
    const utils_noop = ()=>void 0;
    const getContentsProperty = ({ contents })=>contents;
    const throwObjectStream = (chunk)=>{
        throw new Error(`Streams in object mode are not supported: ${String(chunk)}`);
    };
    const getLengthProperty = (convertedChunk)=>convertedChunk.length;
    async function getStreamAsArray(stream, options) {
        return getStreamContents(stream, arrayMethods, options);
    }
    const initArray = ()=>({
            contents: []
        });
    const array_increment = ()=>1;
    const addArrayChunk = (convertedChunk, { contents })=>{
        contents.push(convertedChunk);
        return contents;
    };
    const arrayMethods = {
        init: initArray,
        convertChunk: {
            string: utils_identity,
            buffer: utils_identity,
            arrayBuffer: utils_identity,
            dataView: utils_identity,
            typedArray: utils_identity,
            others: utils_identity
        },
        getSize: array_increment,
        truncateChunk: utils_noop,
        addChunk: addArrayChunk,
        getFinalChunk: utils_noop,
        finalize: getContentsProperty
    };
    async function getStreamAsArrayBuffer(stream, options) {
        return getStreamContents(stream, arrayBufferMethods, options);
    }
    const initArrayBuffer = ()=>({
            contents: new ArrayBuffer(0)
        });
    const useTextEncoder = (chunk)=>array_buffer_textEncoder.encode(chunk);
    const array_buffer_textEncoder = new TextEncoder();
    const useUint8Array = (chunk)=>new Uint8Array(chunk);
    const useUint8ArrayWithOffset = (chunk)=>new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    const truncateArrayBufferChunk = (convertedChunk, chunkSize)=>convertedChunk.slice(0, chunkSize);
    const addArrayBufferChunk = (convertedChunk, { contents, length: previousLength }, length)=>{
        const newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);
        new Uint8Array(newContents).set(convertedChunk, previousLength);
        return newContents;
    };
    const resizeArrayBufferSlow = (contents, length)=>{
        if (length <= contents.byteLength) return contents;
        const arrayBuffer = new ArrayBuffer(getNewContentsLength(length));
        new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
        return arrayBuffer;
    };
    const resizeArrayBuffer = (contents, length)=>{
        if (length <= contents.maxByteLength) {
            contents.resize(length);
            return contents;
        }
        const arrayBuffer = new ArrayBuffer(length, {
            maxByteLength: getNewContentsLength(length)
        });
        new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
        return arrayBuffer;
    };
    const getNewContentsLength = (length)=>SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));
    const SCALE_FACTOR = 2;
    const finalizeArrayBuffer = ({ contents, length })=>hasArrayBufferResize() ? contents : contents.slice(0, length);
    const hasArrayBufferResize = ()=>'resize' in ArrayBuffer.prototype;
    const arrayBufferMethods = {
        init: initArrayBuffer,
        convertChunk: {
            string: useTextEncoder,
            buffer: useUint8Array,
            arrayBuffer: useUint8Array,
            dataView: useUint8ArrayWithOffset,
            typedArray: useUint8ArrayWithOffset,
            others: throwObjectStream
        },
        getSize: getLengthProperty,
        truncateChunk: truncateArrayBufferChunk,
        addChunk: addArrayBufferChunk,
        getFinalChunk: utils_noop,
        finalize: finalizeArrayBuffer
    };
    async function getStreamAsString(stream, options) {
        return getStreamContents(stream, stringMethods, options);
    }
    const initString = ()=>({
            contents: '',
            textDecoder: new TextDecoder()
        });
    const useTextDecoder = (chunk, { textDecoder })=>textDecoder.decode(chunk, {
            stream: true
        });
    const addStringChunk = (convertedChunk, { contents })=>contents + convertedChunk;
    const truncateStringChunk = (convertedChunk, chunkSize)=>convertedChunk.slice(0, chunkSize);
    const getFinalStringChunk = ({ textDecoder })=>{
        const finalChunk = textDecoder.decode();
        return '' === finalChunk ? void 0 : finalChunk;
    };
    const stringMethods = {
        init: initString,
        convertChunk: {
            string: utils_identity,
            buffer: useTextDecoder,
            arrayBuffer: useTextDecoder,
            dataView: useTextDecoder,
            typedArray: useTextDecoder,
            others: throwObjectStream
        },
        getSize: getLengthProperty,
        truncateChunk: truncateStringChunk,
        addChunk: addStringChunk,
        getFinalChunk: getFinalStringChunk,
        finalize: getContentsProperty
    };
    const iterateOnSubprocessStream = ({ subprocessStdout, subprocess, binary, shouldEncode, encoding, preserveNewlines })=>{
        const controller = new AbortController();
        stopReadingOnExit(subprocess, controller);
        return iterateOnStream({
            stream: subprocessStdout,
            controller,
            binary,
            shouldEncode: !subprocessStdout.readableObjectMode && shouldEncode,
            encoding,
            shouldSplit: !subprocessStdout.readableObjectMode,
            preserveNewlines
        });
    };
    const stopReadingOnExit = async (subprocess, controller)=>{
        try {
            await subprocess;
        } catch  {} finally{
            controller.abort();
        }
    };
    const iterateForResult = ({ stream, onStreamEnd, lines, encoding, stripFinalNewline, allMixed })=>{
        const controller = new AbortController();
        stopReadingOnStreamEnd(onStreamEnd, controller, stream);
        const objectMode = stream.readableObjectMode && !allMixed;
        return iterateOnStream({
            stream,
            controller,
            binary: 'buffer' === encoding,
            shouldEncode: !objectMode,
            encoding,
            shouldSplit: !objectMode && lines,
            preserveNewlines: !stripFinalNewline
        });
    };
    const stopReadingOnStreamEnd = async (onStreamEnd, controller, stream)=>{
        try {
            await onStreamEnd;
        } catch  {
            stream.destroy();
        } finally{
            controller.abort();
        }
    };
    const iterateOnStream = ({ stream, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines })=>{
        const onStdoutChunk = (0, external_node_events_.on)(stream, 'data', {
            signal: controller.signal,
            highWaterMark: HIGH_WATER_MARK,
            highWatermark: HIGH_WATER_MARK
        });
        return iterateOnData({
            onStdoutChunk,
            controller,
            binary,
            shouldEncode,
            encoding,
            shouldSplit,
            preserveNewlines
        });
    };
    const DEFAULT_OBJECT_HIGH_WATER_MARK = (0, external_node_stream_.getDefaultHighWaterMark)(true);
    const HIGH_WATER_MARK = DEFAULT_OBJECT_HIGH_WATER_MARK;
    const iterateOnData = async function*({ onStdoutChunk, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) {
        const generators = getGenerators({
            binary,
            shouldEncode,
            encoding,
            shouldSplit,
            preserveNewlines
        });
        try {
            for await (const [chunk] of onStdoutChunk)yield* transformChunkSync(chunk, generators, 0);
        } catch (error) {
            if (!controller.signal.aborted) throw error;
        } finally{
            yield* finalChunksSync(generators);
        }
    };
    const getGenerators = ({ binary, shouldEncode, encoding, shouldSplit, preserveNewlines })=>[
            getEncodingTransformGenerator(binary, encoding, !shouldEncode),
            getSplitLinesGenerator(binary, preserveNewlines, !shouldSplit, {})
        ].filter(Boolean);
    const getStreamOutput = async ({ stream, onStreamEnd, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline, verboseInfo, streamInfo })=>{
        const logPromise = logOutputAsync({
            stream,
            onStreamEnd,
            fdNumber,
            encoding,
            allMixed,
            verboseInfo,
            streamInfo
        });
        if (!buffer) return void await Promise.all([
            resumeStream(stream),
            logPromise
        ]);
        const stripFinalNewlineValue = getStripFinalNewline(stripFinalNewline, fdNumber);
        const iterable = iterateForResult({
            stream,
            onStreamEnd,
            lines,
            encoding,
            stripFinalNewline: stripFinalNewlineValue,
            allMixed
        });
        const [output] = await Promise.all([
            contents_getStreamContents({
                stream,
                iterable,
                fdNumber,
                encoding,
                maxBuffer,
                lines
            }),
            logPromise
        ]);
        return output;
    };
    const logOutputAsync = async ({ stream, onStreamEnd, fdNumber, encoding, allMixed, verboseInfo, streamInfo: { fileDescriptors } })=>{
        if (!shouldLogOutput({
            stdioItems: fileDescriptors[fdNumber]?.stdioItems,
            encoding,
            verboseInfo,
            fdNumber
        })) return;
        const linesIterable = iterateForResult({
            stream,
            onStreamEnd,
            lines: true,
            encoding,
            stripFinalNewline: true,
            allMixed
        });
        await logLines(linesIterable, stream, fdNumber, verboseInfo);
    };
    const resumeStream = async (stream)=>{
        await (0, external_node_timers_promises_namespaceObject.setImmediate)();
        if (null === stream.readableFlowing) stream.resume();
    };
    const contents_getStreamContents = async ({ stream, stream: { readableObjectMode }, iterable, fdNumber, encoding, maxBuffer, lines })=>{
        try {
            if (readableObjectMode || lines) return await getStreamAsArray(iterable, {
                maxBuffer
            });
            if ('buffer' === encoding) return new Uint8Array(await getStreamAsArrayBuffer(iterable, {
                maxBuffer
            }));
            return await getStreamAsString(iterable, {
                maxBuffer
            });
        } catch (error) {
            return handleBufferedData(handleMaxBuffer({
                error,
                stream,
                readableObjectMode,
                lines,
                encoding,
                fdNumber
            }));
        }
    };
    const getBufferedData = async (streamPromise)=>{
        try {
            return await streamPromise;
        } catch (error) {
            return handleBufferedData(error);
        }
    };
    const handleBufferedData = ({ bufferedData })=>isArrayBuffer(bufferedData) ? new Uint8Array(bufferedData) : bufferedData;
    const waitForStream = async (stream, fdNumber, streamInfo, { isSameDirection, stopOnExit = false } = {})=>{
        const state = handleStdinDestroy(stream, streamInfo);
        const abortController = new AbortController();
        try {
            await Promise.race([
                ...stopOnExit ? [
                    streamInfo.exitPromise
                ] : [],
                (0, external_node_stream_promises_namespaceObject.finished)(stream, {
                    cleanup: true,
                    signal: abortController.signal
                })
            ]);
        } catch (error) {
            if (!state.stdinCleanedUp) handleStreamError(error, fdNumber, streamInfo, isSameDirection);
        } finally{
            abortController.abort();
        }
    };
    const handleStdinDestroy = (stream, { originalStreams: [originalStdin], subprocess })=>{
        const state = {
            stdinCleanedUp: false
        };
        if (stream === originalStdin) spyOnStdinDestroy(stream, subprocess, state);
        return state;
    };
    const spyOnStdinDestroy = (subprocessStdin, subprocess, state)=>{
        const { _destroy } = subprocessStdin;
        subprocessStdin._destroy = (...destroyArguments)=>{
            setStdinCleanedUp(subprocess, state);
            _destroy.call(subprocessStdin, ...destroyArguments);
        };
    };
    const setStdinCleanedUp = ({ exitCode, signalCode }, state)=>{
        if (null !== exitCode || null !== signalCode) state.stdinCleanedUp = true;
    };
    const handleStreamError = (error, fdNumber, streamInfo, isSameDirection)=>{
        if (!shouldIgnoreStreamError(error, fdNumber, streamInfo, isSameDirection)) throw error;
    };
    const shouldIgnoreStreamError = (error, fdNumber, streamInfo, isSameDirection = true)=>{
        if (streamInfo.propagating) return isStreamEpipe(error) || isStreamAbort(error);
        streamInfo.propagating = true;
        return isInputFileDescriptor(streamInfo, fdNumber) === isSameDirection ? isStreamEpipe(error) : isStreamAbort(error);
    };
    const isInputFileDescriptor = ({ fileDescriptors }, fdNumber)=>'all' !== fdNumber && 'input' === fileDescriptors[fdNumber].direction;
    const isStreamAbort = (error)=>error?.code === 'ERR_STREAM_PREMATURE_CLOSE';
    const isStreamEpipe = (error)=>error?.code === 'EPIPE';
    const waitForStdioStreams = ({ subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline, verboseInfo, streamInfo })=>subprocess.stdio.map((stream, fdNumber)=>waitForSubprocessStream({
                stream,
                fdNumber,
                encoding,
                buffer: buffer[fdNumber],
                maxBuffer: maxBuffer[fdNumber],
                lines: lines[fdNumber],
                allMixed: false,
                stripFinalNewline,
                verboseInfo,
                streamInfo
            }));
    const waitForSubprocessStream = async ({ stream, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline, verboseInfo, streamInfo })=>{
        if (!stream) return;
        const onStreamEnd = waitForStream(stream, fdNumber, streamInfo);
        if (isInputFileDescriptor(streamInfo, fdNumber)) return void await onStreamEnd;
        const [output] = await Promise.all([
            getStreamOutput({
                stream,
                onStreamEnd,
                fdNumber,
                encoding,
                buffer,
                maxBuffer,
                lines,
                allMixed,
                stripFinalNewline,
                verboseInfo,
                streamInfo
            }),
            onStreamEnd
        ]);
        return output;
    };
    const makeAllStream = ({ stdout, stderr }, { all })=>all && (stdout || stderr) ? mergeStreams([
            stdout,
            stderr
        ].filter(Boolean)) : void 0;
    const waitForAllStream = ({ subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline, verboseInfo, streamInfo })=>waitForSubprocessStream({
            ...getAllStream(subprocess, buffer),
            fdNumber: 'all',
            encoding,
            maxBuffer: maxBuffer[1] + maxBuffer[2],
            lines: lines[1] || lines[2],
            allMixed: getAllMixed(subprocess),
            stripFinalNewline,
            verboseInfo,
            streamInfo
        });
    const getAllStream = ({ stdout, stderr, all }, [, bufferStdout, bufferStderr])=>{
        const buffer = bufferStdout || bufferStderr;
        if (!buffer) return {
            stream: all,
            buffer
        };
        if (!bufferStdout) return {
            stream: stderr,
            buffer
        };
        if (!bufferStderr) return {
            stream: stdout,
            buffer
        };
        return {
            stream: all,
            buffer
        };
    };
    const getAllMixed = ({ all, stdout, stderr })=>all && stdout && stderr && stdout.readableObjectMode !== stderr.readableObjectMode;
    const shouldLogIpc = (verboseInfo)=>isFullVerbose(verboseInfo, 'ipc');
    const logIpcOutput = (message, verboseInfo)=>{
        const verboseMessage = serializeVerboseMessage(message);
        verboseLog({
            type: 'ipc',
            verboseMessage,
            fdNumber: 'ipc',
            verboseInfo
        });
    };
    const waitForIpcOutput = async ({ subprocess, buffer: bufferArray, maxBuffer: maxBufferArray, ipc, ipcOutput, verboseInfo })=>{
        if (!ipc) return ipcOutput;
        const isVerbose = shouldLogIpc(verboseInfo);
        const buffer = getFdSpecificValue(bufferArray, 'ipc');
        const maxBuffer = getFdSpecificValue(maxBufferArray, 'ipc');
        for await (const message of loopOnMessages({
            anyProcess: subprocess,
            channel: subprocess.channel,
            isSubprocess: false,
            ipc,
            shouldAwait: false,
            reference: true
        })){
            if (buffer) {
                checkIpcMaxBuffer(subprocess, ipcOutput, maxBuffer);
                ipcOutput.push(message);
            }
            if (isVerbose) logIpcOutput(message, verboseInfo);
        }
        return ipcOutput;
    };
    const getBufferedIpcOutput = async (ipcOutputPromise, ipcOutput)=>{
        await Promise.allSettled([
            ipcOutputPromise
        ]);
        return ipcOutput;
    };
    const waitForSubprocessResult = async ({ subprocess, options: { encoding, buffer, maxBuffer, lines, timeoutDuration: timeout, cancelSignal, gracefulCancel, forceKillAfterDelay, stripFinalNewline, ipc, ipcInput }, context, verboseInfo, fileDescriptors, originalStreams, onInternalError, controller })=>{
        const exitPromise = waitForExit(subprocess, context);
        const streamInfo = {
            originalStreams,
            fileDescriptors,
            subprocess,
            exitPromise,
            propagating: false
        };
        const stdioPromises = waitForStdioStreams({
            subprocess,
            encoding,
            buffer,
            maxBuffer,
            lines,
            stripFinalNewline,
            verboseInfo,
            streamInfo
        });
        const allPromise = waitForAllStream({
            subprocess,
            encoding,
            buffer,
            maxBuffer,
            lines,
            stripFinalNewline,
            verboseInfo,
            streamInfo
        });
        const ipcOutput = [];
        const ipcOutputPromise = waitForIpcOutput({
            subprocess,
            buffer,
            maxBuffer,
            ipc,
            ipcOutput,
            verboseInfo
        });
        const originalPromises = waitForOriginalStreams(originalStreams, subprocess, streamInfo);
        const customStreamsEndPromises = waitForCustomStreamsEnd(fileDescriptors, streamInfo);
        try {
            return await Promise.race([
                Promise.all([
                    {},
                    waitForSuccessfulExit(exitPromise),
                    Promise.all(stdioPromises),
                    allPromise,
                    ipcOutputPromise,
                    sendIpcInput(subprocess, ipcInput),
                    ...originalPromises,
                    ...customStreamsEndPromises
                ]),
                onInternalError,
                throwOnSubprocessError(subprocess, controller),
                ...throwOnTimeout(subprocess, timeout, context, controller),
                ...throwOnCancel({
                    subprocess,
                    cancelSignal,
                    gracefulCancel,
                    context,
                    controller
                }),
                ...throwOnGracefulCancel({
                    subprocess,
                    cancelSignal,
                    gracefulCancel,
                    forceKillAfterDelay,
                    context,
                    controller
                })
            ]);
        } catch (error) {
            context.terminationReason ??= 'other';
            return Promise.all([
                {
                    error
                },
                exitPromise,
                Promise.all(stdioPromises.map((stdioPromise)=>getBufferedData(stdioPromise))),
                getBufferedData(allPromise),
                getBufferedIpcOutput(ipcOutputPromise, ipcOutput),
                Promise.allSettled(originalPromises),
                Promise.allSettled(customStreamsEndPromises)
            ]);
        }
    };
    const waitForOriginalStreams = (originalStreams, subprocess, streamInfo)=>originalStreams.map((stream, fdNumber)=>stream === subprocess.stdio[fdNumber] ? void 0 : waitForStream(stream, fdNumber, streamInfo));
    const waitForCustomStreamsEnd = (fileDescriptors, streamInfo)=>fileDescriptors.flatMap(({ stdioItems }, fdNumber)=>stdioItems.filter(({ value, stream = value })=>isStream(stream, {
                    checkOpen: false
                }) && !isStandardStream(stream)).map(({ type, value, stream = value })=>waitForStream(stream, fdNumber, streamInfo, {
                    isSameDirection: TRANSFORM_TYPES.has(type),
                    stopOnExit: 'native' === type
                })));
    const throwOnSubprocessError = async (subprocess, { signal })=>{
        const [error] = await (0, external_node_events_.once)(subprocess, 'error', {
            signal
        });
        throw error;
    };
    const initializeConcurrentStreams = ()=>({
            readableDestroy: new WeakMap(),
            writableFinal: new WeakMap(),
            writableDestroy: new WeakMap()
        });
    const addConcurrentStream = (concurrentStreams, stream, waitName)=>{
        const weakMap = concurrentStreams[waitName];
        if (!weakMap.has(stream)) weakMap.set(stream, []);
        const promises = weakMap.get(stream);
        const promise = createDeferred();
        promises.push(promise);
        const resolve = promise.resolve.bind(promise);
        return {
            resolve,
            promises
        };
    };
    const waitForConcurrentStreams = async ({ resolve, promises }, subprocess)=>{
        resolve();
        const [isSubprocessExit] = await Promise.race([
            Promise.allSettled([
                true,
                subprocess
            ]),
            Promise.all([
                false,
                ...promises
            ])
        ]);
        return !isSubprocessExit;
    };
    const safeWaitForSubprocessStdin = async (subprocessStdin)=>{
        if (void 0 === subprocessStdin) return;
        try {
            await waitForSubprocessStdin(subprocessStdin);
        } catch  {}
    };
    const safeWaitForSubprocessStdout = async (subprocessStdout)=>{
        if (void 0 === subprocessStdout) return;
        try {
            await waitForSubprocessStdout(subprocessStdout);
        } catch  {}
    };
    const waitForSubprocessStdin = async (subprocessStdin)=>{
        await (0, external_node_stream_promises_namespaceObject.finished)(subprocessStdin, {
            cleanup: true,
            readable: false,
            writable: true
        });
    };
    const waitForSubprocessStdout = async (subprocessStdout)=>{
        await (0, external_node_stream_promises_namespaceObject.finished)(subprocessStdout, {
            cleanup: true,
            readable: true,
            writable: false
        });
    };
    const waitForSubprocess = async (subprocess, error)=>{
        await subprocess;
        if (error) throw error;
    };
    const destroyOtherStream = (stream, isOpen, error)=>{
        if (error && !isStreamAbort(error)) stream.destroy(error);
        else if (isOpen) stream.destroy();
    };
    const createReadable = ({ subprocess, concurrentStreams, encoding }, { from, binary: binaryOption = true, preserveNewlines = true } = {})=>{
        const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
        const { subprocessStdout, waitReadableDestroy } = getSubprocessStdout(subprocess, from, concurrentStreams);
        const { readableEncoding, readableObjectMode, readableHighWaterMark } = getReadableOptions(subprocessStdout, binary);
        const { read, onStdoutDataDone } = getReadableMethods({
            subprocessStdout,
            subprocess,
            binary,
            encoding,
            preserveNewlines
        });
        const readable = new external_node_stream_.Readable({
            read,
            destroy: (0, external_node_util_.callbackify)(onReadableDestroy.bind(void 0, {
                subprocessStdout,
                subprocess,
                waitReadableDestroy
            })),
            highWaterMark: readableHighWaterMark,
            objectMode: readableObjectMode,
            encoding: readableEncoding
        });
        onStdoutFinished({
            subprocessStdout,
            onStdoutDataDone,
            readable,
            subprocess
        });
        return readable;
    };
    const getSubprocessStdout = (subprocess, from, concurrentStreams)=>{
        const subprocessStdout = getFromStream(subprocess, from);
        const waitReadableDestroy = addConcurrentStream(concurrentStreams, subprocessStdout, 'readableDestroy');
        return {
            subprocessStdout,
            waitReadableDestroy
        };
    };
    const getReadableOptions = ({ readableEncoding, readableObjectMode, readableHighWaterMark }, binary)=>binary ? {
            readableEncoding,
            readableObjectMode,
            readableHighWaterMark
        } : {
            readableEncoding,
            readableObjectMode: true,
            readableHighWaterMark: DEFAULT_OBJECT_HIGH_WATER_MARK
        };
    const getReadableMethods = ({ subprocessStdout, subprocess, binary, encoding, preserveNewlines })=>{
        const onStdoutDataDone = createDeferred();
        const onStdoutData = iterateOnSubprocessStream({
            subprocessStdout,
            subprocess,
            binary,
            shouldEncode: !binary,
            encoding,
            preserveNewlines
        });
        return {
            read () {
                onRead(this, onStdoutData, onStdoutDataDone);
            },
            onStdoutDataDone
        };
    };
    const onRead = async (readable, onStdoutData, onStdoutDataDone)=>{
        try {
            const { value, done } = await onStdoutData.next();
            if (done) onStdoutDataDone.resolve();
            else readable.push(value);
        } catch  {}
    };
    const onStdoutFinished = async ({ subprocessStdout, onStdoutDataDone, readable, subprocess, subprocessStdin })=>{
        try {
            await waitForSubprocessStdout(subprocessStdout);
            await subprocess;
            await safeWaitForSubprocessStdin(subprocessStdin);
            await onStdoutDataDone;
            if (readable.readable) readable.push(null);
        } catch (error) {
            await safeWaitForSubprocessStdin(subprocessStdin);
            destroyOtherReadable(readable, error);
        }
    };
    const onReadableDestroy = async ({ subprocessStdout, subprocess, waitReadableDestroy }, error)=>{
        if (await waitForConcurrentStreams(waitReadableDestroy, subprocess)) {
            destroyOtherReadable(subprocessStdout, error);
            await waitForSubprocess(subprocess, error);
        }
    };
    const destroyOtherReadable = (stream, error)=>{
        destroyOtherStream(stream, stream.readable, error);
    };
    const createWritable = ({ subprocess, concurrentStreams }, { to } = {})=>{
        const { subprocessStdin, waitWritableFinal, waitWritableDestroy } = getSubprocessStdin(subprocess, to, concurrentStreams);
        const writable = new external_node_stream_.Writable({
            ...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),
            destroy: (0, external_node_util_.callbackify)(onWritableDestroy.bind(void 0, {
                subprocessStdin,
                subprocess,
                waitWritableFinal,
                waitWritableDestroy
            })),
            highWaterMark: subprocessStdin.writableHighWaterMark,
            objectMode: subprocessStdin.writableObjectMode
        });
        onStdinFinished(subprocessStdin, writable);
        return writable;
    };
    const getSubprocessStdin = (subprocess, to, concurrentStreams)=>{
        const subprocessStdin = getToStream(subprocess, to);
        const waitWritableFinal = addConcurrentStream(concurrentStreams, subprocessStdin, 'writableFinal');
        const waitWritableDestroy = addConcurrentStream(concurrentStreams, subprocessStdin, 'writableDestroy');
        return {
            subprocessStdin,
            waitWritableFinal,
            waitWritableDestroy
        };
    };
    const getWritableMethods = (subprocessStdin, subprocess, waitWritableFinal)=>({
            write: onWrite.bind(void 0, subprocessStdin),
            final: (0, external_node_util_.callbackify)(onWritableFinal.bind(void 0, subprocessStdin, subprocess, waitWritableFinal))
        });
    const onWrite = (subprocessStdin, chunk, encoding, done)=>{
        if (subprocessStdin.write(chunk, encoding)) done();
        else subprocessStdin.once('drain', done);
    };
    const onWritableFinal = async (subprocessStdin, subprocess, waitWritableFinal)=>{
        if (await waitForConcurrentStreams(waitWritableFinal, subprocess)) {
            if (subprocessStdin.writable) subprocessStdin.end();
            await subprocess;
        }
    };
    const onStdinFinished = async (subprocessStdin, writable, subprocessStdout)=>{
        try {
            await waitForSubprocessStdin(subprocessStdin);
            if (writable.writable) writable.end();
        } catch (error) {
            await safeWaitForSubprocessStdout(subprocessStdout);
            destroyOtherWritable(writable, error);
        }
    };
    const onWritableDestroy = async ({ subprocessStdin, subprocess, waitWritableFinal, waitWritableDestroy }, error)=>{
        await waitForConcurrentStreams(waitWritableFinal, subprocess);
        if (await waitForConcurrentStreams(waitWritableDestroy, subprocess)) {
            destroyOtherWritable(subprocessStdin, error);
            await waitForSubprocess(subprocess, error);
        }
    };
    const destroyOtherWritable = (stream, error)=>{
        destroyOtherStream(stream, stream.writable, error);
    };
    const createDuplex = ({ subprocess, concurrentStreams, encoding }, { from, to, binary: binaryOption = true, preserveNewlines = true } = {})=>{
        const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
        const { subprocessStdout, waitReadableDestroy } = getSubprocessStdout(subprocess, from, concurrentStreams);
        const { subprocessStdin, waitWritableFinal, waitWritableDestroy } = getSubprocessStdin(subprocess, to, concurrentStreams);
        const { readableEncoding, readableObjectMode, readableHighWaterMark } = getReadableOptions(subprocessStdout, binary);
        const { read, onStdoutDataDone } = getReadableMethods({
            subprocessStdout,
            subprocess,
            binary,
            encoding,
            preserveNewlines
        });
        const duplex = new external_node_stream_.Duplex({
            read,
            ...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),
            destroy: (0, external_node_util_.callbackify)(onDuplexDestroy.bind(void 0, {
                subprocessStdout,
                subprocessStdin,
                subprocess,
                waitReadableDestroy,
                waitWritableFinal,
                waitWritableDestroy
            })),
            readableHighWaterMark,
            writableHighWaterMark: subprocessStdin.writableHighWaterMark,
            readableObjectMode,
            writableObjectMode: subprocessStdin.writableObjectMode,
            encoding: readableEncoding
        });
        onStdoutFinished({
            subprocessStdout,
            onStdoutDataDone,
            readable: duplex,
            subprocess,
            subprocessStdin
        });
        onStdinFinished(subprocessStdin, duplex, subprocessStdout);
        return duplex;
    };
    const onDuplexDestroy = async ({ subprocessStdout, subprocessStdin, subprocess, waitReadableDestroy, waitWritableFinal, waitWritableDestroy }, error)=>{
        await Promise.all([
            onReadableDestroy({
                subprocessStdout,
                subprocess,
                waitReadableDestroy
            }, error),
            onWritableDestroy({
                subprocessStdin,
                subprocess,
                waitWritableFinal,
                waitWritableDestroy
            }, error)
        ]);
    };
    const createIterable = (subprocess, encoding, { from, binary: binaryOption = false, preserveNewlines = false } = {})=>{
        const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
        const subprocessStdout = getFromStream(subprocess, from);
        const onStdoutData = iterateOnSubprocessStream({
            subprocessStdout,
            subprocess,
            binary,
            shouldEncode: true,
            encoding,
            preserveNewlines
        });
        return iterateOnStdoutData(onStdoutData, subprocessStdout, subprocess);
    };
    const iterateOnStdoutData = async function*(onStdoutData, subprocessStdout, subprocess) {
        try {
            yield* onStdoutData;
        } finally{
            if (subprocessStdout.readable) subprocessStdout.destroy();
            await subprocess;
        }
    };
    const addConvertedStreams = (subprocess, { encoding })=>{
        const concurrentStreams = initializeConcurrentStreams();
        subprocess.readable = createReadable.bind(void 0, {
            subprocess,
            concurrentStreams,
            encoding
        });
        subprocess.writable = createWritable.bind(void 0, {
            subprocess,
            concurrentStreams
        });
        subprocess.duplex = createDuplex.bind(void 0, {
            subprocess,
            concurrentStreams,
            encoding
        });
        subprocess.iterable = createIterable.bind(void 0, subprocess, encoding);
        subprocess[Symbol.asyncIterator] = createIterable.bind(void 0, subprocess, encoding, {});
    };
    const mergePromise = (subprocess, promise)=>{
        for (const [property, descriptor] of descriptors){
            const value = descriptor.value.bind(promise);
            Reflect.defineProperty(subprocess, property, {
                ...descriptor,
                value
            });
        }
    };
    const nativePromisePrototype = (async ()=>{})().constructor.prototype;
    const descriptors = [
        'then',
        'catch',
        'finally'
    ].map((property)=>[
            property,
            Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
        ]);
    const execaCoreAsync = (rawFile, rawArguments, rawOptions, createNested)=>{
        const { file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors } = handleAsyncArguments(rawFile, rawArguments, rawOptions);
        const { subprocess, promise } = spawnSubprocessAsync({
            file,
            commandArguments,
            options,
            startTime,
            verboseInfo,
            command,
            escapedCommand,
            fileDescriptors
        });
        subprocess.pipe = pipeToSubprocess.bind(void 0, {
            source: subprocess,
            sourcePromise: promise,
            boundOptions: {},
            createNested
        });
        mergePromise(subprocess, promise);
        SUBPROCESS_OPTIONS.set(subprocess, {
            options,
            fileDescriptors
        });
        return subprocess;
    };
    const handleAsyncArguments = (rawFile, rawArguments, rawOptions)=>{
        const { command, escapedCommand, startTime, verboseInfo } = handleCommand(rawFile, rawArguments, rawOptions);
        const { file, commandArguments, options: normalizedOptions } = normalizeOptions(rawFile, rawArguments, rawOptions);
        const options = handleAsyncOptions(normalizedOptions);
        const fileDescriptors = handleStdioAsync(options, verboseInfo);
        return {
            file,
            commandArguments,
            command,
            escapedCommand,
            startTime,
            verboseInfo,
            options,
            fileDescriptors
        };
    };
    const handleAsyncOptions = ({ timeout, signal, ...options })=>{
        if (void 0 !== signal) throw new TypeError('The "signal" option has been renamed to "cancelSignal" instead.');
        return {
            ...options,
            timeoutDuration: timeout
        };
    };
    const spawnSubprocessAsync = ({ file, commandArguments, options, startTime, verboseInfo, command, escapedCommand, fileDescriptors })=>{
        let subprocess;
        try {
            subprocess = (0, external_node_child_process_namespaceObject.spawn)(...concatenateShell(file, commandArguments, options));
        } catch (error) {
            return handleEarlyError({
                error,
                command,
                escapedCommand,
                fileDescriptors,
                options,
                startTime,
                verboseInfo
            });
        }
        const controller = new AbortController();
        (0, external_node_events_.setMaxListeners)(1 / 0, controller.signal);
        const originalStreams = [
            ...subprocess.stdio
        ];
        pipeOutputAsync(subprocess, fileDescriptors, controller);
        cleanupOnExit(subprocess, options, controller);
        const context = {};
        const onInternalError = createDeferred();
        subprocess.kill = subprocessKill.bind(void 0, {
            kill: subprocess.kill.bind(subprocess),
            options,
            onInternalError,
            context,
            controller
        });
        subprocess.all = makeAllStream(subprocess, options);
        addConvertedStreams(subprocess, options);
        addIpcMethods(subprocess, options);
        const promise = handlePromise({
            subprocess,
            options,
            startTime,
            verboseInfo,
            fileDescriptors,
            originalStreams,
            command,
            escapedCommand,
            context,
            onInternalError,
            controller
        });
        return {
            subprocess,
            promise
        };
    };
    const handlePromise = async ({ subprocess, options, startTime, verboseInfo, fileDescriptors, originalStreams, command, escapedCommand, context, onInternalError, controller })=>{
        const [errorInfo, [exitCode, signal], stdioResults, allResult, ipcOutput] = await waitForSubprocessResult({
            subprocess,
            options,
            context,
            verboseInfo,
            fileDescriptors,
            originalStreams,
            onInternalError,
            controller
        });
        controller.abort();
        onInternalError.resolve();
        const stdio = stdioResults.map((stdioResult, fdNumber)=>stripNewline(stdioResult, options, fdNumber));
        const all = stripNewline(allResult, options, 'all');
        const result = getAsyncResult({
            errorInfo,
            exitCode,
            signal,
            stdio,
            all,
            ipcOutput,
            context,
            options,
            command,
            escapedCommand,
            startTime
        });
        return reject_handleResult(result, verboseInfo, options);
    };
    const getAsyncResult = ({ errorInfo, exitCode, signal, stdio, all, ipcOutput, context, options, command, escapedCommand, startTime })=>'error' in errorInfo ? makeError({
            error: errorInfo.error,
            command,
            escapedCommand,
            timedOut: 'timeout' === context.terminationReason,
            isCanceled: 'cancel' === context.terminationReason || 'gracefulCancel' === context.terminationReason,
            isGracefullyCanceled: 'gracefulCancel' === context.terminationReason,
            isMaxBuffer: errorInfo.error instanceof MaxBufferError,
            isForcefullyTerminated: context.isForcefullyTerminated,
            exitCode,
            signal,
            stdio,
            all,
            ipcOutput,
            options,
            startTime,
            isSync: false
        }) : makeSuccessResult({
            command,
            escapedCommand,
            stdio,
            all,
            ipcOutput,
            options,
            startTime
        });
    const mergeOptions = (boundOptions, options)=>{
        const newOptions = Object.fromEntries(Object.entries(options).map(([optionName, optionValue])=>[
                optionName,
                mergeOption(optionName, boundOptions[optionName], optionValue)
            ]));
        return {
            ...boundOptions,
            ...newOptions
        };
    };
    const mergeOption = (optionName, boundOptionValue, optionValue)=>{
        if (DEEP_OPTIONS.has(optionName) && isPlainObject(boundOptionValue) && isPlainObject(optionValue)) return {
            ...boundOptionValue,
            ...optionValue
        };
        return optionValue;
    };
    const DEEP_OPTIONS = new Set([
        'env',
        ...FD_SPECIFIC_OPTIONS
    ]);
    const createExeca = (mapArguments, boundOptions, deepOptions, setBoundExeca)=>{
        const createNested = (mapArguments, boundOptions, setBoundExeca)=>createExeca(mapArguments, boundOptions, deepOptions, setBoundExeca);
        const boundExeca = (...execaArguments)=>callBoundExeca({
                mapArguments,
                deepOptions,
                boundOptions,
                setBoundExeca,
                createNested
            }, ...execaArguments);
        if (void 0 !== setBoundExeca) setBoundExeca(boundExeca, createNested, boundOptions);
        return boundExeca;
    };
    const callBoundExeca = ({ mapArguments, deepOptions = {}, boundOptions = {}, setBoundExeca, createNested }, firstArgument, ...nextArguments)=>{
        if (isPlainObject(firstArgument)) return createNested(mapArguments, mergeOptions(boundOptions, firstArgument), setBoundExeca);
        const { file, commandArguments, options, isSync } = parseArguments({
            mapArguments,
            firstArgument,
            nextArguments,
            deepOptions,
            boundOptions
        });
        return isSync ? execaCoreSync(file, commandArguments, options) : execaCoreAsync(file, commandArguments, options, createNested);
    };
    const parseArguments = ({ mapArguments, firstArgument, nextArguments, deepOptions, boundOptions })=>{
        const callArguments = isTemplateString(firstArgument) ? parseTemplates(firstArgument, nextArguments) : [
            firstArgument,
            ...nextArguments
        ];
        const [initialFile, initialArguments, initialOptions] = normalizeParameters(...callArguments);
        const mergedOptions = mergeOptions(mergeOptions(deepOptions, boundOptions), initialOptions);
        const { file = initialFile, commandArguments = initialArguments, options = mergedOptions, isSync = false } = mapArguments({
            file: initialFile,
            commandArguments: initialArguments,
            options: mergedOptions
        });
        return {
            file,
            commandArguments,
            options,
            isSync
        };
    };
    const mapCommandAsync = ({ file, commandArguments })=>parseCommand(file, commandArguments);
    const mapCommandSync = ({ file, commandArguments })=>({
            ...parseCommand(file, commandArguments),
            isSync: true
        });
    const parseCommand = (command, unusedArguments)=>{
        if (unusedArguments.length > 0) throw new TypeError(`The command and its arguments must be passed as a single string: ${command} ${unusedArguments}.`);
        const [file, ...commandArguments] = parseCommandString(command);
        return {
            file,
            commandArguments
        };
    };
    const parseCommandString = (command)=>{
        if ('string' != typeof command) throw new TypeError(`The command must be a string: ${String(command)}.`);
        const trimmedCommand = command.trim();
        if ('' === trimmedCommand) return [];
        const tokens = [];
        for (const token of trimmedCommand.split(SPACES_REGEXP)){
            const previousToken = tokens.at(-1);
            if (previousToken && previousToken.endsWith('\\')) tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
            else tokens.push(token);
        }
        return tokens;
    };
    const SPACES_REGEXP = / +/g;
    const setScriptSync = (boundExeca, createNested, boundOptions)=>{
        boundExeca.sync = createNested(mapScriptSync, boundOptions);
        boundExeca.s = boundExeca.sync;
    };
    const mapScriptAsync = ({ options })=>getScriptOptions(options);
    const mapScriptSync = ({ options })=>({
            ...getScriptOptions(options),
            isSync: true
        });
    const getScriptOptions = (options)=>({
            options: {
                ...getScriptStdinOption(options),
                ...options
            }
        });
    const getScriptStdinOption = ({ input, inputFile, stdio })=>void 0 === input && void 0 === inputFile && void 0 === stdio ? {
            stdin: 'inherit'
        } : {};
    const deepScriptOptions = {
        preferLocal: true
    };
    createExeca(()=>({}));
    createExeca(()=>({
            isSync: true
        }));
    createExeca(mapCommandAsync);
    createExeca(mapCommandSync);
    createExeca(mapNode);
    const $ = createExeca(mapScriptAsync, {}, deepScriptOptions, setScriptSync);
    const { sendMessage: execa_sendMessage, getOneMessage: execa_getOneMessage, getEachMessage: execa_getEachMessage, getCancelSignal: execa_getCancelSignal } = getIpcExport();
    const index_js_namespaceObject = require("nx/release/index.js");
    function renderVersionTable(projectsVersionData) {
        const rows = Object.entries(projectsVersionData).filter(([, data])=>data.newVersion && data.newVersion !== data.currentVersion).map(([name, data])=>`| \`${name}\` | \`${data.currentVersion}\` | \`${data.newVersion}\` |`);
        if (0 === rows.length) return '';
        const lines = [
            '| Package | Current | New |',
            '|---------|---------|-----|',
            ...rows
        ];
        return lines.join('\n');
    }
    function renderChangesSection(plans) {
        const breaking = [];
        const features = [];
        const fixes = [];
        for (const plan of plans)if ('major' === plan.highestBump) breaking.push(`- ${plan.description}`);
        else if ('minor' === plan.highestBump) features.push(`- ${plan.description}`);
        else fixes.push(`- ${plan.description}`);
        if (0 === breaking.length && 0 === features.length && 0 === fixes.length) return '';
        const sections = [];
        if (breaking.length > 0) sections.push(`### Breaking Changes\n\n${breaking.join('\n')}`);
        if (features.length > 0) sections.push(`### New Features\n\n${features.join('\n')}`);
        if (fixes.length > 0) sections.push(`### Fixes & Improvements\n\n${fixes.join('\n')}`);
        return `## Changes\n\n${sections.join('\n\n')}`;
    }
    function composePrBody(banner, projectsVersionData, plans) {
        const versionTable = renderVersionTable(projectsVersionData);
        const changesSection = renderChangesSection(plans);
        const parts = [];
        if (banner) {
            parts.push(banner);
            parts.push('');
        }
        parts.push('## Release Summary');
        parts.push('');
        if (versionTable) parts.push(versionTable);
        if (changesSection) parts.push(changesSection);
        return parts.join('\n');
    }
    const BUMP_PRIORITY = {
        major: 0,
        minor: 1,
        patch: 2
    };
    function getHighestBump(bumpValues) {
        let highest = 'patch';
        let highestPriority = BUMP_PRIORITY.patch;
        for (const bump of bumpValues){
            const priority = BUMP_PRIORITY[bump];
            if (void 0 !== priority && priority < highestPriority) {
                highest = bump;
                highestPriority = priority;
            }
        }
        return highest;
    }
    function parseVersionPlan(content) {
        const lines = content.split('\n');
        let firstDelim = -1;
        let secondDelim = -1;
        for(let i = 0; i < lines.length; i += 1)if (lines[i]?.trim() === '---') if (-1 === firstDelim) firstDelim = i;
        else {
            secondDelim = i;
            break;
        }
        if (-1 === firstDelim || -1 === secondDelim) return null;
        const bumps = {};
        const bumpValues = [];
        for(let i = firstDelim + 1; i < secondDelim; i += 1){
            const line = lines[i]?.trim();
            if (line) {
                const match = line.match(/^"?([^":]+)"?\s*:\s*(\S+)/);
                if (match?.[1] && match[2]) {
                    const [, pkg, bump] = match;
                    bumps[pkg] = bump;
                    bumpValues.push(bump);
                }
            }
        }
        const description = lines.slice(secondDelim + 1).join('\n').trim();
        if (!description) return null;
        return {
            bumps,
            description,
            highestBump: getHighestBump(bumpValues)
        };
    }
    async function readVersionPlans() {
        const dir = '.nx/version-plans';
        let files;
        try {
            files = (await (0, promises_namespaceObject.readdir)(dir)).filter((f)=>f.endsWith('.md')).sort();
        } catch  {
            return [];
        }
        const contents = await Promise.all(files.map((file)=>(0, promises_namespaceObject.readFile)((0, external_node_path_namespaceObject.join)(dir, file), 'utf8')));
        return contents.map((content)=>parseVersionPlan(content)).filter((plan)=>null !== plan);
    }
    async function run() {
        const branch = getInput('branch', {
            required: true
        });
        const base = getInput('base', {
            required: true
        });
        const prTitle = getInput('pr-title', {
            required: true
        });
        const banner = getInput('banner');
        const commitMessage = getInput('commit-message') || 'chore(release): prepare release';
        const label = getInput('label') || 'release';
        const token = getInput('token', {
            required: true
        });
        const gh$ = $({
            env: {
                GH_TOKEN: token
            }
        });
        await $`git config user.email npm-publisher@rightcapital.com`;
        await $`git config user.name ${'GitHub Actions[bot]'}`;
        await $`git checkout -B ${branch}`;
        const plans = await readVersionPlans();
        const { projectsVersionData, workspaceVersion, releaseGraph } = await (0, index_js_namespaceObject.releaseVersion)({
            dryRun: false,
            verbose: false,
            gitCommit: false,
            gitTag: false,
            stageChanges: false,
            deleteVersionPlans: false
        });
        await (0, index_js_namespaceObject.releaseChangelog)({
            dryRun: false,
            verbose: false,
            versionData: projectsVersionData,
            version: workspaceVersion,
            releaseGraph,
            gitCommit: false,
            gitTag: false,
            stageChanges: false,
            gitPush: false,
            createRelease: false,
            deleteVersionPlans: true
        });
        await $`pnpm install --no-frozen-lockfile`;
        await $`git add .`;
        try {
            await $`git commit -m ${commitMessage}`;
        } catch  {
            core_info('No changes to commit');
        }
        await $`git push origin ${branch} --force`;
        const body = composePrBody(banner, projectsVersionData, plans);
        await (0, promises_namespaceObject.writeFile)('pr-body.md', body);
        let prNumber = '';
        try {
            const { stdout } = await gh$`gh pr list --head ${branch} --json number --jq ${".[0].number // empty"}`;
            prNumber = stdout.trim();
        } catch  {}
        let prUrl = '';
        if (prNumber) {
            await gh$`gh pr edit ${prNumber} --body-file pr-body.md`;
            const result = await gh$`gh pr view ${prNumber} --json url --jq ${'.url'}`;
            prUrl = result.stdout.trim();
        } else {
            const result = await gh$`gh pr create --base ${base} --head ${branch} --title ${prTitle} --body-file pr-body.md --label ${label}`;
            prUrl = result.stdout.trim();
            const match = prUrl.match(/\/pull\/(\d+)$/);
            if (match?.[1]) [, prNumber] = match;
        }
        setOutput('pr-url', prUrl);
        setOutput('pr-number', prNumber);
        core_info(`PR URL: ${prUrl}`);
        core_info(`PR Number: ${prNumber}`);
    }
    run().catch((error)=>{
        setFailed(error instanceof Error ? error.message : String(error));
    });
})();
for(var __rspack_i in __webpack_exports__)exports[__rspack_i] = __webpack_exports__[__rspack_i];
Object.defineProperty(exports, '__esModule', {
    value: true
});
